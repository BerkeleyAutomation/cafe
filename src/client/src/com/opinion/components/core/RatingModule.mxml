<?xml version="1.0" encoding="utf-8"?>
<mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:spinner="com.opinion.components.spinner.*" xmlns:utils="com.opinion.utils.*" xmlns:core="com.opinion.components.core.*" xmlns:panel="com.visualempathy.extensions.panel.*" xmlns:ext="nl.wv.extenders.panel.*">
	<mx:states>
		<mx:State name="stats" enterState="initState()" exitState="exitState()"/>
		<mx:State name="profile" enterState="initState()" exitState="exitState()"/>
		<mx:State name="suggestions" enterState="initState()" exitState="exitState()"/>
		<mx:State name="notifications" enterState="initState()" exitState="exitState()"/>
	</mx:states>
	<mx:Script>
		<![CDATA[
			import mx.events.CloseEvent;
			import mx.rpc.events.ResultEvent;
			import mx.controls.sliderClasses.Slider;
			import mx.collections.ArrayCollection;
			import mx.containers.Box;
			import mx.core.BitmapAsset;
			import mx.containers.HBox;
			import mx.controls.Image;
			import mx.events.FlexEvent;
			import mx.containers.Canvas;
			import mx.controls.Label;
			import mx.controls.Button;
			import mx.controls.HSlider;
			import mx.controls.Alert;
			import mx.events.SliderEvent;
			import mx.controls.Text;
			import mx.rpc.http.HTTPService;
			import mx.rpc.events.FaultEvent;
			import com.adobe.serialization.json.JSON;
			import com.opinion.utils.AuthenticationUtils;
			import com.opinion.utils.ConversionUtils;
			import com.opinion.utils.DisplayUtils;
			import com.opinion.utils.HTTPUtils;
			import com.opinion.utils.MathUtils;
            import com.opinion.settings.Constants;
            import com.opinion.settings.Configuration;
            import com.opinion.utils.Log;
			import com.opinion.utils.ExtendedHTTPService;
			
			
			public var statements:Array = [];
			public var statementPKs:Array = [];
			public var shortStatements:Array = [];
			public var sliders:Array = [];
			public var initialStatementsRated:Dictionary = new Dictionary();
			public var initialCommentEdited:Boolean = false;
			public var backgroundSliders:Array = [];
			public var sliderCanvases:Array = [];
			private var showCommentAlert:Boolean = false;
			[Bindable] private var editCommentModeEnabled:Boolean = false;
			private var opinionMap:OpinionMap = null;
			
			private var sendingComment:Boolean = false;
			
			private var loadRatings:Boolean = false;
			private var charCountLive:int = 0;
			
			//public static const pinImageUnpinned:String = "assets/pin/pin_unpinned.png";
			//public static const pinImagePinned:String = "assets/pin/pin_pinned.png";
            //[Bindable] public static var pinImage:String = pinImageUnpinned;
            
            public var ratingModuleShrunk:Boolean = false;
            
            [Embed(source="assets/slider/gil-slider-dot-disabled.png")] public static const BACKGROUND_SLIDER_VISIBLE:Class;
            [Embed(source="assets/slider/invisible.png")] public static const BACKGROUND_SLIDER_INVISIBLE:Class;

			/*
    		[Embed(source="assets/img/edit-default.png")] public static const EDIT:Class;
    		[Embed(source="assets/img/edit-rollover.png")] public static const EDIT_OVER:Class;            
            [Embed(source="assets/img/save-default.png")] public static const SAVE:Class;
    		[Embed(source="assets/img/save-rollover.png")] public static const SAVE_OVER:Class;
			*/
			
			public const SHRINK_LABEL:String = "Contract to Hide Sliders";
			public const GROW_LABEL:String = "Expand to Show Sliders";
			
			[Bindable] private var NUM_SLIDERS_PER_PAGE:int = 3;
			[Bindable] public var currentPage:int = 0;
			
			[Bindable]private var navigationList:ArrayCollection = new ArrayCollection([{'title': Configuration.YOUR_PROFILE_TITLE, 'state' : 'profile'},
																		      {'title': 'Your Notifications', 'state' : 'notifications'},
																			  {'title': '', 'state' : 'suggestions'},
																			  {'title': 'My Statistics', 'state' : 'stats'}]);
			[Bindable] public var navigationIndex:int = 0;
			
			[Bindable] private var bottomState:String = "";
			private static const BOTTOM_BOX_HEIGHT:int = 195;
			
			[Bindable] public var newNotifications:Boolean = false;
			private var saveButtonClicked:Boolean = false;
			
			public var statementMeans:Array = []
			
			private function initState():void
			{
				// Refresh on each state change
				this.parentApplication.refreshNotifications();
				
				switch (currentState) 
				{
					case 'profile':
						opinionsButton.selected = true;
						switchBottomState('opinions');
						break;
					case 'suggestions':
						suggestionsButton.selected = true;
						break;
					case 'stats':
						statsButton.selected = true;
						this.parentApplication.refreshStats();
						break;
					case 'notifications':
						notificationsButton.selected = true;
						break;
				}
			}
			
			private function exitState():void
			{
				switch (currentState) {
					case 'profile':
						opinionsButton.selected = false;
						break;
					case 'suggestions':
						suggestionsButton.selected = false;
						break;
					case 'stats':
						statsButton.selected = false;
						break;
					case 'notifications':
						notificationsButton.selected = false;
						break;
					default:
						break;
				}
			}
			
			public function showSliderPage(page:int):void
			{
				for(var i:int = 0; i< sliders.length; i++)
				{
					if(i >= page * NUM_SLIDERS_PER_PAGE && i < (page + 1) * NUM_SLIDERS_PER_PAGE)
					{
						VBox(statementsAndSliders.getChildAt(i)).visible = true;
						VBox(statementsAndSliders.getChildAt(i)).includeInLayout = true;
					}
					else
					{
						VBox(statementsAndSliders.getChildAt(i)).visible = false;
						VBox(statementsAndSliders.getChildAt(i)).includeInLayout = false;
					}
				}
			}
			
			public function saveOrEditComment():void {
				if (editCommentModeEnabled) {
					if (!sendingComment) 
					{
						saveButtonClicked = true;
						sendComment();
					}
				}
				else {
					enableEditCommentMode();
				}
			}
			
			public function sendComment():void {
				showSaveCommentLoadingButton();
				sendingComment = true;

			    var parameters:Object = new Object();
				if(Configuration.COMMENT_TITLES && edittitle.text != '')
				{
					parameters['comment'] = "<" + edittitle.text + ">"+ commentInput.text;
					title.text = edittitle.text;
				}
				else
				{
					parameters['comment'] = commentInput.text;
					title.text = edittitle.text;
				}
	            
	            
	            // Set the discussion statement
	            if (this.parentApplication.opinionMap.selectedDiscussionStatementId == -1)
	            	saveComment.url = this.parentApplication.httpUtils.getServiceUrl('os/savecomment/' + this.parentApplication.opinionSpaceId + '/');
	            else
	            	saveComment.url = this.parentApplication.httpUtils.getServiceUrl('os/savecomment/' + this.parentApplication.opinionSpaceId + '/' + this.parentApplication.opinionMap.selectedDiscussionStatementId + '/');
	            
	            if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
	            
				saveComment._retry_function = sendComment;
				saveComment._failure_function = sendCommentFailed;
				saveComment.maxBackOff = true;
	            saveComment.send(parameters);
			}
			
			private function sendCommentFailed():void
			{
				sendingComment = false;	
				disableEditCommentMode();
				
				if(saveComment.backOffTimer > 32)
				{
					setSaveCommentStatus("Save failed");
					setTimeout(clearSaveCommentStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
					return;
				}
				
				for(var i:int = 0; i<saveComment.backOffTimer; i++)
					setTimeout(displayCountDown,i*1000,saveComment.backOffTimer - i);
				
			}
			
			private function displayCountDown(left:int):void
			{
				setSaveCommentStatus("Network error retrying in: " + left + "s");
			}
			
			private function handleSaveComment():void {
				var decodedResult:Object = JSON.decode(saveComment.lastResult.toString());
				saveComment.disconnect();
				
				var success:Boolean = AuthenticationUtils.handleErrorsNoFields(decodedResult, this);

				// TODO: Better error handling
				if(AuthenticationUtils.resultIsAuthRequired(decodedResult))
					return;

				sendingComment = false;				
				if (success) {
					if(saveButtonClicked)
					{
						disableEditCommentMode();
						saveButtonClicked = false;
					}
                    setSaveCommentStatus(Constants.SAVE_COMMENT_STATUS_DONE);
                                   
					// Set the user's own OpinionMap comment to the value of the comment field
					opinionMap.myComment = commentInput.text;
					
					// Update the user dot size
					// Three scenarios:
					// 1) the comment isn't changed, but they clicked save -> same rating so same size
					// 2) the comment is new from having no comment before -> smallest size to default size
					// 3) the comment is new from an old comment -> some size to default size
					this.parentApplication.getUserCommentScore.send();

					// Wait some time before clearing the save status (i.e. the "Saved" message)
					setTimeout(clearSaveCommentStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
					
					// refresh the history
					if (Configuration.ALLOW_EDIT_COMMENT)
					{
						refreshHistory(decodedResult['prev_comments']);
						switchBottomState('history');
					}
				}
				else {
					showSaveCommentButton();
				}
			}			
			
			/**
			 * Save the current values of the sliders to the database
			 */
			public function sendRating(statement_id:int, rating:Number):void {
				saveRatingsStatus.text = Constants.SAVE_RATINGS_STATUS_LOADING;

			    var parameters:Object = new Object();
				parameters['statement_id'] = statement_id;
				parameters['rating'] = rating;
	            
	            saveRating.addEventListener(ResultEvent.RESULT, function(event:ResultEvent):void {handleSaveRating(statement_id)});
	            saveRating.url = this.parentApplication.httpUtils.getServiceUrl('os/saverating/' + this.parentApplication.opinionSpaceId + '/');
	            
	            if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
	            
	            saveRating.send(parameters);
			}
			
			private function handleSaveRating(statement_id:int):void {
				var decodedResult:Object = JSON.decode(saveRating.lastResult.toString());
				saveRating.disconnect();
				
				var success:Boolean = AuthenticationUtils.handleErrorsNoFields(decodedResult, this);
				
				// TODO: Better error handling
				if(AuthenticationUtils.resultIsAuthRequired(decodedResult))
					return;
				
				if (success) {
					saveRatingsStatus.text = Constants.SAVE_RATINGS_STATUS_DONE;
					setTimeout(clearSaveRatingsStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
				}
				else {
					saveRatingsStatus.text = Constants.SAVE_RATINGS_STATUS_ERROR;
					setTimeout(clearSaveRatingsStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
				}
			}
			
			private function enableEditCommentMode():void {
				// Set flag
				editCommentModeEnabled = true;
				
				// Enable text editing
                //commentInput.selectable = true;
                commentInput.editable = true;
                
                setSaveCommentStatus(Constants.SAVE_COMMENT_STATUS_DEFAULT);
                
                showSaveCommentButton();
                
                charCount.visible = true;
				edittitle.visible = true;
				edittitle.includeInLayout = true;
				edittitle.text = title.text;
				title.text = "";
			}
			
			/**
			 * Disables edit mode by disabling all the sliders and the comment field,
			 * showing the edit button, and changing the images appropriately
			 * Also hides the faint slider in the background
			 */
			public function disableEditCommentMode():void {
                // Set flag
                editCommentModeEnabled = false;
                
                // Disable text editing
                //commentInput.selectable = false;
                commentInput.editable = false;
                
                clearSaveCommentStatus();
                
                showEditCommentButton();
                
                charCount.visible = false;
				
				edittitle.visible = false;
				edittitle.includeInLayout = false;
			}
			
			/**
			 * Shows a loading message as the label of the save/edit button
			 */
			private function showSaveCommentLoadingButton():void {
				setSaveCommentStatus(Constants.SAVE_COMMENT_BUTTON_LOADING_LABEL);
			}
			
			/**
			 * Turns the save/edit button into save
			 */
			private function showSaveCommentButton():void {
				saveEditButton.label = "Save";
			}
			
			/**
			 * Turns the save/edit button into edit
			 */
			private function showEditCommentButton():void {
				saveEditButton.label = "Edit";
			}
			
			/**
			 * Shows the argument string as the save status message
			 */
			private function setSaveCommentStatus(status:String):void {
				saveCommentStatus.visible = true;
				saveCommentStatus.text = status;
			}
			
			private function setSaveRatingsStatus(status:String):void {
				saveRatingsStatus.visible = true;
				saveRatingsStatus.text = status;
			}
			
			/**
			 * Clears the save status message
			 */
			private function clearSaveCommentStatus():void {
				saveCommentStatus.visible = true;
				saveCommentStatus.text = Constants.SAVE_COMMENT_STATUS_DEFAULT;
			}
			
			private function clearSaveRatingsStatus():void {
				saveRatingsStatus.visible = true;
				saveRatingsStatus.text = Constants.SAVE_RATINGS_STATUS_DEFAULT;
			}

			/**
			 * Loads the slider values from the DB and disables edit mode, if appropriate
			 */
			public function refreshRatingModule(userRatingsDecoded:Array, userCommentDecoded:Array, discussionStatementText:String, userCommentRevisions:Array):void {
				var stmtid:int = 0;
				var rating:Dictionary = new Dictionary();
				var areRatingsInDB:Boolean = false;
				for (var i:int = 0; i <  userRatingsDecoded.length; i++) {
					stmtid = userRatingsDecoded[i][0];
					rating[stmtid.toString()] = userRatingsDecoded[i][1];
					areRatingsInDB = true;
				}
				
				var areInitialStatementsRated:Boolean = false;
				for (var key:String in initialStatementsRated) {
					areInitialStatementsRated = true;
				}
			
				// Handle refreshing the ratings
				if (areRatingsInDB) {	// If there are ratings in the database, load them
					//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "USER_RATINGS_LOADED_FROM_DB");
					
					for (i = 0; i < this.parentApplication.numStatements; i++) { // this assumes that statementPKs is sorted
						// If the rating is in the database
						if (rating[statementPKs[i].toString()] != null) {
							sliders[i].value = rating[statementPKs[i].toString()];
						}
						else {
							sliders[i].value = Constants.DEFAULT_SLIDER_VALUE;
						}
					}
				}
				// If there are no ratings in the database for the user, and the initial statements were rated
				// and not yet saved, then save them
				else if (areInitialStatementsRated) {
					//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "INITIAL_USER_RATINGS_SAVED");
					
					for (i = 0; i < sliders.length; i++) {
						// If the slider has been rated, save its position to the DB
						if (initialStatementsRated[sliders[i].name.toString()] != null) {
							sendRating(int(sliders[i].name), sliders[i].value);
							delete initialStatementsRated[sliders[i].name.toString()];
						}
						// If the slider has not been rated, don't do anything
						else {}
					}
				}
				// Otherwise, clear the sliders if this is a user logging in. If the user did not visit the statements page, then
				// we need to clear the sliders
				else if (this.parentApplication.refreshFromLogin) {
					for (i = 0; i < sliders.length; i++) 
						sliders[i].value = Constants.DEFAULT_SLIDER_VALUE;
				}
				
				// Handle the response to the discussion question
				if (userCommentDecoded.length != 0) { // If the response is in the database
					//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "USER_COMMENT_LOADED_FROM_DB");
					
					//commentInput.text = userCommentDecoded[0];
					var comment:String = userCommentDecoded[0];
					
					if(Configuration.COMMENT_TITLES && comment.charAt(0) == '<' && comment.indexOf('>') != -1)
					{
						title.text = comment.substring(1,comment.indexOf('>'));
						commentInput.text = comment.substring(comment.indexOf('>')+1,comment.length);
					}
					else
					{
						title.text = "";
						commentInput.text = comment;
					}
					
					disableEditCommentMode();
				} 
				else if (initialCommentEdited) { // If the user edited the input box on the statements page
					//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "INITIAL_USER_COMMENT_SAVED");
					sendComment();
					initialCommentEdited = false;
				}
				else if (userCommentDecoded.length == 0 || this.parentApplication.refreshFromLogin) {
					// Case 1: with multiple discussion questions, if the user has no comment, we need to clear the text
					// because the user may have had a response to the previously selected discussion question
					
					// Case 2: if the user is logging in and has no comment, we need to clear the comment text
					
					// Display a popup to prompt a user to answer the current discussion question
					// if the user has no comment, but has ratings (so they don't see both the popup and the statements page)
					
					//if (areRatingsInDB) DisplayUtils.displayPopup(this.parentApplication, 'addResponse');
					 
					commentInput.text = "";
					//enableEditCommentMode();
				}
				
				moveBackgroundSlidersToForegroundPositions();
				
				showSliderPage(currentPage);
				
				// Update history
				refreshHistory(userCommentRevisions);
				
				// Set to profile state
				switchToState('stats');
			}
			
			/**
			 * Places the user dot according to the current values of the sliders
			 */
			public function placeUserDot():void {
				opinionMap.placeUserDot(ConversionUtils.sliderToUserRating(sliders), opinionMap.curUserDot);
			}
			
			public function createAndPlaceFakeUserDot():void{
				if(opinionMap.fakeUserDot == null)
				{
					opinionMap.createFakeUserPoint(0,0);
				}
				opinionMap.placeUserDot(ConversionUtils.sliderToUserRating(sliders), opinionMap.fakeUserDot);	
			}
			
			/**
			 * Places the background user dot according to the current values of the backgroundSliders
			 */
			public function placeBackgroundUserDot():void {
//				opinionMap.placeUserDot(ConversionUtils.sliderToUserRating(backgroundSliders), opinionMap.backgroundCurUserDot);
			}
			
			/**
			 * Handler for when the statement slider changes, that calls placeUserDot
			 */
			public function sliderChange(event:SliderEvent):void {
				if(this.parentApplication.isUserAuthenticated)
				{
					placeUserDot();
				}
				else
				{				
					if(opinionMap.fakeUserDot != null && opinionMap.container.contains(opinionMap.fakeUserDot))
					{
						opinionMap.placeUserDot(ConversionUtils.sliderToUserRating(sliders), opinionMap.fakeUserDot);
						
						//not in projector mode
						if(this.parentApplication.opinionMap.plotCanvas.width > 1100)
							opinionMap.moveToFront(opinionMap.fakeUserDot);
					}
				}
				
				this.parentApplication.opinionMap.hideArrowBox();
				
				if (!Configuration.ALLOW_EDIT_SLIDERS)
				{
					for (var i:int=0; i < backgroundSliders.length; i++)
						showBackgroundSliderThumb(backgroundSliders[i]);
						
					// show revert button
					revertButton.visible = true;
					revertButton.includeInLayout = true;
				}
			}
			
			/**
			 * Handler for when the statement slider value changes, that calls placeUserDot
			 */
			public function sliderValueChange(event:FlexEvent):void {
				if(this.parentApplication.isUserAuthenticated)
				{
					placeUserDot();
				}
				else
				{				
					if(opinionMap.fakeUserDot != null)
					{
						opinionMap.placeUserDot(ConversionUtils.sliderToUserRating(sliders), opinionMap.fakeUserDot);
						//opinionMap.moveToFront(opinionMap.fakeUserDot);
					}
				}
				
				if (!Configuration.ALLOW_EDIT_SLIDERS)
				{
					for (var i:int=0; i < backgroundSliders.length; i++)
						showBackgroundSliderThumb(backgroundSliders[i]);
						
					// show revert button
					revertButton.visible = true;
					revertButton.includeInLayout = true;	
				}	
			}
			
			public function sliderRelease(event:SliderEvent):void {
				var targetSlider:Slider = Slider(event.target);
				var targetSliderValue:Number = targetSlider.value;
				var targetSliderStatementId:int = int(targetSlider.name);
			
				// Save the rating change
				if (Configuration.ALLOW_EDIT_SLIDERS)
					sendRating(targetSliderStatementId, targetSliderValue);
			}
			
			/**
			 * Handler for when the backround slider value changes
			 */
			public function backgroundSliderValueChange(event:FlexEvent):void {
				placeBackgroundUserDot();
			}
			
			public function modifyStatementDisplayText(textStyleName:String, truncate:Boolean, width:int, percentWidth:int, maxHeight:int, statementDisplayText:Text, statementNum:int, statementText:String):Text {
				statementDisplayText.id = "st" + statementNum.toString();
	        	
	        	// Set the tool tips
	        	statementDisplayText.toolTip = statements[statementNum-1];
        		statementDisplayText.text = statementText; 
	        	statementDisplayText.styleName = textStyleName;
	        	
	        	if (truncate) {
	        		statementDisplayText.truncateToFit = true;
	        	}
	        	else {
	        		statementDisplayText.truncateToFit = false;
	        	}
	        	
	        	if (width != -1) {
	        		statementDisplayText.width = width;
	        	}
	        	
	        	if (percentWidth != -1) {
	        		statementDisplayText.percentWidth = percentWidth;
	        	}
	        	
	        	if (maxHeight != -1) {
	        		statementDisplayText.maxHeight = maxHeight;
	        	}
				
	        	return statementDisplayText;
			}
			
			/**
			 * Creates the statement labels (above each of the rating sliders)
			 */
			public function createStatementDisplayText(textStyleName:String, truncate:Boolean, width:int, percentWidth:int, maxHeight:int, statementNum:int, statementText:String):Text {
				var statementDisplayText:TruncatedText = new TruncatedText();
				
	        	return modifyStatementDisplayText(textStyleName, truncate, width, percentWidth, maxHeight, statementDisplayText, statementNum, statementText);
			}
			
			/**
			 * Creates an HBox that contains a slider, backgroundSlider and thumbs up/down images
			 */
			public function createSliderHBox(slider:OpinionSlider, backgroundSlider:OpinionSlider):HBox {
				var sliderHBox:HBox = new HBox();
	            sliderHBox.percentWidth = 100;
	            sliderHBox.styleName = "sliderHBox";
				
				//var leftSliderImage:Image = new Image();
				//var thumbsDownImageBMP:BitmapAsset = new Constants.THUMBS_DOWN_IMAGE() as BitmapAsset;
				//leftSliderImage.source = thumbsDownImageBMP;

				//var rightSliderImage:Image = new Image();
				//var thumbsUpImageBMP:BitmapAsset = new Constants.THUMBS_UP_IMAGE() as BitmapAsset;
				//rightSliderImage.source = thumbsUpImageBMP;
				
				var sliderCanvas:Canvas = new Canvas();
				sliderCanvas.percentWidth = 100;
				sliderCanvas.addChild(backgroundSlider);
				sliderCanvas.addChild(slider);
				
				sliderCanvases.push(sliderCanvas);
				
				//sliderHBox.addChild(leftSliderImage); 
				sliderHBox.addChild(sliderCanvas);
				//sliderHBox.addChild(rightSliderImage);
				
				return sliderHBox;
			}
			
			/**
			 * Creates a slider, sets the intial value of the slider, and adds it to the global sliders array
			 */
			public function createSlider(sliderStyleName:String, sliders:Array, sliderValueChangeFunction:Function, sliderChangeFunction:Function, sliderReleaseFunction:Function, statementId:int, sliderValue:Number):OpinionSlider {
				var slider:OpinionSlider = new OpinionSlider();
				slider.name = statementId.toString(); 
				slider.styleName = sliderStyleName;
				slider.enabled = enabled;
				slider.percentWidth = 100;
				if (Configuration.RATING_MODULE_SLIDER_TOOLTIP_ENABLED)
					slider.toolTip = Configuration.RATING_MODULE_SLIDER_TOOLTIP;
				slider.addEventListener(FlexEvent.VALUE_COMMIT, sliderValueChangeFunction);
				slider.addEventListener(SliderEvent.CHANGE, sliderChangeFunction);
				slider.addEventListener(SliderEvent.THUMB_RELEASE, sliderReleaseFunction);
				
				if (sliderValue != -1) {
                    slider.value = sliderValue;
    			}
                else {
                    slider.value = Constants.DEFAULT_SLIDER_VALUE;
                }
				
				// Add this slider to the global sliders array
				sliders.push(slider);
				
				return slider;
			}
			
			/**
			 * Creates a slider, sets the intial value of the slider, and adds it to the global sliders array
			 */
			public function createVSlider(sliderStyleName:String, sliders:Array, sliderValueChangeFunction:Function, sliderChangeFunction:Function, sliderReleaseFunction:Function, statementId:int, sliderValue:Number):OpinionSlider {
				var slider:OpinionSlider = new OpinionSlider();
				slider.name = statementId.toString(); 
				slider.styleName = sliderStyleName;
				slider.enabled = enabled;
				slider.percentWidth = 100;
				if (Configuration.RATING_MODULE_SLIDER_TOOLTIP_ENABLED)
					slider.toolTip = Configuration.RATING_MODULE_SLIDER_TOOLTIP;
				slider.addEventListener(FlexEvent.VALUE_COMMIT, sliderValueChangeFunction);
				slider.addEventListener(SliderEvent.CHANGE, sliderChangeFunction);
				slider.addEventListener(SliderEvent.THUMB_RELEASE, sliderReleaseFunction);
				
				if (sliderValue != -1) {
					slider.value = sliderValue;
				}
				else {
					slider.value = Constants.DEFAULT_SLIDER_VALUE;
				}
				
				// Add this slider to the global sliders array
				sliders.push(slider);
				
				return slider;
			}
			
			public function createLargeSlider(sliderStyleName:String, sliders:Array, sliderValueChangeFunction:Function, sliderChangeFunction:Function, sliderReleaseFunction:Function, statementId:int, sliderValue:Number):LargeOpinionSlider {
				var slider:LargeOpinionSlider = new LargeOpinionSlider();
				slider.name = statementId.toString(); 
				slider.styleName = sliderStyleName;
				slider.enabled = enabled;
				slider.addEventListener(FlexEvent.VALUE_COMMIT, sliderValueChangeFunction);
				slider.addEventListener(SliderEvent.CHANGE, sliderChangeFunction);
				slider.addEventListener(SliderEvent.THUMB_RELEASE, sliderReleaseFunction);
				
				if (sliderValue != -1) {
                    slider.value = sliderValue;
    			}
                else {
                    slider.value = Constants.DEFAULT_SLIDER_VALUE;
                }
				
				// Add this slider to the global sliders array
				sliders.push(slider);
				
				return slider;
			}
			
			private function hideBackgroundSliderThumb(backgroundSlider:OpinionSlider):void {
				backgroundSlider.setStyle("thumbDisabledSkin", BACKGROUND_SLIDER_INVISIBLE);
			}
			
			private function showBackgroundSliderThumb(backgroundSlider:OpinionSlider):void {
				backgroundSlider.setStyle("thumbDisabledSkin", BACKGROUND_SLIDER_VISIBLE);
			}
			
			public function resetSlidersToSaved():void {
				// Log that the sliders were reset to their saved positions
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "SLIDERS_RESET_TO_SAVED");
				
				for (var i:int = 0; i < sliders.length; i++) {
					sliders[i].value = backgroundSliders[i].value;
				}
				
				// hide revert button
				revertButton.visible = false;
				revertButton.includeInLayout = false;
			}
			
			public function moveBackgroundSlidersToForegroundPositions():void {
				for (var i:int = 0; i < sliders.length; i++) {
					backgroundSliders[i].value = sliders[i].value;
				}
				
				// hide revert button
				revertButton.visible = false;
				revertButton.includeInLayout = false;
			}
			
			public function createBackgroundSlider(sliderStyleName:String, slider:OpinionSlider):OpinionSlider {
				var backgroundSlider:OpinionSlider = new OpinionSlider();
				backgroundSlider.thumbCount = 1;
	            backgroundSlider.enabled = false;
	            backgroundSlider.percentWidth = 100;
	            backgroundSlider.value = slider.value;
	            backgroundSlider.styleName = sliderStyleName;
	            backgroundSlider.addEventListener(FlexEvent.VALUE_COMMIT, backgroundSliderValueChange);
	            hideBackgroundSliderThumb(backgroundSlider);
	            
	           	// Add this backgroundSlider to the global backgroundSliders array
				backgroundSliders.push(backgroundSlider);
	            
	            return backgroundSlider;
			}
            
			public function createRatingModule(opinionMap:OpinionMap, statementsDecoded:Array, discussionStatementDecoded:String, userRatingsDecoded:Array, userCommentDecoded:Array, userCommentRevisions:Array) {			    
			    this.opinionMap = opinionMap;			    
			    try {
			        for (var i:int = 0; i < this.parentApplication.numStatements; i++) {
			            var statementNum:int = i + 1;
			            var statementId:int = int(statementsDecoded[i][0]);
			            statementPKs[i] = statementId;
			            var statementText:String = statementsDecoded[i][1];
			            statements[i] = statementText;
						
						if(statementsDecoded.length == 2)
						{
							var axis:String = MathUtils.twoSliderXorY(MathUtils.compressEigenvectorsDecoded(this.parentApplication.eigenvectorsDecoded),i);
							if(axis == 'y')
								opinionMap.vsliderText.text = statementText;
							else if (axis == 'x')
								opinionMap.hsliderText.text = statementText;
						}
						
						var shortStatement:String = statementsDecoded[i][2];
			            shortStatements[i] = shortStatement;
						
						statementMeans[i] = statementsDecoded[i][3];
			            
			            var statementDisplayText:Text = createStatementDisplayText("ratingModuleStatement", true, -1, -1, -1, statementNum, shortStatement);
						var slider:OpinionSlider = createSlider("ratingModuleSlider", sliders, sliderValueChange, sliderChange, sliderRelease, statementId, Constants.DEFAULT_SLIDER_VALUE);
						var backgroundSlider:OpinionSlider = createBackgroundSlider("ratingModuleSliderBackground", slider);
						var sliderHBox:HBox = createSliderHBox(slider, backgroundSlider);
						
						var separator:VBox = createHorizontalSeparator();
						
						var statementSliderContainer:VBox = new VBox();
						statementSliderContainer.addChild(statementDisplayText);
						statementSliderContainer.addChild(sliderHBox);
						statementSliderContainer.addChild(separator);
						statementSliderContainer.setStyle('verticalAlign', 'middle');
						statementSliderContainer.setStyle('horizontalAlign', 'center');
						statementSliderContainer.setStyle('verticalGap', 0);
						statementSliderContainer.percentWidth = 100;
						statementsAndSliders.addChildAt(statementSliderContainer,i);
			        }
			        statementPKs = statementPKs.sort(Array.NUMERIC);
			        
			        // REMOVED discussion question 2011.08.20
			        //modifyStatementDisplayText("commentIntroText", true, -1, -1, -1, discussionStatementDisplayText, 6, discussionStatementDecoded);
			        
			        // 2011.08.02 - Don't show the statement sliders for 2 sliders
			        // Allow user to place their point on the 2D axis
			        			        
			        placeUserDot();
			        placeBackgroundUserDot()
			    }
			    catch (e:RangeError) {
			    	// TODO: log error
			    }
                
                this.refreshRatingModule(userRatingsDecoded, userCommentDecoded, discussionStatementDecoded, userCommentRevisions);
			}
			
			/**
			 * Disables the sliders in the rating module
			 */ 
			public function disableSliders():void {
				for (var i:int=0; i<sliders.length; i++) {
					sliders[i].enabled = false;
				}
			}
			
			/**
			 * Enables the sliders in the rating module
			 */ 
			public function enableSliders():void {
				for (var i:int=0; i<sliders.length; i++) {
					sliders[i].enabled = true;
				}
			}
			
			private function handleFaultOrTimeout(event:FaultEvent):void{
				//this.parentApplication.log.log(Log.ERROR, this.parentApplication.opinionSpaceId, "HTTPServiceError: " + event.target.method.toString()+" "+ event.target.url.toString() + ":" + event.fault.faultString);
			}
			
			private function showStatements(event:Event):void
			{		
				if(Configuration.LOGGED_IN_SLIDERS_ENABLED && this.parentApplication.numStatements == 2)
				{
					this.parentApplication.opinionMap.showFlareVisSliders();
					this.parentApplication.opinionMap.placingPoint = true;
					this.parentApplication.opinionMap.vslider.enabled = true;
					this.parentApplication.opinionMap.hslider.enabled = true;
					
					// Show the correct button
					if (this.parentApplication.opinionMap.hasFinishedStatements)
					{
						provide_opinions_steady.visible = false;
						provide_opinions_steady.includeInLayout = false;
						loggedin_placing_point_steady.visible = true;
						loggedin_placing_point_steady.includeInLayout = true;
					} else
					{
						provide_opinions.visible = false;
						provide_opinions.includeInLayout = false;
						loggedin_placing_point.visible = true;
						loggedin_placing_point.includeInLayout = true;
					}
					
					// Allow click and drag
					this.parentApplication.opinionMap.curUserDot.addEventListener(MouseEvent.MOUSE_DOWN, this.parentApplication.opinionMap.placingPointDown);
				}
				else
				{
					this.parentApplication.opinionMap.mapOverlay.showStatementsPage(event)
				}
			}
			
			//saves slider values for a loggedIn user placing points
			private function submitSliderValues():void
			{
				// Show the correct button
				if (this.parentApplication.opinionMap.hasFinishedStatements)
				{
					provide_opinions_steady.visible = true;
					provide_opinions_steady.includeInLayout = true;
					loggedin_placing_point_steady.visible = false;
					loggedin_placing_point_steady.includeInLayout = false;
				} else
				{
					this.provide_opinions.visible = true; //Keep in mind while the parent objects visibility matters this is so if someone else logs in stuff looks ok
					this.provide_opinions.includeInLayout = true;
					this.loggedin_placing_point.visible = false;
					this.loggedin_placing_point.includeInLayout = false;
				}
				
				// Save ratings and clear after updating the button (hasFinishedStatements is updated in this call) 
				this.parentApplication.opinionMap.saveRatingsAndClear();
				
				if(Configuration.LOGGED_IN_SLIDERS_ENABLED && this.parentApplication.numStatements == 2)
				{
					// remove click and drag
					this.parentApplication.opinionMap.curUserDot.removeEventListener(MouseEvent.MOUSE_DOWN, this.parentApplication.opinionMap.placingPointDown);	
				}
			}
			
			public function nextPage():void
			{
				if(currentPage < this.parentApplication.numStatements/NUM_SLIDERS_PER_PAGE - 1)
					currentPage++;
				showSliderPage(currentPage);
			}
			
			public function prevPage():void
			{
				if(currentPage > 0)
					currentPage--;
				showSliderPage(currentPage);
			}
						
			public function resetSliders():void
			{
				for (var i:int = 0; i < sliders.length; i++) {
					sliders[i].value = Constants.DEFAULT_SLIDER_VALUE;
				}
			}
			
			public function switchToState(state:String):void
			{
				for(var i:int; i< navigationList.length; i++)
					if (navigationList.getItemAt(i).state == state)
					{
						currentState = state;
						navigationIndex = i;
					}
			}
			
			public function refreshHistory(userCommentRevisions:Array):void
			{
				responseHistoryBox.removeAllChildren();
				
				if (userCommentRevisions.length == 0)
				{
					var commentHist:Text = new Text();
					commentHist.text = "You have no previous response revisions.";
					commentHist.percentWidth = 100;
					
					var commentHistBox:VBox = new VBox();
					commentHistBox.percentWidth = 100;
					commentHistBox.setStyle('textAlign', 'center');
					commentHistBox.addChild(commentHist);
					responseHistoryBox.addChild(commentHistBox);
					return;
				}
				
				for(var i:int = 0; i<userCommentRevisions.length; i++)
				{
					var wrapperBox:HBox = new HBox();
					wrapperBox.percentWidth = 100;
					var commentHist:Text = new Text();
					commentHist.percentWidth= 100;
					
					var timestamp:Text = new Text();
					timestamp.percentWidth = 100;
					timestamp.setStyle('textAlign', 'right');
					timestamp.text = userCommentRevisions[i][1];
					
					var commentHistBox:VBox = new VBox();
					commentHistBox.styleName="commentHistoryBox";
					
					if(userCommentRevisions[i][2] == 'comment')
					{
						commentHist.text = userCommentRevisions[i][3] + '\'s updated response:' + '\n' + '\"' + userCommentRevisions[i][0] + '\"';
						wrapperBox.setStyle('horizontalAlign', 'left');
					}
					else
					{
						commentHist.text = userCommentRevisions[i][3] + ' suggested:' + '\n' + '\"' + userCommentRevisions[i][0] + '\"';
						commentHistBox.setStyle('backgroundColor', 0xd2ece1);
						wrapperBox.setStyle('horizontalAlign', 'right');
					}
						
					commentHistBox.percentWidth = 80;
					commentHistBox.addChild(commentHist);
					commentHistBox.addChild(timestamp);					
					wrapperBox.addChild(commentHistBox);
					
					responseHistoryBox.addChild(wrapperBox);
				}
			}
			
			public function switchBottomState(state:String):void
			{
				// Exit state actions
				switch(bottomState) {
					case 'opinions':
						break;
					case 'history':
						break;
				}
				
				bottomState = state;
				
				// Enter state actions
				switch(bottomState) {
					case 'opinions':
						break;
					case 'history':
						break;
				}
			}
			
			private function createHorizontalSeparator():VBox
			{
				var outer:VBox = new VBox();
				var inner:VBox = new VBox();
				
				inner.styleName = "mapLeftPanelHorizontalBoxLine";
				inner.percentWidth = 97;
				inner.height = 1;
				
				outer.percentWidth = 100;
				outer.setStyle('horizontalAlign', 'center');
				outer.addChild(inner);
				return outer;
			}
			
			private function remove_new_line(e:Event):void
			{
				commentInput.text = commentInput.text.replace("\r", "");
				commentInput.text = commentInput.text.replace("\n", " ");
				
				charCountLive = charCountLive + 1;
				if(charCountLive % 30 == 0)
					sendComment();
			}
				
		]]>
	</mx:Script>

	<mx:Fade id="fadeEffect" duration="750"/>
	
	<utils:ExtendedHTTPService id="saveRating" useProxy="false" method="POST" resultFormat="text" requestTimeout="{Configuration.HTTP_REQUEST_TIMEOUT}" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="saveComment" useProxy="false" method="POST" resultFormat="text" result="handleSaveComment()" requestTimeout="{Configuration.HTTP_REQUEST_TIMEOUT}" fault="handleFaultOrTimeout(event)"/>
	
	<mx:VBox id="ratingModuleBox" width="100%" height="100%" verticalGap="0">	
	
		<!-- Upper tool bar -->
		<mx:Canvas id="buttonCanvas" width="100%">
			<mx:Text text="{this.parentApplication.registeredUsername}" fontWeight="bold" fontSize="18"/>
			<mx:HBox horizontalGap="4" width="100%" horizontalAlign="center">
				<utils:LoggedButton id="opinionsButton" name="rating-module-opinions" label="My Comment" styleName="blueButton" click="{switchToState('profile')}"/>
				<utils:LoggedButton id="statsButton" name="rating-module-stats" label="My Stats" styleName="blueButton" click="{switchToState('stats')}" visible="{Configuration.STATS_ENABLED}" includeInLayout="{Configuration.STATS_ENABLED}"/>
				<utils:LoggedButton id="suggestionsButton" name="rating-module-suggestions" label="Comments" styleName="blueButton" click="{switchToState('suggestions'); suggestionModule.switchState('received');}" visible="{Configuration.SUGGESTIONS_ENABLED}" includeInLayout="{Configuration.SUGGESTIONS_ENABLED}"/>
				
				<mx:Canvas visible="false" includeInLayout="false">
					<utils:LoggedButton id="notificationsButton" name="rating-module-notifications" label="Notifications" styleName="blueButton" click="{switchToState('notifications')}"/>
					<mx:HBox top="0" right="0" width="32" height="32" verticalAlign="middle" horizontalAlign="center">
						<mx:Text id="newNotificationsCount" styleName="newNotificationsLabelBox"/>	
					</mx:HBox>				
				</mx:Canvas>
					
			</mx:HBox>
			<mx:Image right="0" top="0" source="{Configuration.CLOSE_BUTTON}" buttonMode="true" click="{this.parentApplication.opinionMap.handlePlotClick()}" visible="{Configuration.VERTICAL_ORIENTATION}" includeInLayout="{Configuration.VERTICAL_ORIENTATION}"/>
		</mx:Canvas>
		
		<mx:VBox width="100%" horizontalAlign="center">
			<mx:VBox styleName="mapLeftPanelHorizontalBoxLine" width="97%" height="1"/>	
		</mx:VBox>
		
		<!-- Title -->
		<mx:HBox width="100%" paddingTop="2" horizontalGap="0" paddingBottom="5">
			<mx:Text text="{String(navigationList.getItemAt(navigationIndex).title).toUpperCase()}" visible="{!Configuration.COMMENT_TITLES}" includeInLayout="{!Configuration.COMMENT_TITLES}" fontSize="19" fontWeight="bold" />
			<mx:Text id="title" text="" visible="{this.title.text !=''}" includeInLayout="{this.title.text !=''}" fontSize="19" fontWeight="bold"/>
			<mx:TextInput id="edittitle" text="" styleName="ratingModuleCommentInputText" visible="{editCommentModeEnabled}" includeInLayout="{editCommentModeEnabled}" fontSize="19" fontWeight="bold" width="250" maxChars="25"/>
			<!--
			<mx:Text text=": STEP 1" fontSize="19" fontWeight="bold" visible="{!(this.parentApplication.opinionMap.hasFinishedComment || this.parentApplication.opinionMap.hasFinishedStatements || !(currentState == 'profile'))}" includeInLayout="{!(this.parentApplication.opinionMap.hasFinishedComment || this.parentApplication.opinionMap.hasFinishedStatements || !(currentState == 'profile'))}"/>
			<mx:Text text=": STEP 2" fontSize="19" fontWeight="bold" visible="{!(this.parentApplication.opinionMap.hasFinishedComment || !this.parentApplication.opinionMap.hasFinishedStatements || !(currentState == 'profile'))}" includeInLayout="{!(this.parentApplication.opinionMap.hasFinishedComment || !this.parentApplication.opinionMap.hasFinishedStatements || !(currentState == 'profile'))}"/>
			-->
		</mx:HBox> 
		
		
		<core:Notifications id="notificationModule" visible="{currentState == 'notifications'}" includeInLayout="{currentState == 'notifications'}" width="100%" height="100%"/>
		<core:Stats id="statsModule" visible="{currentState == 'stats'}" includeInLayout="{currentState == 'stats'}" width="100%" height="100%"/>	
		<core:CommentSuggestion id="suggestionModule" visible="{currentState == 'suggestions'}"	 includeInLayout="{currentState == 'suggestions'}" width="100%" height="100%"/>
	
		<mx:VBox id="ratingPanel" height="100%" width="100%"  visible="{currentState == 'profile'}"	 includeInLayout="{currentState == 'profile'}" >

			<!-- Has not filled out the statements -->
			<mx:VBox width="100%" visible="{!(this.parentApplication.opinionMap.hasFinishedComment || this.parentApplication.opinionMap.hasFinishedStatements)}" includeInLayout="{!(this.parentApplication.opinionMap.hasFinishedComment || this.parentApplication.opinionMap.hasFinishedStatements)}" paddingTop="10">
				<!--<mx:Text text="{String(Configuration.STATEMENTS_NOT_FINISHED_TEXT).toUpperCase()}" width="100%" fontSize="19" fontWeight="bold" />-->
				<mx:HBox width="100%" horizontalAlign="center">
					<utils:LoggedButton id="provide_opinions" styleName="blueButtonLarge" height="55" width="{this.parentApplication.opinionMap.plotCanvas.width * .3 * .75}" name="rating_provide-opinion" label="{Configuration.STATEMENTS_NOT_FINISHED_BUTTON_TEXT}" enabled="true" click="showStatements(event)" />
				</mx:HBox>
				<utils:LoggedButton id="loggedin_placing_point" styleName="blueButtonLarge"  visible="false" includeInLayout="false" height="90" width="{this.parentApplication.opinionMap.plotCanvas.width * .3}" label="Done Placing Point" enabled="true" click="submitSliderValues()" />
			</mx:VBox>
	
			<!-- has not written a comment -->
			<mx:VBox width="100%" visible="{!(this.parentApplication.opinionMap.hasFinishedComment || !this.parentApplication.opinionMap.hasFinishedStatements)}" includeInLayout="{!(this.parentApplication.opinionMap.hasFinishedComment || !this.parentApplication.opinionMap.hasFinishedStatements)}" paddingTop="10">
				<!--<mx:Text text="{String(Configuration.COMMENT_NOT_FINISHED_TEXT).toUpperCase()}" width="100%" fontSize="19" fontWeight="bold" />-->
				<mx:HBox width="100%" horizontalAlign="center">
					<utils:LoggedButton id="respond_to_comment" height="55" width="{this.parentApplication.opinionMap.plotCanvas.width * .3 * .75}" name="rating_respond-to-dis" styleName="blueButtonLarge" label="{Configuration.COMMENT_NOT_FINISHED_BUTTON_TEXT}" enabled="true" click="{this.parentApplication.opinionMap.mapOverlay.showCommentsPage(event)}" />						
				</mx:HBox>
			</mx:VBox>
	
			<!-- comment input -->
			<mx:VBox width="100%" height="100%">
				
				<!-- steady state -->
				<mx:VBox width="100%" height="100%"  visible="{this.parentApplication.opinionMap.hasFinishedComment}" includeInLayout="{this.parentApplication.opinionMap.hasFinishedComment}" showEffect="{fadeEffect}">
					
					<mx:TextArea id="commentInput" change="remove_new_line(event)" paddingLeft="10" styleName="ratingModuleCommentInputText" minHeight="{Configuration.RATING_MODULE_COMMENT_INPUT_TEXT_HEIGHT}" height="100%" width="100%" maxChars="{Configuration.MAX_COMMENT_LENGTH}" visible="{this.parentApplication.opinionMap.hasFinishedComment}" includeInLayout="{this.parentApplication.opinionMap.hasFinishedComment}"/>
					
					<mx:HBox width="100%" horizontalAlign="right" horizontalGap="4" visible="{Configuration.ALLOW_EDIT_COMMENT}" includeInLayout="{Configuration.ALLOW_EDIT_COMMENT}">
						
						<!--<utils:LoggedButton name="rating-module-statements" label="Rate" click="{switchBottomState('opinions')}" visible="{!Configuration.NO_STATEMENTS}" includeInLayout="{!Configuration.NO_STATEMENTS}"/>-->
						<utils:LoggedButton name="rating-module-history" label="History"  visible="{!Configuration.NO_REVISIONS}" includeInLayout="{!Configuration.NO_REVISIONS}" click="{switchBottomState('history')}"/>
						<mx:HBox width="100%" horizontalAlign="right">
							<mx:Label id="saveCommentStatus" text="{Constants.SAVE_COMMENT_STATUS_DEFAULT}"/>
							<mx:Text id="charCount" visible="false" styleName="smallLinksFont" text="{commentInput.text.length + '/'+Configuration.MAX_COMMENT_LENGTH}"/>
							
							<!-- edit comment box -->
							<utils:LoggedButton id="saveEditButton" name="rating-module-save-edit-response" label="Edit" click="{saveOrEditComment()}"/>
						</mx:HBox>
					</mx:HBox>
						
				</mx:VBox>
			</mx:VBox>	
			
			<!-- bottom box -->
			<mx:VBox width="100%" visible="false" includeInLayout="false">
				<!-- statements and sliders -->
				<mx:VBox width="100%" visible="{!(!bottomState == 'opinions' || Configuration.NO_STATEMENTS)}" includeInLayout="{!(!bottomState == 'opinions' || Configuration.NO_STATEMENTS)}" showEffect="{fadeEffect}">
							
					<!-- steady state -->
					<mx:VBox visible="{this.parentApplication.opinionMap.hasFinishedStatements}" includeInLayout="{this.parentApplication.opinionMap.hasFinishedStatements}" height="100%" width="100%" horizontalAlign="left" showEffect="{fadeEffect}">
						
						<mx:VBox width="100%" horizontalAlign="center">
							<mx:VBox styleName="mapLeftPanelHorizontalBoxLine" width="97%" height="1"/>	
						</mx:VBox>
						
						<!-- sliders -->
						<mx:HBox width="100%" horizontalAlign="center">
							<mx:VBox id="statementsAndSliders" verticalGap="0" height="100%" width="100%"/>	
						</mx:HBox>
						
						<!-- box for buttons in 2D case -->
						<mx:VBox id="placingPointButtons" width="100%" includeInLayout="false" visible="false">
							<utils:LoggedButton id="provide_opinions_steady" fontSize="26" height="90" width="{this.parentApplication.opinionMap.plotCanvas.width * .3}" color="{Configuration.USER_DOT_COLOR}" styleName="splashButton" name="rating_provide-opinion-steady" label="Adjust Your Position" click="showStatements(event)" />
							<utils:LoggedButton id="loggedin_placing_point_steady" name="loggedin_placing_point_steady"  visible="false" includeInLayout="false" fontSize="26" height="90" width="{this.parentApplication.opinionMap.plotCanvas.width * .3}" color="{Configuration.USER_DOT_COLOR}" styleName="splashButton" label="Done Placing Point" enabled="true" click="submitSliderValues()" />	
						</mx:VBox>
						<mx:Label id="saveRatingsStatus" styleName="saveRatingsStatus" text="{Constants.SAVE_RATINGS_STATUS_DEFAULT}" visible="{Configuration.ALLOW_EDIT_SLIDERS}" includeInLayout="{Configuration.ALLOW_EDIT_SLIDERS}"/>
						<mx:HBox width="100%" horizontalAlign="right" visible="{!(Configuration.ALLOW_EDIT_SLIDERS || !revertButton.visible)}" includeInLayout="{!(Configuration.ALLOW_EDIT_SLIDERS || !revertButton.includeInLayout)}" showEffect="{fadeEffect}" hideEffect="{fadeEffect}">
							<utils:LoggedButton id="revertButton" label="{Configuration.REVERT_TO_BG_SLIDER_TEXT}" click="resetSlidersToSaved();" visible="false" includeInLayout="false"/>					
						</mx:HBox>
						<mx:HBox width="100%" visible="{this.parentApplication.numStatements > 5}" includeInLayout="{this.parentApplication.numStatements > 5}">
							<utils:LoggedButton label="Prev" styleName="yellowButton" click="prevPage()"/>
							<utils:LoggedButton label="Next" styleName="yellowButton" click="nextPage()"/>
						</mx:HBox>
					</mx:VBox>
				</mx:VBox>
				
				<!-- History Box -->
				<mx:VBox width="100%" visible="{bottomState == 'history'}" includeInLayout="{bottomState == 'history'}" showEffect="{fadeEffect}">
					<mx:VBox visible="{!Configuration.NO_REVISIONS}" includeInLayout="{!Configuration.NO_REVISIONS}">
						<mx:Text text="{'Your Response Activity'}"/>
						<mx:VBox id="responseHistoryBox" paddingLeft="10" width="100%" verticalGap="10"/>
					</mx:VBox>
				</mx:VBox>
				
			</mx:VBox>
			
		</mx:VBox>	
	</mx:VBox>
</mx:Module>
<?xml version="1.0" encoding="utf-8"?>
<mx:Module  xmlns:mx="http://www.adobe.com/2006/mxml"
            xmlns:ns1="com.opinion.components.core.*"
            xmlns:local="com.opinion.components.core.*"
            xmlns:panel="com.visualempathy.extensions.panel.*"
            xmlns:pages="com.opinion.components.pages.*"
            xmlns:code="http://code.google.com/p/flexlib/"
            xmlns:flex="flare.flex.*"
			xmlns:utils="com.opinion.utils.*" 
            xmlns:spinner="com.opinion.components.spinner.*"
			xmlns:core="com.opinion.components.core.*"
            addedToStage="addedToStage()" 
            layout="absolute" currentState="loggedOut" >
    <mx:states>
        <mx:State name="loggedIn" enterState="initState()"/>
        <mx:State name="loggedOut" enterState="initState()"/>
    </mx:states>
    <mx:Script>
        <![CDATA[
			import com.adobe.protocols.dict.Dict;
			import com.adobe.serialization.json.JSON;
			import com.opinion.components.core.RatingModule;
			import com.opinion.components.renderers.PinRenderer;
			import com.opinion.settings.*;
			import com.opinion.settings.Configuration;
			import com.opinion.utils.AuthenticationUtils;
			import com.opinion.utils.ConversionUtils;
			import com.opinion.utils.DisplayUtils;
			import com.opinion.utils.HTTPUtils;
			import com.opinion.utils.Log;
			import com.opinion.utils.MathUtils;
			import com.themorphicgroup.controls.HSlider;
			
			import flare.animate.Easing;
			import flare.animate.Parallel;
			import flare.animate.Sequence;
			import flare.animate.TransitionEvent;
			import flare.animate.Transitioner;
			import flare.animate.Tween;
			import flare.flex.FlareVis;
			import flare.util.Displays;
			import flare.vis.Visualization;
			
			import flash.filters.DropShadowFilter;
			import flash.filters.GradientGlowFilter;
			import flash.geom.Rectangle;
			import flash.utils.setTimeout;
			
			import mx.binding.utils.*;
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.containers.Box;
			import mx.containers.TitleWindow;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.controls.ToolTip;
			import mx.controls.sliderClasses.Slider;
			import mx.core.IToolTip;
			import mx.effects.Resize;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.ResizeEvent;
			import mx.events.SliderEvent;
			import mx.events.ToolTipEvent;
			import mx.managers.ToolTipManager;
			import mx.rpc.events.FaultEvent;
			
			
            // Constants for button labels
            /*private static const FLAGGED_LABEL:String = "Reported";
            private static const UNFLAGGED_LABEL:String = "Inappropriate?";
            private static const SHOW_PANEL_LABEL:String = "Show My Opinions";
            private static const HIDE_PANEL_LABEL:String = "Hide My Opinions";
            private static const SHOW_HELP:String = "Show Help";
            private static const HIDE_HELP:String = "Hide Help";
            private static const SHOW_GLOW:String = "Glowing On";
            private static const HIDE_GLOW:String = "Glowing Off";   
            public static const REFRESH_DOTS_LABEL:String = "Refresh";
            public static const REFRESH_DOTS_LABEL_LOADING:String = "Refreshing...";
            public static const ENTER_FULLSCREEN_TOOLTIP:String = "Enter Fullscreen Mode";
            public static const EXIT_FULLSCREEN_TOOLTIP:String = "Exit Fullscreen Mode";
            public static const ENTER_FULLSCREEN_LABEL:String = "Fullscreen";
            public static const EXIT_FULLSCREEN_LABEL:String = "Exit Fullscreen";      
            public static const SHOW_RATING_LABEL:String = "Show Opinions";
            public static const HIDE_RATING_LABEL:String = "Hide Opinions";
            private static const RATING_LOADING_MESSAGE:String = "Loading...";
            public static const GET_PREVIOUS_COMMENT_LABEL:String = "See Response to Previous Question";
            public static const GET_CURRENT_COMMENT_LABEL:String = "See Response to Current Question";*/
            
            // Constants that denote dot size
			
            public var POINT_SIZES:Array; 
            public var POINT_COLORS:Array;
			           
            public static const HALO_THICKNESS:Number = 1.6;   
            public static const GRADIENT_GLOW_ALPHA:Array = [0, .10, .5, 1];
            public static const GRADIENT_GLOW_RATIO:Array = [50, 150, 200, 255];     
            
            // Constants for timeout values
            private static const AUTO_REFRESH_TIMEOUT:int = 30000;
            private static const INSTRUCTIONS_DISAPPEAR_TIMEOUT:int = 5000;
            
            // Constants for zooming
            private static const ZOOM_SLIDER_MIN:int = 1;
            private static const ZOOM_SLIDER_MAX:int = 3;
            private var tweenZoom:Boolean = true;
            private static const TWEEN_ZOOM_TIME:Number = .1;
            
            // Variables and constants for twinkling effect
            // Note: The twinkling effect has been known to increase frequency when
            // Opinion Space is refreshed. This is a open bug.
            private static const TWINKLE_TIME_BASE:int = 5000;
            private static const MIN_TWINKLE_FREQ:int = 1000;
            private static const MAX_TWINKLE_FREQ:int = 5000;
            private static const TWINKLE_MISS_TIMEOUT:int = 1000;
            private static const MIN_TWINKLE_THREADS:int = 1;
            private static const TWINKLE_THREAD_FACTOR:int = 100;
            private static const MAX_TWINKLE_THREADS:int = 5;    
            private var twinkleOn:Boolean = false;        
            private var twinkleThreads:int = 0;
            private static const GLOW_SPEED:Number = 1; 
			public var comment_count:int = 0;
            
            // Variables for radiation
            private var radiation:Boolean = true;  
            private var allRadiating:Boolean = true;            
                        
            // Constants for commenting
            private static const COMMENT_LOADING_MESSAGE:String = "Loading...";
            private static const USER_COMMENT_ID:int = 0; // Constant value for the user's id when handling comments
            private static const CUR_USER_NO_COMMENT:Number = 0;
            
            // Embed map assets
            [Embed(source="/assets/img/arrow_control_down.png")] public static const CLOSED_LIST_IMAGE:Class;
            [Embed(source="/assets/img/arrow_control_down_over.png")] public static const CLOSED_LIST_IMAGE_OVER:Class;
            [Embed(source="/assets/img/arrow_control_up.png")] public static const EXPANDED_LIST_IMAGE:Class;
            [Embed(source="/assets/img/arrow_control_up_over.png")] public static const EXPANDED_LIST_IMAGE_OVER:Class;
            //[Embed(source="/assets/toolbar/fullscreen.png")] public static const FULLSCREEN_ICON:Class;
            //[Embed(source="/assets/toolbar/help.png")] public static const HELP_ICON:Class;
            //[Embed(source="/assets/toolbar/refresh.png")] public static const REFRESH_ICON:Class;
            //[Embed(source="/assets/toolbar/show_me.png")] public static const SHOW_ME_ICON:Class;
            //[Embed(source="/assets/toolbar/show_my_opinions.png")] public static const SHOW_MY_OPINIONS_ICON:Class;
            //[Embed(source="/assets/img/zoom_in_1.png")] public static const ZOOM_IN_ICON:Class;
            //[Embed(source="/assets/img/zoom_out_1.png")] public static const ZOOM_OUT_ICON:Class;
            //[Embed(source="/assets/img/play_button.png")] public static const PLAY_BUTTON:Class;
            //[Embed(source="/assets/img/white_arrow.png")] public static const WHITE_ARROW:Class;

           
            
            // Embed the map background
            
            // HWL Logo 
			//[Embed(source="/assets/img/hwl-logo-small.jpg")] public static const HWL_LOGO:Class;
			
            // The current user's variables
            [Bindable] public var curUserDot:Sprite;
			[Bindable] public var fakeUserDot:Sprite;
            [Bindable] public var curUserDotX:int;
            [Bindable] public var curUserDotY:int;
            public var myComment:String = "";
            private var lastCurUserRatings:Array = new Array();
            
            // Constants for the user dot size
            // This should be changed eventually to not be a constant. 
            // The dot size should reflect how well the user is rated
            private static const USER_DOT_RADIUS:Number = 13;
            private static const USER_DOT_HALO_RADIUS:Number = 30;
            
			/*
			  Variables for comments and points
			*/
			// Variables for comment viewing
			public var curCommentUserId:int = 0;            
            private var prevCommentUserId:String; // The user whose previous comment is sought
			
			// Variables for comment data storage.
			// These need to be cleared on every refresh/load due to multiple discussion questions
			public var storedAgreementRating:Dictionary = new Dictionary();		
            public var storedCommentRating:Dictionary = new Dictionary();
            private var storedCommentScore:Dictionary = new Dictionary();
            private var storedComments:Dictionary = new Dictionary(); 
            private var storedCommentIds:Dictionary = new Dictionary();
			private var storedRatings:Dictionary = new Dictionary();
			private var userIdToCommentConfidence:Dictionary = new Dictionary();
            private var usernameToUid:Dictionary = new Dictionary();
            private var userIdToCommentScoreBucket:Dictionary = new Dictionary();
            private var userIdToAvgAgreementBucket:Dictionary = new Dictionary();
            private var storedVisualVars:Dictionary = new Dictionary();
			public var userIdUsernameLocation:Dictionary = new Dictionary();
			[Bindable] public var storedCommentRevisions:Array =new Array();
            private var curQueryAgreeRating:Dictionary = new Dictionary(); // Used to track the ratings for the current query
            private var curQueryInsightRating:Dictionary = new Dictionary();
            
            // Variables for filtering
            private var userDataPairs:Dictionary = new Dictionary();
            private var filterableKeys:Object = new Object();
            
            // Variables for specific queries
            [Bindable] private var queryInProcess:Boolean = false;
            [Bindable] private var curUserRatedByUids:Array = new Array();
            [Bindable] private var leaderboardUsersOnMap:Boolean = false;
            private var ratedIdeasQuery:Boolean = false;
			private var firstRating = true;
            
            /* This variable differs from refreshAndBang as it is only set during queries 
               Only one of these variables should be true during a refreshing of points 
               Make sure this variable is set to false after the effect has played */
            public var queryRefreshAndBang:Boolean = false; 
            
            // Top author and reviewer data structures
            private var topResponseUids:Array;
            private var topReviewerUids:Array;
            private var topResponses:Array;
			private var topReviewers:Array;
			private var risingAuthors:Array;            
            
			// Data structures that hold and keep track of the dots in the space            
            private var spriteNames:Array = new Array(); // holds the names of the objects in the container
            private var bgSpriteNames:Array = new Array();  //holds names of the background sprites
			public var spriteObjects:Object = new Object(); // holds a pointer to all the other dot sprite objects (does not include current user's point)
            public var bgSpriteObjects:Object = new Object(); //holds pointer to background sprite objects
			private var inContainer:Object = new Object();
            private var hasHalo:Object = new Object();
            private var idToHaloRadius:Object = new Object();
            private var lowConfidenceArray:Array = new Array();
            
            // Flags for when Opinion Space is refreshing
            public var refreshingOtherUsers:Boolean = false;
            
            // Flags to mark the drawing of users and landmarks
            public var drawingUsers:Boolean = false;
            
			// Opinion Space 2-D plane variables
            private var eigenvectors:Array = [];
            private var axisMax:Array = [];
            private var axisMin:Array = [];
            
            // Variables that help with panning, zooming, and fullscreen
            private var _graphOriginalCenter:Point;
            private var _graphCenter:Point;
            private var _graphMin:Point;
            private var _graphMax:Point;
            private var xAxisMax:Number;
            [Bindable] private var yAxisMax:Number;
            private var lastWidth:Number;
            private var lastHeight:Number;            
            private var fullScreenOffsetX:Number;
            private var fullScreenOffsetY:Number;
            public var originalCoordinates:Object = new Object();
			private var originalBGCoordinates:Object = new Object();
            private var glowT:Transitioner = new Transitioner(1.1, Easing.none);
            private var glowT1:Transitioner = new Transitioner(1.1, Easing.none);
            private var glowing:Boolean = false;    
            private var lastZoomVal:Number = 1;
            private var px:Number;
            private var py:Number;
            private var wasPanning:Boolean = false;
            private var closedFromPanning:Boolean = false;    
            
            // Big bang effect
            public var bigBang:Transitioner = new Transitioner(2, Easing.easeInOutPoly(4));
            private var bangOrigin:Point = new Point();
            public var fadePointsOut:Transitioner;
            public var fadeOutSprites:Array; // Holds the names of the sprites to be removed after the fade out effect
			
			private var sessionScore:Number = 0;
            
            // Constants for the space padding
            [Bindable] private var xLowerPadding:int = 30;
			[Bindable] private var xUpperPadding:int = 20;
			[Bindable] private var yLowerPadding:int = 40;
			[Bindable] private var yUpperPadding:int = 20;        
            private static const panZoomXLPad:int = 0;
            private static const panZoomXUPad:int = 0;
            private static const panZoomYLPad:int = 0;
            private static const panZoomYUPad:int = 0;            

            // Other variables
            [Bindable] public var loggedIn:Boolean = false;
            private var editCommentModeEnabled:Boolean = false;
            private var helpHidden:Boolean = true;
            
            [Bindable] public var commentModule:CommentModule;
            public var container:Sprite;
                        
            public var curSelectedSprite:Sprite = null;
            public var dotToolTip:ToolTip = null;
            public var dotToolTipsEnabled:Boolean = true;
            public var commentRatingCount:int = 0;
            
            private var instructionsTimeoutId:int = -1;
            private var arrowTimeoutId:int = -1;
            private var dotToolTipTimeoutId:int = -1;
            
            private var mouseWheelFixer:Timer;
            private var statements:Array; // This holds the statement ids
            
            [Bindable] private var authorScore:Number = 0;
            [Bindable] private var reviewerScore:Number = 0;
            [Bindable] public var numFullyRatedResponses:int = 0;
            
            private var numRad:int = 0;
            private var radiatingHalo:Sprite = null;
            public var highlightBox:Sprite = null;
            private var highlightedPoint:Sprite = null;
            
            private var meTxt:HBox = createFloatingPrompt("You", 45);
            
            private var linesDict:Dictionary = new Dictionary();
            private var linesShown:Boolean = false;
            
            public var userSignedUp:Boolean = false; // A variable that tracks if the user just signed up (turned on in SignupPage)
            [Bindable] private var displayFirstTimeInstructions:Boolean = false;
            
            [Bindable] public var numberOpinionsCollected:String;
            public var welcomeTxt:TextField;
            
            public var selectedDiscussionStatementId:int = -1;
            [Bindable] public var discussionStatementDropDownActive:Boolean = true;
            
            // Variables for demo
			private var SLIDER_TWEEN_DURATION:Number = 2.5;
			private var SLIDER_WIGGLE_DURATION:Number = 1; 
			private var demoWiggleValue:Number = .1;
			[Bindable] private var DEMO_PLAYING:Boolean = false;
			[Bindable] private var ANIMATION_PLAYING:Boolean = false;
			[Bindable] private var demoState:int = 0; // 0 means that the demo is not playing
			
			private var filterColorMap:Object = new Object();
			public var statementPageSliders:Array = [];
			
			[Bindable] public var hasFinishedComment:Boolean = false;
			[Bindable] public var hasFinishedStatements:Boolean = false;
			[Bindable] public var hasFinishedDemographics:Boolean = false;
			public var hasFinishedAdditional:Boolean = false;
			
			private var backgroundContainer:Sprite;
			
			// First time tutorial variables
			[Bindable] private var firstTimeHighlightedPointId:int = -1; // The point with the highest score
			private var firstTimeTutorialAlpha:Number = 0.15;
			private var firstTimeTutorialInsightRatings:Dictionary = new Dictionary();
			private var firstTimeTutorialAgreementRatings:Dictionary = new Dictionary();
			[Bindable] public var firstTimeUserScore:Number = 0;
			[Bindable] private var firstTimeTutorialNumRated:int = 0;
			[Bindable] private var oldFirstTimeScore:Number = 0;
			
			[Bindable] private var oldClientScore:Number = 0;
			private var plusOnePar:Parallel = new Parallel();
			
			private var firstTimeTooltip:HBox = null;
			
			[Bindable] public var approvedForLenses:Boolean = false;
			private var lensesPointHistory:Array = new Array();
			private var lensesFieldHistory:Array = new Array();
			private var lensesHistoryIdx:int = -1;
			[Bindable] public var placingPoint:Boolean = false; // Boolean indicates if the seed being dragged is in the borders of the sliders 
			private var mouseLocalDeltaX:int = 0;
			private var mouseLocalDeltaY:int = 0;
			public var firstTimeStatements:Object = new Object();
			private var spriteToFocusOnCallBack:String = "";
			private var uidToFocusOnCallBack:int = -1;
			
			//private static var DEMO_PICTURES:Array = new Array("http://automation.berkeley.edu/images/current-sanjay.jpg", "http://automation.berkeley.edu/images/current-dwong.jpg", "http://automation.berkeley.edu/images/current-siamak.jpg", "http://automation.berkeley.edu/images/current-rajat.jpg", "http://profile.ak.fbcdn.net/hprofile-ak-snc4/hs269.snc3/23138_1179613633_9943_q.jpg", "http://profile.ak.fbcdn.net/hprofile-ak-snc4/hs644.snc3/27409_1240789_8964_q.jpg", "http://profile.ak.fbcdn.net/hprofile-ak-snc4/hs344.snc4/41437_629130621_1081_q.jpg", "http://profile.ak.fbcdn.net/hprofile-ak-snc4/hs272.snc3/23197_1215172932_2856_q.jpg", "http://profile.ak.fbcdn.net/v229/955/68/q527559248_3019.jpg");
			
			// Dot over animation
			public var sprIsAnimating:Object = new Object();
			
			private var dragTxt:Text;
			
			/* First time prompts */
			public var rateResponsePrompt:HBox = createFloatingPrompt(Configuration.RATE_RESPONSE_PROMPT);
			public var leaveSuggestionPrompt:HBox = createFloatingPrompt(Configuration.LEAVE_SUGGESTION_PROMPT);
			public var ratedTranslucentPrompt:VBox = createFloatingPromptTop(Configuration.RATED_TRANSLUCENT_PROMPT);
			public var userSearchPrompt:VBox = createFloatingPromptTop("Here is %username's bloom, click on it to view the idea");
			public var scoreExplanationBox:HBox = createFloatingPrompt(Configuration.SCORE_EXPLANATION_BOX,300);
			
			private var spriteToMoveToBack:Sprite = null;
			public var usernameSearchFirstTime:Boolean = false;
			
			/* Prompt booleans so it's not so annoying */
			private var hasSeenSuggestionPrompt:Boolean = false;
			private var firstTimeTutorialCompleted:Boolean = false;
			
			public var signupContinue:Boolean = false;
			
            /**
            * Begin Opinion Space functions
            */ 
            
            public function initState():void {
				
				if (Configuration.FUN_COLORS)
				{
					POINT_SIZES = [20, 25, 30, 36, 42];
					POINT_COLORS = [ 0x000099,0xFF7519,0x66FF33, 0xFFCC00, 0xFF1975, 0xFF0000, 0x470047];
				}
				else
				{
					POINT_SIZES = [9, 12.5, 20, 27.5, 35];
					POINT_COLORS = [0xffda10, 0xffaa10, 0xff5b11, 0xef3a47, 0xc22f3a, 0xc22faf, 0x9e2fc2];
				}
				
                switch (currentState) {
                    case 'loggedOut':
						if (arrowTimeoutId != -1) {
                            clearTimeout(arrowTimeoutId);
                        }
                        if (instructionsTimeoutId != -1) {
                            clearTimeout(instructionsTimeoutId);
                        }
                        
                        loggedIn = false;
                        if (curUserDot != null) curUserDot.visible = loggedIn && Configuration.RATING_MODULE_VISIBLE;

						//flareVis.addEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);
						
                        hideArrowBox();
                        hideRatingModule();
                        removeLines(); // remove any lines drawn
                        hideResponseStats(); // make sure the response stats box is not visisble
                        if (welcomeTxt != null) welcomeTxt.visible = true;
                        
                        // Add comment module to logged out view
                        leftPanelOtherUserViewerLoggedout.addChild(commentModuleWrapper);
						hideFlareVisSliders();
						//join_box.visible=false;
						//join_box.includeInLayout = false;
                        
						
                        break;
                    case 'loggedIn':
                        if (arrowTimeoutId != -1) {
                            clearTimeout(arrowTimeoutId);
                        }
                        if (instructionsTimeoutId != -1) {
                            clearTimeout(instructionsTimeoutId);
                        }
                    
                        loggedIn = true;
                        if (curUserDot != null) curUserDot.visible = loggedIn && Configuration.RATING_MODULE_VISIBLE;
                        
                        if (welcomeTxt != null) welcomeTxt.visible = false;
						sessionScore = 0;
                        // Add comment module to logged in view
                        leftPanelOtherUserViewer.addChild(commentModuleWrapper);
						hideFlareVisSliders();
						//profile_pic.source = DEMO_PICTURES[Math.round(Math.random()*DEMO_PICTURES.length)];//TODO: FIX
                        
						//join_box.visible= false;
						//join_box.includeInLayout= false;
						
                        break;
                    default:
                        break;
                }
            }			
            
            private function addedToStage():void {
            	// log not creatd yet, we may not need to log this as the map is always viewed
            	//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "MAP_VIEW");
            }
            
            public function initializeCommentModule():void {
                commentModule = this.parentApplication.commentModule;  
            }
            
            public function hideHelp():void {
                helpHidden = true;
          //TODO:      helpBox.visible = false;
            }
            
            public function showHelp():void {
                helpHidden = false;
          //TODO: helpBox.visible = true;
            }
            
            public function showArrowBox():void {
            	if (meTxt == null) return;  
            	if (!this.parentApplication.isUserAuthenticated) return;
				alignMeTxt();
				moveDotToFront(curUserDot);   
                meTxt.visible = true;         
            }
            
            public function hideArrowBox():void {
            	if (meTxt == null) return;
                meTxt.visible = false;
                arrowTimeoutId = -1;
            }
            
            public function showArrowBoxTemporarily(e:Event=null):void {
                if (arrowTimeoutId == -1) {
                    showArrowBox();
                    ///arrowTimeoutId = setTimeout(hideArrowBox, INSTRUCTIONS_DISAPPEAR_TIMEOUT);
                }
            }
            
            public function showHideHelp():void {
                if (helpHidden) {
                    showHelp();
                }
                else {
                    hideHelp();
                }
            }
            
            /**
            * Function used to turn on and off glowing. Don't know if it works completely
            */ 
            public function showHideGlow():void {
                if (twinkleOn) {
                    //glowButton.label = SHOW_GLOW;
                    turnOffTwinkle();
                }
                else {
                    //glowButton.label = HIDE_GLOW;
                    turnOnTwinkle();
                    twinkle();
                }
            }
                        
            public function showFullscreenWarningBriefly():void { 
                     showFullscreenWarning(); 
                     setTimeout(hideFullscreenWarning, 2000); 
             } 
              
             public function hideFullscreenWarning():void { 
                //TODO:     fullscreenWarningBox.visible = false; 
             } 
              
             public function showFullscreenWarning():void { 
                //TODO:     fullscreenWarningBox.visible = true;  
             }  
            
            /**
             * Places the user dot according to the argument ratings
             */
            public function placeUserDot(userRatings:Array, userDot:Sprite):void {
                if (userDot == curUserDot) lastCurUserRatings = userRatings;	
				
				var xVal:Number = 0;
				var yVal:Number = 0;
				
				if(this.parentApplication.numStatements == 2)
				{
              	 	xVal = MathUtils.dotProduct(userRatings, eigenvectors[0]);
                	yVal = 1.0 - MathUtils.dotProduct(userRatings, eigenvectors[1]);
					// Translate slider ratings into coordinate space, with (0,0) on the upper left
				}
				else
				{
					xVal = MathUtils.dotProduct(userRatings, eigenvectors[0]);
					yVal = MathUtils.dotProduct(userRatings, eigenvectors[1]);
				}
				
                originalCoordinates[userDot.name].x = xVal;
                originalCoordinates[userDot.name].y = yVal;
                
                // These are the coordinates assuming no zoom and a centered graph
               // var rawX:Number = Math.max(userDot.width, Math.min(flareVis.width - userDot.width,transformXCoorToPixels(xVal)));
				//var rawY:Number = Math.max(userDot.height, Math.min(flareVis.height - userDot.height,transformYCoorToPixels(yVal)));
				var rawX:Number = transformXCoorToPixels(xVal);
				var rawY:Number = transformYCoorToPixels(yVal);
                // This adjusts the point given zoom
              /*TODO:  if (zoomSlider.value != 1) {    
                    var deltaXY:Object = computeZoomDeltas(rawX, rawY, _graphOriginalCenter.x, _graphOriginalCenter.y, 1, zoomSlider.value, "placeUser");
                    if (!isNaN(deltaXY['x']) && !isNaN(deltaXY['y'])) {
                        if (rawX < _graphOriginalCenter.x) {
                            rawX -= deltaXY['x'];
                        } else {
                            rawX += deltaXY['x'];                       
                        }
                        if (rawY < _graphOriginalCenter.y) {
                            rawY -= deltaXY['y'];   
                        } else {
                            rawY += deltaXY['y'];
                        }
                    } 
                }*/
                
                // This shifts the point to the corresponding location given panning
                rawX -= _graphOriginalCenter.x - _graphCenter.x;
                rawY -= _graphOriginalCenter.y - _graphCenter.y;                
                
                // Set user dot location
                userDot.x = rawX;
				userDot.y = rawY;
				
                // Have the user's point emerge from the background
                if (this.parentApplication.refreshAndBang) {
                	// Have the user dot fade in
                	userDot.alpha = 0;
                	bigBang.$(userDot).alpha = 1;
                	
                	// Have the user dot grow in size
                	userDot.scaleX = 0.1;                	
                	userDot.scaleY = 0.1;
                	bigBang.$(userDot).scaleX = 1;
                	bigBang.$(userDot).scaleY = 1;
                }
                
                // We stop the function here for a big bang effect, in fact if the
                // user's dot is out of bounds, this will cause an infinite loop
                // and possibly cause the user's dot to be removed from the big bang
                // effect (if the origins cause the user's dot to be removed)
                if (this.parentApplication.refreshAndBang) return;
                
                // This function is also called during a refresh to place the user dot.
                // If the screen is refreshing when the user's dot happens to be out of 
                // the map, we don't want the map to pan so the user is still in the map
				if (!this.parentApplication.refreshing) { 
					// If the user is moving their dot beyond the map boundaries,
	                // this moves the map along with the user, we only do so if its the curUserDot
	                var deltaX:Number = 0;
	                var deltaY:Number = 0;
	                if (userDot.x < USER_DOT_RADIUS - panZoomXLPad) deltaX = (USER_DOT_RADIUS - panZoomXLPad) - userDot.x;
	                if (userDot.x > (flareVis.width - USER_DOT_RADIUS - panZoomXUPad)) deltaX = (flareVis.width - USER_DOT_RADIUS - panZoomXUPad) - userDot.x;
	                if (userDot.y < USER_DOT_RADIUS - panZoomYLPad) deltaY = (USER_DOT_RADIUS - panZoomYLPad) - userDot.y;
	                if (userDot.y > (flareVis.height - USER_DOT_RADIUS - panZoomYUPad)) deltaY = (flareVis.height - USER_DOT_RADIUS - panZoomYUPad) - userDot.y;
	                
	                if (deltaX != 0 || deltaY != 0) {
	                    if (!closedFromPanning) {
	                        panBy(deltaX, deltaY, true);
	                        placeUserDot(userRatings, curUserDot); // Do it one more time to adjust for the panning
	                    }
	                }
    			}
    			
    			// If there are lines drawn, adjust them
    			adjustLines();
    			
    			alignMeTxt();
    			
    			// 2011.08.02 no more highlight box
    			//if (highlightedPoint == curUserDot) adjustNonDotPosition(highlightBox, highlightedPoint, _graphOriginalCenter, null, null, 0);
    			
                // Endall fix for numerous problems
                /*
                1) Move the userDot back in if it was out, this happens if the user starts adjusting ratings
                and their dot is out of bounds
                2) If closed from panning, we need to check if the background user dot is outside the bounds
                and the curUser dot goes there. elsewise, you'd see the user dot drawn out of bounds
                3) If the userDot is out of bounds and the background user dot is in bounds, we need to
                redraw the user dot in bounds (opposite of 2)
                */
                checkBounds(userDot, userDot.name);
            }
            
            /**
            * Refreshes the size of the user's dot based on their comment score
            */ 
            public function refreshUserDotSize():void {
                adjustDotRadius("curUser", this.parentApplication.userCommentNormalizedScore);
            }
            
            /**
             * Refreshes the user dot according to the argument ratings and comment
             */
            public function refreshUserDot(userRatings:Array, userComment:String):void {
                this.myComment = userComment;
                
                refreshUserDotSize();
                placeUserDot(userRatings, curUserDot);
            }
            
            /**
             * Refreshes the user dot according to the argument ratings and comment, after first
             * compressing the arguments
             */
            public function refreshUserDotCompress(userRatingsDecoded:Array, userCommentDecoded:Array):void {
                refreshUserDot(MathUtils.compressUserRatingsDecoded(userRatingsDecoded), userCommentDecoded[0]);
            }
            
            /**
             * Initializes the state variables of the space. 
             * Uses the eigenvectors retrieved by the HTTPService call to find the max/min values of the axes.
             */
            public function refreshOpinionMap(osNameDecoded:String, userCommentDecoded:Array, eigenvectorsDecoded:Array, numStatements:int, isUserAuthenticated:Boolean, resetCenter:Boolean, statementsDecoded:Array):void {
                this.parentApplication.osNameText.text = osNameDecoded;
				//this.parentApplication.opinionMap.hideFlareVisSliders();
				//this.parentApplication.opinionMap.removeFakePoint();
				
				hasFinishedStatements = (this.parentApplication.userRatingsDecoded.length > 0);
				hasFinishedComment = (this.parentApplication.userCommentDecoded.length > 0 && this.parentApplication.userCommentDecoded != Configuration.COMMENT_ENTRY_PROMPT);
				hasFinishedDemographics = mapOverlay.isDemographicsFinished();
							
				hasSeenSuggestionPrompt = (this.parentApplication.numSuggestions!=0);			
							
                this.myComment = userCommentDecoded[0];
                eigenvectors = MathUtils.compressEigenvectorsDecoded(eigenvectorsDecoded);
                
                // TODO: Log this
                if (eigenvectors.length == 0) {                 
                    eigenvectors = MathUtils.createDummyEigenvectors(numStatements);
                }
                
                authorScore = this.parentApplication.userCommentNormalizedScore*100;
                reviewerScore = this.parentApplication.userRaterScore;
                
                axisMax = MathUtils.getAxisMax(eigenvectors);
                axisMin = MathUtils.getAxisMin(eigenvectors); 
                
                _graphMin = new Point(axisMin[0], axisMin[1]);
                _graphMax = new Point(axisMax[0], axisMax[1]);
                
                // Max lengths of the axes
                xAxisMax = Math.abs(_graphMax.x - _graphMin.x);
                yAxisMax = Math.abs(_graphMax.y - _graphMin.y);
                
                lastWidth = flareVis.width;
                lastHeight = flareVis.height;
                
                if (resetCenter) {
	                _graphOriginalCenter = new Point(transformXCoorToPixels(_graphMin.x + xAxisMax/2), transformYCoorToPixels(_graphMin.y + yAxisMax/2));
	                _graphCenter = new Point(_graphOriginalCenter.x, _graphOriginalCenter.y);
	                
	                // Also reset the zoom
	              //TODO:  zoomSlider.value = 1;
                }
                
                // Set the bang origin
                bangOrigin.x = _graphOriginalCenter.x;
                bangOrigin.y = _graphOriginalCenter.y;
                
                if (isUserAuthenticated) {
                    currentState = 'loggedIn';
					//currentTopicHeader.visible = false;
					//currentTopicHeader.includeInLayout = false;
                }
                else {
                    currentState = 'loggedOut';
                }
                
                statements = new Array();
                for (var i:int = 0; i < statementsDecoded.length; i++) {
                	statements.push(statementsDecoded[i][0]);
                }
                statements = statements.sort(Array.NUMERIC);
                
                // Clear the mapOverlay
               if(!userSignedUp)
					mapOverlay.clearState();
				
				// Reset the first time tutorial variables
				resetFirstTimeTutorialVariables();
				this.parentApplication.refreshStats();
				this.parentApplication.refreshNotifications();
				
				if(loggedIn && Configuration.LEADERBOARD_ENABLED)
					this.sendGetLeaderboardUsers();
            }
            
            
            /**
            * Function that creates the Opinion Space map.
            * This is called in opinionflex to initialize the map
            */ 
            public function createOpinionMap(osNameDecoded:String, userCommentDecoded:Array, eigenvectorsDecoded:Array, numStatements:int, isUserAuthenticated:Boolean, statementsDecoded:Array):void {
                refreshOpinionMap(osNameDecoded, userCommentDecoded, eigenvectorsDecoded, numStatements, isUserAuthenticated, true, statementsDecoded);
				
				// Initialize flare after initial variables have been instantiated
				initFlare();
			}
			
            /**
            * Initializes the Flare visualization instance
            */ 
            private function initFlare():void {
                container = new Sprite();
                container.x = 0;
                container.y = 0;
				
				backgroundContainer = new Sprite();
				backgroundContainer.x = 0;
				backgroundContainer.y = 0;

                flareVis.buttonMode = true;
                flareVis.addEventListener(MouseEvent.CLICK, containerClick);
                //flareVis.addEventListener(MouseEvent.MOUSE_DOWN, panMouseDown);     
                flareVis.addEventListener(ResizeEvent.RESIZE, resizeMap);
				this.addEventListener(ResizeEvent.RESIZE, resizeMap);
				flareVis.visualization.addChild(backgroundContainer); 
                //flareVis.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelZoom);
                flareVis.visualization.addChild(container);
                
                flareVis.visualization.bounds = new Rectangle(0, 0, flareVis.width, flareVis.height);
                
                drawUserDots();
                
				if(Configuration.ARCS_ON)
                	createArcs();
                	
                // 2010.09.29 removed the welcome text for first time intro	
                //writeWelcomeText();
                
                // Add-ons for configurable modules
                if (Configuration.OPINION_MAP_ADD_ON) 
                {
					for (var i:int = 0; i < Configuration.OPINION_MAP_ADD_ONS.length; i++)
					{
						var parent:DisplayObjectContainer = plotCanvas;
						for (var n:int = 0; n < Configuration.OPINION_MAP_ADD_ONS[i]['parent'].length; n++)
						{
							parent = DisplayObjectContainer(parent.getChildByName(Configuration.OPINION_MAP_ADD_ONS[i]['parent'][n]));
						} 
						parent.addChild(Configuration.OPINION_MAP_ADD_ONS[i]['child']);
					}
                }
                
                // Initialize the score formatter
                scoreFormatter.precision = Configuration.SCORE_PRECISION;
                
                // Set tooltip delay to 0
             	ToolTipManager.showDelay = 0;
             
             	// Draw lanuage
             	if (Configuration.SHOW_LEGEND) drawLegend();
             
                // uncomment if you need to test the padding of the space
               //calibrate();
            }
            
            private function reEnableMouseWheel(e:TimerEvent):void {
                flareVis.addEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelZoom);
            }
            
            private function mouseWheelZoom(e:MouseEvent):void {
             /*TODO:  var center:Point = new Point(e.stageX, e.stageY).subtract(
                    flareVis.localToGlobal(new Point(flareVis.x - 10, flareVis.y)));
                
                if (e.delta > 0) {
                    // Zoom in
                    if (zoomSlider.value != ZOOM_SLIDER_MAX) {
                        zoomSlider.value += .25;
                    }
                }
                else if (e.delta < 0) {
                    // Zoom out
                    if (zoomSlider.value != ZOOM_SLIDER_MIN) {
                        zoomSlider.value -= .25;
                    }
                }
                
                doZoomWithCenter(center.x, center.y, true);
                
                // Fix for a Firefox 3 bug which sends two scroll events
                mouseWheelFixer = new Timer(1);
                mouseWheelFixer.addEventListener(TimerEvent.TIMER, reEnableMouseWheel);
                mouseWheelFixer.start();
                flareVis.removeEventListener(MouseEvent.MOUSE_WHEEL, mouseWheelZoom); */
            }
            
			private function resizeBackground():void{
				var center:Point = _graphOriginalCenter;
				for (var m:int = 0; m<bgSpriteNames.length; m++) {
					var spr:Sprite = bgSpriteObjects[bgSpriteNames[m.toString()]];
					
					var rawX:Number = transformXCoorToPixels(originalBGCoordinates[spr.name].x);
					var rawY:Number = transformYCoorToPixels(originalBGCoordinates[spr.name].y);
					
					// This adjusts the point given zoom
/*TODO:					if (zoomSlider.value != 1) {    
						var deltaXY:Object = computeZoomDeltas(rawX, rawY, center.x, center.y, 1, zoomSlider.value, "dotResizing" + spr.name);
						if (!isNaN(deltaXY['x']) && !isNaN(deltaXY['y'])) {
							if (rawX < center.x) {
								rawX -= deltaXY['x'];
							} else {
								rawX += deltaXY['x'];                       
							}
							if (rawY < center.y) {
								rawY -= deltaXY['y'];   
							} else {
								rawY += deltaXY['y'];
							}
						} 
					}*/
					
					// This adjusts the point given panning
					rawX -= _graphOriginalCenter.x - _graphCenter.x;
					rawY -= _graphOriginalCenter.y - _graphCenter.y;
					
					spr.x = rawX;
					spr.y = rawY;
				}
			}
			
            private function resizeMap(e:ResizeEvent):void {				
				//if (bigBang.running) bigBang.stop();
				resizeFlareVis();
                adjustForFullScreen();
				resizeBackground();	
				
				mapOverlay.resize();//allow the plot canvas to resize
				
				if(fakeUserDot != null){
					
					if (Configuration.NO_STATEMENTS)
						updateFakePoint(hslider.value,1.0 - vslider.value);
					else
						this.parentApplication.ratingModule.createAndPlaceFakeUserDot();
				}
            }
            
            private function containerClick(e:MouseEvent):void {
				handlePlotClick();
            }
            
            /**
            * Here begins the event handlers and other functions that enable panning
            */ 
            private function panMouseDown(e:MouseEvent):void {
                px = e.stageX;
                py = e.stageY;
                
                flareVis.addEventListener(MouseEvent.MOUSE_MOVE, panMouseMove);
                flareVis.addEventListener(MouseEvent.MOUSE_UP, panMouseUp);
                flareVis.addEventListener(MouseEvent.MOUSE_OUT, panMouseOut);
            }
            
            private function panMouseMove(e:MouseEvent):void {
				if (bigBang.running) return;            	
            	
                var x:Number = e.stageX - xUpperPadding;
                var y:Number = e.stageY - yLowerPadding;
                
                panBy(x - px, y - py, false);
                px = x;
                py = y;
                
                wasPanning = true;
            }
			
			public function removeFakePoint():void
			{
				if(fakeUserDot != null && plotCanvas.rawChildren.contains(fakeUserDot))
					plotCanvas.rawChildren.removeChild(fakeUserDot);
				
				fakeUserDot = null;
			}
			
			/**
			 * x and y are the point's exact location
			 */ 
			private function updateFakePoint(xCoor:Number, yCoor:Number):void
			{
				if(fakeUserDot != null && plotCanvas.rawChildren.contains(fakeUserDot))
				{
					// remove the prompt
					if (dragTxt != null && plotCanvas.contains(dragTxt))
						plotCanvas.removeChild(dragTxt);
					
					// Show done box
					done_box.visible = true;
					done_box.includeInLayout = true;
					
					fakeUserDot.x = transformXCoorToPixels(xCoor) + mouseLocalDeltaX;
					fakeUserDot.y = transformYCoorToPixels(yCoor);
					
					originalCoordinates[fakeUserDot.name].x = xCoor;
					originalCoordinates[fakeUserDot.name].y = yCoor;
				}
			}
			
			public function placingPointDown(e:MouseEvent):void {
				plotCanvas.addEventListener(MouseEvent.MOUSE_MOVE, placingPointDrag);
				
				if (!loggedIn)
				{
					fakeUserDot.addEventListener(MouseEvent.MOUSE_UP, placingPointUp);
					fakeUserDot.addEventListener(MouseEvent.MOUSE_OUT, placingPointOut);
				}
				else
				{
					hideArrowBox(); // incase You is still visible
					curUserDot.addEventListener(MouseEvent.MOUSE_UP, placingPointUp);
					curUserDot.addEventListener(MouseEvent.MOUSE_OUT, placingPointOut);
				}
			}
			
			private function placingPointDrag(e:MouseEvent):void {
				// remove the prompt
				if (dragTxt != null && plotCanvas.contains(dragTxt))
					plotCanvas.removeChild(dragTxt);
				
				var x:Number = plotCanvas.globalToLocal(new Point(e.stageX, e.stageY)).x;
				var y:Number = plotCanvas.globalToLocal(new Point(e.stageX, e.stageY)).y;
				
				// If mouse outside bounds of map
				if(transformPixelsToYCoor(y) > 1 || transformPixelsToYCoor(y) < 0 || transformPixelsToXCoor(x - mouseLocalDeltaX) < 0 || transformPixelsToXCoor(x - mouseLocalDeltaX) > 1)
				{
					// If you haven't yet crossed into the map
					if (!placingPoint)
					{
						fakeUserDot.x = x;
						fakeUserDot.y = y;
					}
				} else
				{
					// Event triggers in the sliders will update the point's position
					hslider.value = transformPixelsToXCoor(x - mouseLocalDeltaX);
					vslider.value = 1.0 - transformPixelsToYCoor(y); // Transform from coordinate space to slider space
				}
			}
			
			private function placingPointUp(e:MouseEvent):void {
				plotCanvas.removeEventListener(MouseEvent.MOUSE_MOVE, placingPointDrag);
				
				if (!loggedIn)
				{
					fakeUserDot.removeEventListener(MouseEvent.MOUSE_UP, placingPointUp);
					fakeUserDot.removeEventListener(MouseEvent.MOUSE_OUT, placingPointOut);
				}
				else
				{
					curUserDot.removeEventListener(MouseEvent.MOUSE_UP, placingPointUp);
					curUserDot.removeEventListener(MouseEvent.MOUSE_OUT, placingPointOut);
				}
			}
			
			private function placingPointOut(e:MouseEvent):void {
				var x:Number = plotCanvas.globalToLocal(new Point(e.stageX, e.stageY)).x;
				var y:Number = plotCanvas.globalToLocal(new Point(e.stageX, e.stageY)).y;
				
				// If mouse outside bounds of map
				if(transformPixelsToYCoor(y) > 1 || transformPixelsToYCoor(y) < 0 || transformPixelsToXCoor(x - mouseLocalDeltaX) < 0 || transformPixelsToXCoor(x - mouseLocalDeltaX) > 1)
				{
					// If user has already crossed within the bounds of the sliders
					if (placingPoint)
						placingPointUp(e);
				}
			}

            private function panMouseUp(e:MouseEvent):void {
                flareVis.removeEventListener(MouseEvent.MOUSE_MOVE, panMouseMove);
                flareVis.removeEventListener(MouseEvent.MOUSE_UP, panMouseUp);
                flareVis.removeEventListener(MouseEvent.MOUSE_OUT, panMouseOut);
            }
            
            private function panMouseOut(e:MouseEvent):void {
                flareVis.removeEventListener(MouseEvent.MOUSE_MOVE, panMouseMove);
                flareVis.removeEventListener(MouseEvent.MOUSE_UP, panMouseUp);
                flareVis.removeEventListener(MouseEvent.MOUSE_OUT, panMouseOut);
            }

            private function panBy(x:Number, y:Number, movingUser:Boolean):void {
                if (!movingUser) {
                    // Because of this, if the user dot is out of bounds then you start rating,
                    // you need to readd the dot in, this is in placeUserDot
                    curUserDot.x += x;
                    curUserDot.y += y;
                    checkBounds(curUserDot, curUserDot.name)
                }
                
                for (var m:int = 0; m < spriteNames.length; m++) {
                    var temp:Sprite = spriteObjects[spriteNames[m]];
                    temp.x += x;
                    temp.y += y;
                    checkBounds(temp, temp.name);
                }
                _graphCenter.x += x;
                _graphCenter.y += y;
                
                if (radiatingHalo != null) {
                	// this is only null if it hasn't been created by a click on the leaderboard yet
	                radiatingHalo.x += x;
	                radiatingHalo.y += y;
                }
                
                if (highlightBox != null) {
                	// this is only null if it hasn't been created by a click on the leaderboard yet
	                highlightBox.x += x;
	                highlightBox.y += y;
                }

				// Pan the lines if they are on the map
                if (linesShown){
	                for (var id:Object in linesDict) {
	                	linesDict[id].x += x;
	                	linesDict[id].y += y;
	                }	
                }
                
                hideArrowBox();
            }
            
            /**
            * initializes the curUserDot and backgroundCurUserDot at 0,0
            */ 
            private function drawUserDots():void {
				if(placingPoint)
					return;

				// Determine what to draw
				/*
                var ideaStages:Array = this.parentApplication.PointDrawer.ideaProgression();
                
                // Draw bud if # ratings < 2
                if (this.parentApplication.numUserRatedBy < Configuration.AUTHOR_RATINGS_THRESHOLDS[0])
                	curUserDot = ideaStages[0];
                else if(this.parentApplication.numUserRatedBy < Configuration.AUTHOR_RATINGS_THRESHOLDS[1])
                	curUserDot = ideaStages[1];
                else if(this.parentApplication.numUserRatedBy < Configuration.AUTHOR_RATINGS_THRESHOLDS[2])
                	curUserDot = ideaStages[2];
                else
                	curUserDot = ideaStages[3];
				*/
				
				curUserDot = this.parentApplication.PointDrawer.drawDisc(0x15abd7,0,0,30/7,30,true);
				
				// Create aura
				var gradientGlow:GradientGlowFilter = new GradientGlowFilter();
				gradientGlow.distance = 0;
				gradientGlow.angle = 0;
				gradientGlow.colors = [0xffffff, 0xFBEC5D, 0xFBEC5D];//[0x000000, 0xeefc6b, 0xeefc6b, 0xeefc6b];
				gradientGlow.alphas = [0, .7, 1];
				gradientGlow.ratios = [0, 95, 200];
				gradientGlow.blurX = 60;
				gradientGlow.blurY = 60;
				gradientGlow.strength = 4;
				gradientGlow.quality = BitmapFilterQuality.MEDIUM;
				gradientGlow.type = BitmapFilterType.OUTER;
				
				// 2011.10.10 remove glow
				/*
				curUserDot.filters = [gradientGlow];
				
				// Have bud twinkle
                var twn:Tween = new Tween(curUserDot, 1, {//"filters[0].alphas":[0, 1, 1],
                                   "filters[0].ratios":[0, 63, 126]
                                   //"filters[0].strength":4
                                   });
	            twn.easing = Easing.none;
	            var twn1:Tween = new Tween(curUserDot, 1, {//"filters[0].alphas":GRADIENT_GLOW_ALPHA,
	                                               "filters[0].ratios":[0, 95, 200]
	                                               //scaleX:1, scaleY:1
	                                               });
	            twn1.easing = Easing.none;
	            
	            var seq:Sequence = new Sequence(twn, twn1);
	            seq.addEventListener(TransitionEvent.END, function():void {seq.play();});
				
				//seq.play();

                /*
                curUserDot = this.parentApplication.PointDrawer.drawFlower(30, // outer radius
                															  .75, // decay
                															  [[0.7, 0.7],[0.7, 0.7],[0.7, 0.7],], // alpha 
                															  [5 + Math.random() * 15, 5 + Math.random() * 15, 5 + Math.random() * 15], // num petals
                															  [[0xD9D919, 0xCFB52B],[0xCFB52B,0xDBDB70],[0xD9D919,0xDBDB70]], // colors
                															  [[0,127],[0,127],[0,127]], 
                															  [Math.PI * Math.random(), Math.PI * Math.random(), Math.PI * Math.random()]);
                */														  
				curUserDot.x = bangOrigin.x;
                curUserDot.y = bangOrigin.y;
				
				//Alert.show(curUserDot.x + " " + curUserDot.y);
				
                curUserDot.name = "curUser";
				curUserDot.buttonMode = true;
				
				curUserDot.addEventListener(MouseEvent.CLICK, handleDotClick);  
				curUserDot.addEventListener(MouseEvent.MOUSE_OVER, dotOver);
				curUserDot.visible = loggedIn && Configuration.RATING_MODULE_VISIBLE; 
				//Alert.show(loggedIn + " " );
                
                // Draw the user's halo
                /*
                var halo:Sprite = createHalo(0, 0, "curUserhalo", HALO_THICKNESS, 1, USER_DOT_HALO_RADIUS, Configuration.USER_DOT_COLOR);
                curUserDot.addChild(halo);
                curUserDot.filters = [gradientGlow];
                */
                
                // Draw the me text
				alignMeTxt();
                meTxtBox.addChild(meTxt);                
                
                idToHaloRadius[curUserDot.name] = USER_DOT_HALO_RADIUS;
                hasHalo[curUserDot.name] = true;
                inContainer[curUserDot.name] = true;
                originalCoordinates[curUserDot.name] = new Point();
                container.addChild(curUserDot);
                
				//haloRadiation(halo);
            }
                        
			/**
			 * Moves the argument dot to the top of the display.
			 * Similiar to z-index in css
			 */                         
            private function moveDotToFront(userDot:DisplayObject):void {
                if (inContainer[userDot.name]) moveToFront(userDot);			
            }
            
            /**
            * Moves an object to the front of the display
            */ 
            public function moveToFront(obj:DisplayObject):void {
                var index:int = container.getChildIndex(obj);
                if (index != -1 && index < (container.numChildren - 1))
                {
                    container.setChildIndex(obj, container.numChildren - 1);
                }
            }
            
            /**
            * Moves an object to the back of the display
            */ 
            public function moveToBack(obj:DisplayObject):void {
                var index:int = container.getChildIndex(obj);
                if (index != -1 && index < (container.numChildren - 1))
                {
                    container.setChildIndex(obj, 0);
                }
				adjustDotLayers();
            }
			
			public function moveToBackRated(obj:DisplayObject):void {
					for (var i:int =0; i<container.numChildren; i++)
					{
						var spr:DisplayObject = container.getChildAt(i);
						if(spr == curUserDot)
							continue;
						
						if (storedCommentRating[spr.name] == null || storedAgreementRating[spr.name] == null || storedCommentRating[spr.name] == -1 || storedAgreementRating[spr.name] == -1) 
						{
							break;
						}
					}
					if(i < container.getChildIndex(obj))
						container.setChildIndex(obj, Math.max(i-1,0));
					else if (i == container.numChildren)
						moveToFront(obj);
					
					adjustDotLayers();
			}
            
            
            /**
            * Correctly layers the sprites so the user's dot is always on top followed by
            * landmarks and other dots.
            */ 
            private function adjustDotLayers():void {
                moveDotToFront(curUserDot);
            }
            
            /**
            * Places dots in the top left, right, and bottom right to calibrate the padding
            */ 
            private function calibrate():void {
                container.addChild(createCircle(transformXCoorToPixels(_graphMax.x), transformYCoorToPixels(_graphMax.y), "1", 5, 1, 0x4499FF));
                container.addChild(createCircle(transformXCoorToPixels(_graphMax.x), transformYCoorToPixels(_graphMin.y), "3", 4, 1, 0x4499FF));
                container.addChild(createCircle(transformXCoorToPixels(_graphMin.x), transformYCoorToPixels(_graphMax.y), "4", 4, 1, 0x4499FF));
                container.addChild(createCircle(transformXCoorToPixels(_graphMin.x + xAxisMax/2), transformYCoorToPixels(_graphMin.y + yAxisMax/2), "5", 4, 1, 0x4499FF));
				
				// Draw a 5 x 5 grid of flowers
				var flowers:Array = new Array();
				flowers = this.parentApplication.PointDrawer.calibrateDrawing();
				for (var i:int = 0; i < flowers.length; i++)
				{
					flowers[i].x = transformXCoorToPixels(_graphMin.x + (i % 5) * xAxisMax/5);
					flowers[i].y = transformYCoorToPixels(_graphMin.y + int(i / 5) * yAxisMax/5) + yLowerPadding;
					container.addChild(flowers[i]); 
				}
            }
            
            /**
            * Removes a list of dots from the spriteNames array and from the container
            * 
            * The removal is done without an animation
            * 
            * This is currently only used in the getUsersBy query to remove points before they
            * are redrawn on return from the query. This is used to display updated comments
            * 
            * NOTE: It is not guaranteed that any of the users in userIds are in the display
            * 
            */
            private function removeUsers(userIds:Array):void {
            	// Remove from container
            	for (var i:int = 0; i<userIds.length; i++)
            	{
					// If the user is currently in the display, remove it            		
            		if ((spriteNames.indexOf(userIds[i].toString()) != -1) && inContainer[userIds[i].toString()])
            		{
            			container.removeChild(spriteObjects[userIds[i].toString()]);
            		}
            	}
            	
            	// Remove from spriteNames 
            	var newSpriteNames:Array = new Array();
            	for (var j:int = 0; j<spriteNames.length; j++)
            	{
            		if (userIds.indexOf(spriteNames[j]) == -1)
            		{
            			newSpriteNames.push(spriteNames[j]);
            		}	
            	}
            	
            	spriteNames = newSpriteNames;
            	
            } 
            
            /**
            * Removes all the dots from the spriteNames array except for landmarks sprites
            * if passed the correct boolean
            * 
            * If queryRefreshAndBang is set, then the points will be removed with an animation
            * 
            */ 
            public function removeDots(removeLandmarks:Boolean):void {
            	var newSpriteNames:Array = new Array();
            	
            	if (queryRefreshAndBang)  
                { 
                	// Reset the animation for removal of points
                	fadePointsOut = new Transitioner(.5, Easing.none);
                	fadePointsOut.addEventListener(TransitionEvent.END, endFadePointsOut);
                	fadeOutSprites = new Array();
                }
            	
            	// Iterate through the points to see which to remove
            	for (var m:int = 0; m < spriteNames.length; m++) {
                    var temp:Sprite = spriteObjects[spriteNames[m.toString()]];
                    if (true) {
                        if (inContainer[temp.name]) {                         
                            // Mark sprite for removal and add it to the animation
                            if (queryRefreshAndBang)
                            {
                            	fadeOutSprites.push(temp);
                            	
                            	// Change the type of animation here
                            	fadePointsOut.$(temp).alpha = 0;
                            } 
                            // Remove the points from the display
                            else
                            {
                            	
								container.removeChild(temp);
                            	//inContainer[temp.name] = false; Removed to keep this consistent with endFadePointsOut
                            }
                        }
                    } else 
                    {
                        newSpriteNames.push(temp.name); // add the landmark to the newSpriteNames
                    }
                }
                
                // Assign the spriteNames array to the new array
                // Note: newSpriteNames will at most only hold the names of the landmarks
                spriteNames = newSpriteNames;
                
                if (queryRefreshAndBang)
                {
                	// Avoid playing an empty animation
                	if (fadeOutSprites.length == 0)
						return;                		
                	
                	// Play the animation
                	fadePointsOut.play();
                }
            }
			
			public function fadeDots():void {

				fadePointsOut = new Transitioner(2, Easing.easeOutCirc);
				fadeOutSprites = new Array();

				// Iterate through the points to see which to remove
				for (var m:int = 0; m < spriteNames.length; m++) {
					var temp:Sprite = spriteObjects[spriteNames[m.toString()]];

						if (inContainer[temp.name]) {                         
							
							fadeOutSprites.push(temp);
							// Change the type of animation here
							fadePointsOut.$(temp).alpha = 0;
						}
					
				}
					// Avoid playing an empty animation
					if (fadeOutSprites.length == 0)
						return;                		
					
					// Play the animation
					fadePointsOut.play();
			}
			
			public function fadeInDots():void {
				
				fadePointsOut = new Transitioner(2, Easing.easeInCirc);
				
				// Iterate through the points to see which to remove
				for (var m:int = 0; m < fadeOutSprites.length; m++) {
					var temp:Sprite = fadeOutSprites[m];
					
					if (inContainer[temp.name]) {                         
						fadePointsOut.$(temp).alpha = 1;
					}
					
				}
				// Avoid playing an empty animation
				if (fadeOutSprites.length == 0)
					return;   
				
				fadeOutSprites = new Array();
				
				// Play the animation
				fadePointsOut.play();
			}
            
 			/**
            * Ends the animation of the points disappearing and removes the sprite objects
            * from the container
            */
            private function endFadePointsOut(e:TransitionEvent):void {
            	for (var i:int = 0; i<fadeOutSprites.length; i++)
            	{
            		var temp:Sprite = fadeOutSprites[i];
            		container.removeChild(temp);
					// Note: removed inContainer[temp.name] = false            		
            	}	
            }
            
            /**
            * Function used to adjust the initial the dot locations for other users and landmarks
            * according to the pan/zoom settings
            */ 
            private function adjustDots(adjustLandmarks:Boolean):void {
                for (var x:int = 0; x < spriteNames.length; x++) {
                    var spr:Sprite = spriteObjects[spriteNames[x.toString()]];
                    if (false) {
                        adjustForResizing(spr, _graphOriginalCenter);
                    }
                }
            }

			/**
			 * Begin getter and setter methods for extracting comment values from the 
			 * JSON object returned by all the query methods for comments 
			 */ 
            private function getUserId(commentDecoded:Object):String {
            	usernameToUid[commentDecoded['username'].toString().toLowerCase()] = commentDecoded['uid'].toString();
                return commentDecoded['uid'].toString();
            }
            
            private function getCommentText(commentDecoded:Object):String {
                return commentDecoded['comment'];
            }       
            
			public function storeCommentJSONUsernames(userId:String,commentDecoded:Object):void
			{
				userIdUsernameLocation[userId] = new Object();
				userIdUsernameLocation[userId]['username'] = commentDecoded['username'];
				userIdUsernameLocation[userId]['location'] = commentDecoded['location'];
			}
			
            private function storeCommentText(userId:String, commentDecoded:Object):void {
                var commentText:String = getCommentText(commentDecoded);
                storedComments[userId] = commentText;
            }
			
			private function storeCommentRevisions(userId:String,commentDecoded:Object):void
			{
				storedCommentRevisions[userId] = commentDecoded['prev_comments'];
			}
            
            private function getCommentScore(commentDecoded:Object):Number {
                if (commentDecoded['norm_score'] != null) return commentDecoded['norm_score'];
                else return -1;
            }
            
            private function storeCommentScore(userId:String, commentDecoded:Object):Number {
                var commentScore:Number = getCommentScore(commentDecoded);
                storedCommentScore[userId] = commentScore;
                return commentScore;
            }
            
            private function getCommentRating(commentDecoded:Object):Number {
                if (commentDecoded['rating'] != null) return commentDecoded['rating'];
                else return -1;
            }
            
            private function storeCommentRating(userId:String, commentDecoded:Object):Number {
                var commentRating:Number = getCommentRating(commentDecoded);
                storedCommentRating[userId] = commentRating;
                return commentRating;
            }
            
            private function getCommentId(commentDecoded:Object):int {
                return commentDecoded['cid'];
            }
            
            private function storeCommentId(userId:String, commentDecoded:Object):void {
                var commentId:int = getCommentId(commentDecoded);
                storedCommentIds[userId] = commentId;
				comment_count = comment_count + 1;
            }
 
             /**
            * Returns the confidence returned by the json object. If the confidence is null,
            * then the returned value is 1. The confidence is the SE, so if it is null, we set it
            * to the greatest value, 1
            */ 
            private function getCommentConfidence(commentDecoded:Object):Number {
            	if(commentDecoded['confidence'] == null) return 1;
            	else return commentDecoded['confidence'];
            }
            
            private function storeCommentConfidence(userId:String, commentDecoded:Object):void {
            	var commentConfidence:Number = getCommentConfidence(commentDecoded);
            	userIdToCommentConfidence[userId] = commentConfidence;
            }
            
            private function getCommentAgreement(commentDecoded:Object):Number {
            	if (commentDecoded['agreeance'] != null) return commentDecoded['agreeance'];
            	else return -1;
            }
            
            private function storeCommentAgreement(userId:String, commentDecoded:Object):void {
            	var commentAgreement:Number = getCommentAgreement(commentDecoded);
            	storedAgreementRating[userId] = commentAgreement;
            }
            
            private function storeCommentVisualVars(userId:String, commentDecoded:Object):void {
            	var visualVars:Array = new Array();
            	
            	if (commentDecoded['vis_vars'] == null)
					visualVars = [];
            	else
            		visualVars = commentDecoded['vis_vars'];
            		 
            	storedVisualVars[userId] = visualVars; 
            } 
            
            /**
            * Stores the information in state variables and if a leaderboard is open, it initializes the corresponding leaderboard
            */ 
            private function storeLeaderboardInfo(topResp:Array, topRev:Array, risingAuth:Array):void {
            	topResponses = topResp;
            	topReviewers = topRev;
            	risingAuthors = risingAuth;
            	
            	topResponseUids = new Array();
            	topReviewerUids = new Array();
            	
				for (var i:int = 0; i<topResponses.length; i++)
					topResponseUids.push(topResponses[i]['uid']);
				for (var j:int = 0; j<topReviewers.length; j++)
					topReviewerUids.push(topReviewers[j]['uid']);

				// Update the leaderboards if any are open				
				if (topReviewerControl.source == EXPANDED_LIST_IMAGE || topReviewerControl.source == EXPANDED_LIST_IMAGE_OVER)
					initTopReviewerList();
				if (topAuthorControl.source == EXPANDED_LIST_IMAGE || topAuthorControl.source == EXPANDED_LIST_IMAGE_OVER)
            		initTopAuthorsList();
            	if (risingAuthorControl.source == EXPANDED_LIST_IMAGE || risingAuthorControl.source == EXPANDED_LIST_IMAGE_OVER)	
            		initRisingAuthorsList();  				
            }
            
            /**
            * Stores the filterable keys used by the lenses
            */
			public function storeFilterableKeys(data:Object):void {
				filterableKeys = data;
            	
            	var filterable:Array = [];
            	for (var key:Object in filterableKeys) {
            		filterable.push(key);
            	}
            	
            	filterableKeysDropDown.dataProvider = filterable;
            	filterableKeysDropDownChange();
			}          
            
            /**
            * Stores the key value pairs from the UserData table
            */ 
            private function storeUserData(data:Object):void {
            	
            	for (var i:int = 0; i < spriteNames.length; i++)
            	{
            		if (data[spriteNames[i]] != null)
            		{
            			userDataPairs[spriteNames[i]] = data[spriteNames[i]];
            		}
            	}
            }
            
            /**
            * All formatted comments sent from the server should be processed by this function
            * 
            * This function assumes that the variables used to store comment data have been 
            * flushed if needed.
            */ 
            private function storeCommentJSON(commentsDecoded:Array):void {
            	commentRatingCount = 0;
                for (var i:int = 0; i < commentsDecoded.length; i++) {
                    var commentDecoded:Object = commentsDecoded[i];
                    
                    var userId:String = getUserId(commentDecoded);
                    storeCommentText(userId, commentDecoded);
                    storeCommentScore(userId, commentDecoded);
                    var commentRating:Number = storeCommentRating(userId, commentDecoded);
                    storeCommentId(userId, commentDecoded);
                    storeCommentConfidence(userId, commentDecoded);
                    storeCommentAgreement(userId, commentDecoded);
                    storeCommentVisualVars(userId, commentDecoded);
					storeCommentJSONUsernames(userId,commentDecoded);
					storeCommentRevisions(userId,commentDecoded);
                    
                    if (commentRating != -1) commentRatingCount++;
                }
                
                if (commentRatingCount >= 3) dotToolTipsEnabled = false;
                commentRatingCount = 0;
            }
			
            /**
            * All ratings json objects sent from the server should be processed by this function
            * 
            * This function takes care of drawing the points based off the ratings
            */ 
            private function storeRatingsJSONandDraw(ratingsDecoded:Array, background:Boolean = false):void {
				if (ratingsDecoded.length == 0) return;
            	// First time tutorial: determine which point is to be highlighted
            	if (!this.parentApplication.isUserAuthenticated && !background)
            	{
            		var topScore:Number = Number.MIN_VALUE;
            		var topScoreId:int;
	            	for (var key:Object in storedCommentScore)
	            	{
	            		if (storedCommentScore[key] > topScore)
	            		{
	            			topScore = storedCommentScore[key];
	            			topScoreId = int(key);
	            		}
	            	}
	            	
	            	//firstTimeHighlightedPointId = topScoreId;
            	}
            	
            	var tempRating:Dictionary = new Dictionary();
                var len:int = 0;
                var stmtid:int = 0;
                var lastUser:int = ratingsDecoded[0][0];
                
                // Iterate through ratings and draw the points
                for (var i:int = 0; i <= ratingsDecoded.length; i++) {
                    // Completed one rating array
                    if (i == ratingsDecoded.length || ratingsDecoded[i][0] != lastUser) {
                        if (len != eigenvectors[0].length) {
                            for (var k:int = 0; k < statements.length; k++) {
                                if (tempRating[statements[k].toString()] == null) {
                                    tempRating[statements[k].toString()] = Constants.DEFAULT_SLIDER_VALUE;
                                }
                            }
                        }
						
						// Transform from slider space to coordinate space--upper left is (0,0)
						var xVal:Number = 0;
						var yVal:Number = 0
						if(this.parentApplication.numStatements == 2)
						{
                       		xVal = MathUtils.dictArrayDotProduct(tempRating, eigenvectors[0], statements);
                        	yVal = 1.0 - MathUtils.dictArrayDotProduct(tempRating, eigenvectors[1], statements);
						}
						else
						{
							xVal = MathUtils.dictArrayDotProduct(tempRating, eigenvectors[0], statements);
							yVal = MathUtils.dictArrayDotProduct(tempRating, eigenvectors[1], statements);
						}
						
                        // This includes trying to get ratings for user_id = 1
                        //drawOtherUserDots(xVal, yVal, lastUser, storedCommentScore[lastUser.toString()]);
						/*if (!background)
							drawOtherUserDots(xVal, yVal, lastUser, storedCommentScore[lastUser.toString()]);
						else
							drawOnBackground(xVal, yVal, lastUser);*/
						
						if (!background)
							drawOtherUserDots(Configuration.AFFINE_TRANSFORM_SCALEX*xVal+Configuration.AFFINE_TRANSFORM_SHIFTX, Configuration.AFFINE_TRANSFORM_SCALEY*yVal+Configuration.AFFINE_TRANSFORM_SHIFTY, lastUser, storedCommentScore[lastUser.toString()]);
						else
							drawOnBackground(Configuration.AFFINE_TRANSFORM_SCALEX*xVal+Configuration.AFFINE_TRANSFORM_SHIFTX, Configuration.AFFINE_TRANSFORM_SCALEY*yVal+Configuration.AFFINE_TRANSFORM_SHIFTY, lastUser);
                        
						if (i == ratingsDecoded.length) {
                        	// End of function
                            //terminateHandleGetOtherUsers();
                            return;
                        }
                        
                        lastUser = ratingsDecoded[i][0];
                        tempRating = new Dictionary();
                        len = 0;
                    }
                    
                    try {
                        stmtid = ratingsDecoded[i][1];
                        tempRating[stmtid.toString()] = ratingsDecoded[i][2];
                        len += 1;
                    }
                    catch (e:RangeError) {
                        /// TODO: Log this error
                    }
                }
            }

            /**
            * Initializes userIdToCommentScoreBucket to map to the dot size interval
            * used in mapScoreToRadius
            * 
            * Spreads the comments evenly among the intervals. If the number of comments
            * is not a multiple of the number of intervals, the remainer gets spread across
            * the smallest intervals first
            * 
            * The argument array data is assumed to be sorted from smallest to largest score
            */ 
            private function storeSortedIDsToBuckets(data:Array, bucket:Dictionary, numBuckets:int, no_statements:Boolean = false):void
            {
            	// Hardcode the first three points to have nice colors
            	/*
            	if (data.length == Configuration.EXPLORE_THRESHOLD_RATINGS && Configuration.NO_STATEMENTS && no_statements && bucket == userIdToAvgAgreementBucket)
            	{
            		bucket[data[0][0]] = numBuckets; 
            		bucket[data[1][0]] = numBuckets - 4;
            		bucket[data[2][0]] = 0;
            	} */
            	
				if (data.length == 1)
				{
					//Alert.show('test');
					if(Math.random() < 5)
						bucket[data[0][0]] = numBuckets;
					else
						bucket[data[0][0]] = numBuckets-2;
					return;
				}
				
            	var intervalSize:int = data.length/numBuckets;
            	var remainder:int = data.length % numBuckets;
            	var intervalNum:int = 1;
            	var commentsSoFar:int = 0;

				// default to having the larger points first
            	if (intervalSize == 0)
            		intervalNum = numBuckets - data.length + 1;

            	for (var k:int = 0; k < data.length; k++) 
            	{
            		// Corner case: if the number of points displayed < NUM_SIZE_INTERVALS and 
            		// intervalSize is 0
            		if (intervalSize == 0)
            		{
            			bucket[data[k][0]] = intervalNum;
            			intervalNum += 1;
            			continue;
            		}
            		
            		// Standard case: intervalSize > 0, remainder >= 0
            		if (commentsSoFar >= intervalSize) // Two cases: 1) maybe use a remainder, 2) remainder has been used
            		{
            			if (remainder > 0 && commentsSoFar == intervalSize) // use remainder
            			{
            				remainder -= 1;
            			} else // remainder has been used or no remainder left 
            			{
            				intervalNum += 1;
            				commentsSoFar = 0;	
            			}
            		}
            		
            		// Set the corresponding interval number for the user_id
            		bucket[data[k][0]] = intervalNum;
            		commentsSoFar += 1;
            	}
            }
            
            /**
            * Clears the state variables for the comments returned by
            * getUnratedUsers, getLeaderboardUsers, getRatedUsers, and getRatedByUsers 
            */ 
            private function clearOtherUserData():void {
				storedAgreementRating = new Dictionary();		
	            storedCommentRating = new Dictionary();
	            storedCommentScore = new Dictionary();
	            storedComments = new Dictionary(); 
	            storedCommentIds = new Dictionary();
	            storedRatings = new Dictionary();
	            userIdToCommentConfidence = new Dictionary();
	            usernameToUid = new Dictionary();
	            userIdToCommentScoreBucket = new Dictionary();
	            userIdToAvgAgreementBucket = new Dictionary();
	            storedVisualVars = new Dictionary();
	            userIdUsernameLocation = new Dictionary();
	            storedCommentRevisions = new Array();
	            userDataPairs = new Dictionary();
	            curQueryAgreeRating = new Dictionary();
	            curQueryInsightRating = new Dictionary();
            }
            
            /**
            * Clears the map of points and flushes the variables for comment
            * data storage. Also handles some cleanup:
            * 	- deselecting the leaderboard
            * 	- hiding the highlight box
            * 
            * Call this function per new query that needs to return a new set
            * of points to the space. 
            */
            private function flushAllPointsAndData(includingLandmarks:Boolean):void
            {
            	// Clear all the points 
                removeDots(includingLandmarks);
                
                // Clear the state variables for comment data storage
                clearOtherUserData(); 
                
                // Unselect the leaderboards
                leftList.selectedIndex = -1;
                rightList.selectedIndex = -1;
                
                // Hide the highlight box
                hideHighlightBox();
                
                // Set flag for this specific query
            	ratedIdeasQuery = false;
            	
            	// Hide panels: if Configuration.VERTICAL_ORIENTATION, this closes all panels, 
            	// ow the rating module is still visible  
            	hidePanels();
            }
			
            /**
            * Send functions for the various types of queries
            * 
            * Each send function will account for multiple discussion questions
            */
            private function sendGetAllCurrentComments():void {
            	if (queryInProcess) return;
            	
            	// Set flag for query bang
            	if (this.parentApplication.bangOn)
            	{
            		queryRefreshAndBang = true;
            		this.resetBigBang();
            	} 
            	
            	if (this.selectedDiscussionStatementId == -1) 
                	getAllCurrentComments.url = this.parentApplication.httpUtils.getServiceUrl("os/all/" + this.parentApplication.opinionSpaceId + "/");
                else
                	getAllCurrentComments.url = this.parentApplication.httpUtils.getServiceUrl("os/all/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
            	
            	// Prepare parameters
            	var parameters:Object = new Object();
            	
            	// Send entry code for authentication if needed                
                if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
            	
            	// We don't need to account for multiple discussion questions here as it is
            	// already taken care of in createOS, discussionStatementDropDownChange, and logout
            	getAllCurrentComments.send(parameters);
            	
            	// Hide leaderboard
            	leaderboardUsersOnMap = false;
            	
            	// Set flag for query processing
            	queryInProcess = true;
            }
            
            public function sendShuffle():void {
				
            	if (queryInProcess) return;
            	
            	// Set flag for query bang
            	if (this.parentApplication.bangOn)
            	{
            		queryRefreshAndBang = true;
            		this.resetBigBang();
            	} 
            	
            	// We don't need to account for multiple discussion questions here as it is
            	// already taken care of in createOS, discussionStatementDropDownChange, and logout
            	var parameters:Object = new Object();
            	parameters['shuffle'] = true;
            	
            	// Send entry code for authentication if needed                
                if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
	            	
				getNeverSeenComments.send(parameters);
            	
            	// Hide leaderboard
            	leaderboardUsersOnMap = false;
            	
            	// Set flag for query processing
            	queryInProcess = true;
            }
              
            private function sendGetLeaderboardUsers():void {
				
            	//if (queryInProcess) return;
            	
            	// Set flag for query bang
            	//if (this.parentApplication.bangOn)
            	//{
            	//	queryRefreshAndBang = true;
            	//	this.resetBigBang();
            	//} 
            	
				if (this.selectedDiscussionStatementId == -1) 
                	getLeaderboardUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/leaderboard/" + this.parentApplication.opinionSpaceId + "/");
                else
                	getLeaderboardUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/leaderboard/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");

                // Send entry code for authentication if needed                
                var parameters:Object = new Object();
                if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                
                getLeaderboardUsers.send(parameters);
                
                // Set flag for query processing
            	queryInProcess = true;
            }

            public function sendGetRatedUsers():void {
				
            	if (queryInProcess) return;
            	
            	// Set flag for query bang
            	if (this.parentApplication.bangOn)
            	{
            		queryRefreshAndBang = true;
            		this.resetBigBang();
            	}
            	
            	if (this.selectedDiscussionStatementId == -1) 
                	getRatedUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/rated/" + this.parentApplication.opinionSpaceId + "/");
                else
                	getRatedUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/rated/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
                
                // Send entry code for authentication if needed                
                var parameters:Object = new Object();
                if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                
                getRatedUsers.send(parameters);
                
                // Hide leaderboard
            	leaderboardUsersOnMap = false;
            	
            	// Set flag for query processing
            	queryInProcess = true;
            	
            	firstTimeIntroPrompt.visible = false;
				firstTimeIntroPrompt.includeInLayout = false;
            }
            
            public function sendGetRatedByUsers():void {
				
            	if (queryInProcess) return;
            	
				// Set flag for query bang
            	if (this.parentApplication.bangOn)
            	{
            		queryRefreshAndBang = true;
            		this.resetBigBang();
            	}            	
            	
            	if (this.selectedDiscussionStatementId == -1) 
					getRatedByUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/ratedby/" + this.parentApplication.opinionSpaceId + "/");
				else
					getRatedByUsers.url = this.parentApplication.httpUtils.getServiceUrl("os/ratedby/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
				// Prepare parameters                
                var parameters:Object = new Object();
				
				if (Configuration.USE_ENTRY_CODES)
	            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;

				getRatedByUsers.send(parameters);
                
                // Hide leaderboard
            	leaderboardUsersOnMap = false;
            	
            	// Set flag for query processing
            	queryInProcess = true;
            }   
			
			
			public function sendGetUsersByList(userArray:Array):void {				
				if (queryInProcess) return;         	
				
				if (this.selectedDiscussionStatementId == -1) 
					getUsersByList.url = this.parentApplication.httpUtils.getServiceUrl("os/userlist/" + this.parentApplication.opinionSpaceId + "/");
				else
					getUsersByList.url = this.parentApplication.httpUtils.getServiceUrl("os/userlist/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
				// Prepare parameters                
				var parameters:Object = new Object();
				
				if(userArray != null)
					parameters['userlist'] = JSON.encode(userArray);
				
				if (Configuration.USE_ENTRY_CODES)
					parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
				
				// Remove the users from the display if they are currently visible.
				removeUsers(userArray);
				
				getUsersByList.send(parameters);
				
				// Hide leaderboard
				leaderboardUsersOnMap = false;
				
				// Set flag for query processing
				queryInProcess = true;
			}
			
			public function sendGetRatedUpdatedComments():void {
				
				if (queryInProcess) return;
				
				// Set flag for query bang
				if (this.parentApplication.bangOn)
				{
					queryRefreshAndBang = true;
					this.resetBigBang();
				}            	
				
				if (this.selectedDiscussionStatementId == -1) 
					getRatedUpdatedComments.url = this.parentApplication.httpUtils.getServiceUrl("os/ratedupdatedcomments/" + this.parentApplication.opinionSpaceId + "/");
				else
					getRatedUpdatedComments.url = this.parentApplication.httpUtils.getServiceUrl("os/ratedupdatedcomments/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
				// Prepare parameters                
				var parameters:Object = new Object();
				
				if (Configuration.USE_ENTRY_CODES)
					parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
				
				getRatedUpdatedComments.send(parameters);
				
				// Hide leaderboard
				leaderboardUsersOnMap = false;
				
				// Set flag for query processing
				queryInProcess = true;
			}
			
			public function sendGetNeverSeenComments():void {
				
				if (queryInProcess) return;
				
				// Set flag for query bang
				if (this.parentApplication.bangOn)
				{
					queryRefreshAndBang = true;
					this.resetBigBang();
				}            	
				
				if (this.selectedDiscussionStatementId == -1) 
					getNeverSeenComments.url = this.parentApplication.httpUtils.getServiceUrl("os/neverseencomments/" + this.parentApplication.opinionSpaceId + "/");
				else
					getNeverSeenComments.url = this.parentApplication.httpUtils.getServiceUrl("os/neverseencomments/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
				// Prepare parameters                
				var parameters:Object = new Object();
				
				if (Configuration.USE_ENTRY_CODES)
					parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
				
				parameters['query'] = true;				
				getNeverSeenComments.send(parameters);
				
				// Hide leaderboard
				leaderboardUsersOnMap = false;
				
				// Set flag for query processing
				queryInProcess = true;
				
				firstTimeIntroPrompt.visible = false;
				firstTimeIntroPrompt.includeInLayout = false;
			}
			
			public function sendAddUserToMap(username:String,uid:int):void {
				
				if (queryInProcess) return;
				
				if(spriteObjects[uid] != null)
				{
					processDotClick(spriteObjects[uid]);
					//Alert.show('test');
					return;
				}
				
				focusUIDOnCallback(uid);
				// Set flag for query bang
				//if (this.parentApplication.bangOn)
				//{
					//queryRefreshAndBang = true;
					//this.resetBigBang();
				//}            	
				
				if (this.selectedDiscussionStatementId == -1) 
					addUserToMap.url = this.parentApplication.httpUtils.getServiceUrl("os/neverseencomments/" + this.parentApplication.opinionSpaceId + "/");
				else
					addUserToMap.url = this.parentApplication.httpUtils.getServiceUrl("os/neverseencomments/" + this.parentApplication.opinionSpaceId + "/" + this.selectedDiscussionStatementId + "/");
				// Prepare parameters                
				var parameters:Object = new Object();
				
				if (Configuration.USE_ENTRY_CODES)
					parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
				
				parameters['username']= username;
				parameters['query'] = true;				
				addUserToMap.send(parameters);
				
				// Hide leaderboard
				//leaderboardUsersOnMap = false;
				
				// Set flag for query processing
				queryInProcess = true;
				
				//firstTimeIntroPrompt.visible = false;
				//firstTimeIntroPrompt.includeInLayout = false;
			}
			
			public function handleAddUserToMap():void
			{
				// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_BY_USERS_LOADED");
				
				// Check for eigenvalues -- this only pertains to the initial load
				if (eigenvectors.length == 0 || eigenvectors[0].length == 0) {
					// The request that sets the eigenvectors hasn't completed yet
					setTimeout(handleAddUserToMap, 100);
					return;
				}
				
				// Extract variables from the JSON object
				var decoded:Object = JSON.decode(addUserToMap.lastResult.toString());
				addUserToMap.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
				if (AuthenticationUtils.resultIsAuthRequired(decoded))
					return;
				
				// Clear all the points and the state variables for comments
				
				if(!leaderboardUsersOnMap)
				{
					//flushAllPointsAndData(false);
					// Hide leaderboard - Add here also, since system refresh also invokes
					// this function, which won't call the sendGetUnratedUsers function
					leaderboardUsersOnMap = false;
					
					// Store comment info and draw points (the order of these functions matters)
					storeCommentJSON(decoded['comments']);
					storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
					storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length, decoded['no_statements']);
					storeRatingsJSONandDraw(decoded['ratings']);
					storeUserData(decoded['user_data']);
					parseAndStoreRatings(decoded['ratings']);
				}
				
				cleanupQuery(false);
				processDotClick(spriteObjects[uidToFocusOnCallBack]);
				//cleanupQuery(false);
			}
			
			public function focusPointOnCallback(spriteName:String):void
			{
				spriteToFocusOnCallBack = spriteName;
			}
			
			public function focusUIDOnCallback(spriteID:int):void
			{
				uidToFocusOnCallBack = spriteID;
			}
            
            /**
            * Function that performs the necessary housekeeping after a query
            * handler receives the JSON result.
            * 
            * This function should be called in some way in all the call back handlers
            * for query methods.
            *  
            */
            private function cleanupQuery(focus:Boolean=true):void {
            	
            	// Show the user's point when a query has been executed
            	if (focus)
            		processDotClick(curUserDot);
            	
            	if (queryRefreshAndBang)
				{
					// Check for an empty animation
					if (spriteNames.length != 0)
					{
						// The cleanup in the else case will be taken care
						// of at the end of the big bang
						this.playBigBang(); 
					} else
					{
						// If there is an empty animation, don't play it
						// and take care of clean up here
						queryRefreshAndBang = false;
						this.endBigBang();
					}
					
					
				}
				else // Otherwise do cleanup
				{
	                adjustDotLayers(); // Move user dot and background to front
	                
	                // Set flag for query processing
	            	queryInProcess = false;					
				}
            }
            
            /**
            * Callback handler for getAllCurrentComments HTTPService
            * 
            * Retrieves all comments and the comment user's ratings, stores the information, and 
            * draws the users onto the space.
            * 
            * This function will only be invoked by a button click and is not
            * invoked on a system refresh.
            * 
            */
            private function handleGetAllCurrentComments():void {
				
				// Extract variables from the JSON object
                var decoded:Object = JSON.decode(getAllCurrentComments.lastResult.toString());
				getAllCurrentComments.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(decoded))
                	return;
				
				// Clear all the points and the state variables for comments
                flushAllPointsAndData(false);
                
                // Store comment info and draw points (the order of these functions matters)
                storeCommentJSON(decoded['comments']);
                storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
                storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
                storeRatingsJSONandDraw(decoded['ratings']);
                storeUserData(decoded['user_data']);
				parseAndStoreRatings(decoded['ratings']);
                
                // End system refresh cleanup
				drawingUsers = false;
                if (twinkleOn) setTimeout(twinkle, 3000); // Turns twinkling on when the function terminates
                if (refreshingOtherUsers) // adjust dots if no big bang effect 
                {
                	// call adjust dots to align dots with current pan/zoom settings
                    if (!this.parentApplication.refreshAndBang && !queryRefreshAndBang) {
                    	adjustDots(false);
                    } 
                    refreshingOtherUsers = false;
                    this.parentApplication.endRefresh();
                } else 
                {
                	this.parentApplication.endCreateOS();
                }        	
            }
            
            /**
            * Callback handler for getUnratedUsers HTTPService
            * 
            * Retrieves unrated user comments and ratings, stores the comments information, and 
            * draws the users onto the space.
            * 
            * This function will be called on each load or system refresh of the space and for every user
            * initiated shuffle. 
            * 
            * The function will return a set of comments and ratings for comments sorted by time and number
            * of ratings for each load/refresh. The function will return a random set of points for each 
            * shuffle
            */
            private function handleGetUnratedUsers():void {
            	
            	// TEMP DEBUG LOGGING
            	if (Configuration.DEBUG_LOGGING)
					this.parentApplication.log.logUserEvent(1, -1, "handleGetUnratedUsers called");
            	
				// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "UNRATED_USERS_LOADED");
            	
            	// Check for eigenvalues -- this only pertains to the initial load
            	if (eigenvectors.length == 0 || eigenvectors[0].length == 0) {
                    // The request that sets the eigenvectors hasn't completed yet
                    setTimeout(handleGetUnratedUsers, 100);
                    return;
                }
                
                // Extract variables from the JSON object
                var decoded:Object = JSON.decode(getUnratedUsers.lastResult.toString());
				getUnratedUsers.disconnect(); //kill the connection after we are done using it
                
                // TODO: Better error handling for auth errors
                if (AuthenticationUtils.resultIsAuthRequired(decoded))
                	return;
                
                // Clear all the points and the state variables for comments
                flushAllPointsAndData(false);
                
                // Hide leaderboard - Add here also, since system refresh also invokes
                // this function, which won't call the sendGetUnratedUsers function
            	leaderboardUsersOnMap = false;
                
                // Store comment info and draw points (the order of these functions matters)
                storeCommentJSON(decoded['comments']);
                storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
                storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
                storeRatingsJSONandDraw(decoded['ratings']);
                storeUserData(decoded['user_data']);
				parseAndStoreRatings(decoded['ratings']);
				
                // Show notification
                if (decoded['comments'].length == 0 && decoded['shuffle'])
                {
                	showMapNotification(Configuration.RATED_ALL_COMMENTS_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
                }
				
				if (!decoded['shuffle']) // Some cleanup housekeeping ONLY for os creation and system refreshes
				{
					drawingUsers = false;
	                if (twinkleOn) setTimeout(twinkle, 3000); // Turns twinkling on when the function terminates
	                if (refreshingOtherUsers) // adjust dots if no big bang effect 
	                {
	                	// call adjust dots to align dots with current pan/zoom settings
	                    if (!this.parentApplication.refreshAndBang && !queryRefreshAndBang) {
	                    	adjustDots(false);
	                    } 
	                    refreshingOtherUsers = false;
	                    this.parentApplication.endRefresh();
	                } else 
	                {
	                	this.parentApplication.endCreateOS();
	                }
					// TODO: Revisit the highlighting of low confidence points
					// if (allRadiating && (lowConfidenceArray.length != 0)) highlightLowConfidencePoints(); // Add effect for low confidence points
					
					// Show user's point (moved out the general refresh)
					processDotClick(curUserDot);
				} 
				else // Normal query housekeeping 
				{
					cleanupQuery();
				}
            } 
            
            /**
            * Callback handler for getLeaderboardUsers HTTPService
            * 
            * This function returns the comments and ratings, stores the comments information, and 
            * draws the users onto the space for the following:
            * - The top 10 responses for the discussion statement
            * - The top 10 reviewers with responses to the discussion statement
            * - The top 10 rising authors for the discussion statement
            * 
            * This function will only be invoked by a button click and is not
            * invoked on a system refresh.
            * 
            */            
            private function handleGetLeaderboardUsers():void {
            	// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "LEADERBOARD_USERS_LOADED");
				
				// Extract variables from the JSON object
                var decoded:Object = JSON.decode(getLeaderboardUsers.lastResult.toString());
				getLeaderboardUsers.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(decoded))
                	return;
				
				// Clear all the points and the state variables for comments
                if(!Configuration.ROLLING_LEADERBOARD)
					flushAllPointsAndData(false);
                
                // Store leaderboard info
               	storeLeaderboardInfo(decoded['list_1'], decoded['list_2'], decoded['list_3']);

               	// Store comment info and draw points (the order of these functions matters)
				if(!Configuration.ROLLING_LEADERBOARD){
				var allComments:Array = (decoded['list_1'] as Array).concat(decoded['list_2'] as Array).concat(decoded['list_3'] as Array);
                storeCommentJSON(allComments);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
                storeRatingsJSONandDraw(decoded['ratings']);
                storeUserData(decoded['user_data']);
                parseAndStoreRatings(decoded['ratings']);
				}
                
				// Normal query housekeeping
            	cleanupQuery();
				
				if(!Configuration.ROLLING_LEADERBOARD){
                leaderboardUsersOnMap = true;
				}
                
                // Show the top authors
                if (!leftList.visible && !rightList.visible)
                	toggleAuthorControl();
            }
            
            /**
            * Callback handler for getRatedUsers HTTPService
            * 
            * Retrieves rated comments and the comment user's ratings, stores the information, and 
            * draws the users onto the space.
            * 
            * This function will only be invoked by a button click and is not
            * invoked on a system refresh.
            * 
            */
            private function handleGetRatedUsers():void {
            	// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_USERS_LOADED");
				
				// Extract variables from the JSON object
                var decoded:Object = JSON.decode(getRatedUsers.lastResult.toString());
				getRatedUsers.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(decoded))
                	return;
				
				// Clear all the points and the state variables for comments
                flushAllPointsAndData(false);
                
                // Set flag for this specific query
            	ratedIdeasQuery = true;
                
                // Store comment info and draw points (the order of these functions matters)
                storeCommentJSON(decoded['comments']);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
                storeRatingsJSONandDraw(decoded['ratings']);
                storeUserData(decoded['user_data']);
                parseAndStoreRatings(decoded['ratings']);
                
                // Show notification
                if (decoded['comments'].length == 0)
                {
                	showMapNotification(Configuration.NOT_RATED_ANY_RESP_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
                }
                
				// Normal query housekeeping
            	cleanupQuery();
            }
            
            private function handleGetRatedByUsers():void {
            	// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_BY_USERS_LOADED");
				
				// Extract variables from the JSON object
                var decoded:Object = JSON.decode(getRatedByUsers.lastResult.toString());
				getRatedByUsers.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(decoded))
                	return;
				
				// Clear all the points and the state variables for comments
                flushAllPointsAndData(false);
                
                // Store comment info and draw points (the order of these functions matters)
                storeCommentJSON(decoded['comments']);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
                storeRatingsJSONandDraw(decoded['ratings']);
                storeUserData(decoded['user_data']);
                parseAndStoreRatings(decoded['ratings']);
                
                // Initialize curUserRatedByUids if want to use the lines button
                
                // Show notification
                if (decoded['comments'].length == 0)
                {
                	showMapNotification(Configuration.NOT_RATED_BY_OTHER_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
                }
                
                // Normal query housekeeping
            	cleanupQuery();
            }
			
			private function handleGetUsersByList():void {
				// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_BY_USERS_LOADED");
				
				// Extract variables from the JSON object
				var decoded:Object = JSON.decode(getUsersByList.lastResult.toString());
				getUsersByList.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
				if (AuthenticationUtils.resultIsAuthRequired(decoded))
					return;
								
				// Store comment info and draw points (the order of these functions matters)
				storeCommentJSON(decoded['comments']);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
				storeRatingsJSONandDraw(decoded['ratings']);
				storeUserData(decoded['user_data']);
				parseAndStoreRatings(decoded['ratings']);
				// Initialize curUserRatedByUids if want to use the lines button
				
				// Show notification if returned result is null
				if (decoded['comments'].length == 0)
				{
					//showMapNotification(Configuration.NOT_RATED_BY_OTHER_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
				}
				
				// No call to cleanupQuery, so take care of it manually here
				// for future reference, we can use cleanupQuery if we want to have the bigBang effect
				// You have to turn on queryRefreshAndBang and reset the big bang effect 
				
				// Move user dot and background to front
				adjustDotLayers(); 
				
				// Set flag for query processing
				queryInProcess = false;
				
				if(spriteToFocusOnCallBack != "")
				{
					processDotClick(spriteObjects[spriteToFocusOnCallBack]);
					spriteToFocusOnCallBack = "";
				}
				
			}
			
			private function handleGetRatedUpdatedComments():void {
				// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_BY_USERS_LOADED");
				
				// Extract variables from the JSON object
				var decoded:Object = JSON.decode(getRatedUpdatedComments.lastResult.toString());
				getRatedUpdatedComments.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
				if (AuthenticationUtils.resultIsAuthRequired(decoded))
					return;
				
				// Clear all the points and the state variables for comments
				flushAllPointsAndData(false);
				
				// Store comment info and draw points (the order of these functions matters)
				storeCommentJSON(decoded['comments']);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length);
				storeRatingsJSONandDraw(decoded['ratings']);
				storeUserData(decoded['user_data']);
				parseAndStoreRatings(decoded['ratings']);
				
				// Show notification
                if (decoded['comments'].length == 0)
                {
                	showMapNotification(Configuration.NO_RATED_UPDATED_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
                }
                				
				// Normal query housekeeping
				cleanupQuery();
			}
			
			private function handleGetNeverSeenComments():void {
				// Log the event
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "RATED_BY_USERS_LOADED");
				
				// Check for eigenvalues -- this only pertains to the initial load
            	if (eigenvectors.length == 0 || eigenvectors[0].length == 0) {
                    // The request that sets the eigenvectors hasn't completed yet
                    setTimeout(handleGetNeverSeenComments, 100);
                    return;
                }
				
				// Extract variables from the JSON object
				var decoded:Object = JSON.decode(getNeverSeenComments.lastResult.toString());
				getNeverSeenComments.disconnect(); //kill the connection after we are done using it
				
				// TODO: Better error handling
				if (AuthenticationUtils.resultIsAuthRequired(decoded))
					return;
				
				// Clear all the points and the state variables for comments
				
				if(!leaderboardUsersOnMap)
				{
				flushAllPointsAndData(false);
					// Hide leaderboard - Add here also, since system refresh also invokes
                // this function, which won't call the sendGetUnratedUsers function
            	leaderboardUsersOnMap = false;
								
				// Store comment info and draw points (the order of these functions matters)
				storeCommentJSON(decoded['comments']);
				storeSortedIDsToBuckets(decoded['sorted_comments_ids'], userIdToCommentScoreBucket, POINT_SIZES.length);
				storeSortedIDsToBuckets(decoded['sorted_avg_agreement'], userIdToAvgAgreementBucket, POINT_COLORS.length, decoded['no_statements']);
				storeRatingsJSONandDraw(decoded['ratings']);
				storeUserData(decoded['user_data']);
				parseAndStoreRatings(decoded['ratings']);
				}
				
				// Show notification if null result for a query
                if (decoded['comments'].length == 0 && decoded['query'])
                {
                	showMapNotification(Configuration.NO_NEW_RESPONSES_MSG, Configuration.MAP_NOTIFICATION_TIMEOUT);
                }

				if (!decoded['query']) // Some cleanup housekeeping ONLY for os creation and system refreshes
				{
					drawingUsers = false;
	                if (twinkleOn) setTimeout(twinkle, 3000); // Turns twinkling on when the function terminates
	                if (refreshingOtherUsers) // adjust dots if no big bang effect 
	                {
	                	// call adjust dots to align dots with current pan/zoom settings
	                    if (!this.parentApplication.refreshAndBang && !queryRefreshAndBang) {
	                    	adjustDots(false);
	                    } 
	                    refreshingOtherUsers = false;
	                    this.parentApplication.endRefresh();
	                } else 
	                {
	                	this.parentApplication.endCreateOS();
	                }
					// TODO: Revisit the highlighting of low confidence points
					// if (allRadiating && (lowConfidenceArray.length != 0)) highlightLowConfidencePoints(); // Add effect for low confidence points
					if(this.parentApplication.usernameSearch)
					{
						if (Configuration.SHOW_WALKTHROUGH && !this.parentApplication.isUserAuthenticated)
							this.parentApplication.opinionMap.mapOverlay.showWalkthrough();
												
						this.parentApplication.displayOpinionMap();
						this.parentApplication.currentState = 'home';
						var uid:String = usernameToUid[this.parentApplication.argumentUsername.toString().toLowerCase()];
						for(var i:int = 0; i< spriteNames.length; i++)
							if(spriteNames[i] != uid)
							{
								spriteObjects[spriteNames[i]].alpha = 0;
								spriteObjects[spriteNames[i]].removeEventListener(MouseEvent.CLICK, handleDotClick);  
								spriteObjects[spriteNames[i]].removeEventListener(MouseEvent.MOUSE_OVER, dotOver);
							}
					}
					// Show user's point (moved out the general refresh)
					if (!Configuration.VERTICAL_ORIENTATION)
						processDotClick(curUserDot);
				} 
				else // Normal query housekeeping 
				{
					cleanupQuery();
				}
			}
			
			public function unHideOtherUsers():void
			{
				for(var i:int = 0; i< spriteNames.length; i++)
					if(spriteNames[i] != uid)
					{
						spriteObjects[spriteNames[i]].alpha = 1;
						spriteObjects[spriteNames[i]].addEventListener(MouseEvent.CLICK, handleDotClick);  
						spriteObjects[spriteNames[i]].addEventListener(MouseEvent.MOUSE_OVER, dotOver);
					}
			}
            
			public function showTooltipOnUser():void {
				userSearchPrompt = createFloatingPromptTop("Here is " + this.parentApplication.argumentUsername + "'s bloom, click on it to view the idea")
				var uid:String = usernameToUid[this.parentApplication.argumentUsername.toString().toLowerCase()];
				if (uid != null) {
					if (spriteObjects[uid] != null) 
					{
						userSearchPrompt.x = spriteObjects[uid].x - userSearchPrompt.width/2 + 12;
						userSearchPrompt.y = spriteObjects[uid].y - 30;
						plotCanvas.addChild(userSearchPrompt);
					}  
				}
			}
			
			public function removeTooltipOnUser():void
			{
				if(!this.parentApplication.isUserAuthenticated)
				{
					var uid:String = usernameToUid[this.parentApplication.argumentUsername.toString().toLowerCase()];
					var fadeIn:Transitioner = new Transitioner(2.5, Easing.none); // Other easing effects to be added here
					for(var i:int = 0; i< spriteNames.length; i++)
					{
						if(spriteNames[i] != uid)
						{
							fadeIn.$(spriteObjects[spriteNames[i]]).alpha = 1;
							spriteObjects[spriteNames[i]].addEventListener(MouseEvent.CLICK, handleDotClick);  
							spriteObjects[spriteNames[i]].addEventListener(MouseEvent.MOUSE_OVER, dotOver);
						}
						else
						{
							fadeIn.$(spriteObjects[spriteNames[i]]).alpha = 0;
							spriteObjects[spriteNames[i]].removeEventListener(MouseEvent.CLICK, handleDotClick);  
							spriteObjects[spriteNames[i]].removeEventListener(MouseEvent.MOUSE_OVER, dotOver);
						}
					}
					fadeIn.play();
				}
				this.parentApplication.argumentUsernameSaved = this.parentApplication.argumentUsername;
				this.parentApplication.argumentUsername = "";
				//plotCanvas.removeChild(userSearchPrompt);
			}
			
            /**
             * Callback handler for the getOtherUsers HTTPService
             * Gets all the other users' ratings, and multiplies them by each eigenvector to get their
             * projection on the OpinionMap. Then creates their dots.
             */
            private function handleGetOtherUsers():void {
                // Log that the handleGetOtherUsers handler was called
                //this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "OTHER_USERS_LOADED");
                
                if (eigenvectors.length == 0 || eigenvectors[0].length == 0) {
                    // The request that sets the eigenvectors hasn't completed yet
                    setTimeout(handleGetOtherUsers, 100);
                    return;
                }
                
                // Note that the code below results in the curSelectedSprite being deselected
                if (refreshingOtherUsers) {
                    removeDots(false); 
                    clearOtherUserData();
                    twinkleOn = true;
                }
                
                // Extract variables from the JSON object
                var decoded:Object = JSON.decode(getOtherUsers.lastResult.toString());
				getOtherUsers.disconnect(); //kill the connection after we are done using it
				
                var ratingsDecoded:Array = decoded['other_ratings'];
                var commentsDecoded:Array = decoded['comments'];
                
               	// Store leaderboard info
               	storeLeaderboardInfo(decoded['top_responses'], decoded['top_reviewers'], decoded['rising_comments']);
               	
                dotToolTipsEnabled = true;
                
                storeCommentJSON(commentsDecoded);
                
                // Check for no other ratings
                if (ratingsDecoded.length == 0) {
                    terminateHandleGetOtherUsers();
                    return;
                }
                
                // Draw
                storeRatingsJSONandDraw(ratingsDecoded);
            }
            
            /**
            * Finishes the getOtherUsers call
            */ 
            private function terminateHandleGetOtherUsers():void {
                drawingUsers = false;            	
            	
                // Turns twinkling on when the function terminates
                if (twinkleOn) setTimeout(twinkle, 3000);
                
                if (refreshingOtherUsers) {
                	// call adjust dots to align dots with current pan/zoom settings
                    if (!this.parentApplication.refreshAndBang && !queryRefreshAndBang) {
                    	adjustDots(false);
                    } 
                    refreshingOtherUsers = false;
                    this.parentApplication.endRefresh();
                } else {
                	this.parentApplication.endCreateOS();
                }
                
                // Move user dot and background to front
				adjustDotLayers();
				
				// Add effect for low confidence points
				if (allRadiating && (lowConfidenceArray.length != 0)) highlightLowConfidencePoints();
            }
      
            /**
            * Draws the other dots (dots besides the current user's) on the flare visual.
            * 
            * Stores the sprite and other meta data within the corresponding data structures
            */ 
            private function drawOtherUserDots(x:Number, y:Number, id:int, commentScore:Number):void {
				var lowConfidence:Boolean = false;
                
                var colorAndAlpha:Dictionary = getAlphaAndColor(id.toString());
                var dotAlpha:Number = colorAndAlpha['alpha'];
                var dotColor:Number = colorAndAlpha['color'];
                
                // If user is not authenticated, then they are viewing the first time tutorial
                //if (!this.parentApplication.isUserAuthenticated && id != firstTimeHighlightedPointId)
                	//dotAlpha = firstTimeTutorialAlpha;
                
                // Dots emerge effect
                var xPixel:Number = transformXCoorToPixels(x);
                var yPixel:Number = transformYCoorToPixels(y);
                
                // Extract visual vars
                var visualVars:Array = storedVisualVars[id.toString()];
                
                var spr:Sprite = new Sprite();
				
				var size:Number = mapScoreToRadius(id.toString(), commentScore);
				var color:int = mapUidToColor(id.toString());
				
				if(this.parentApplication.usernameSearch)
				{
					var uid:String = usernameToUid[this.parentApplication.argumentUsername.toString().toLowerCase()];
					if (uid == id+"")
					{
						color = 0xCC0000;
						size = 20;
					}
				}
				
				//if (size == POINT_SIZES[0])
				//	color = 0x888888;
				
				spr = this.parentApplication.PointDrawer.drawDisc(color,0,0,size/7,size);
                
                // Determine what to draw
                /*
                var ideaStages:Array = this.parentApplication.PointDrawer.ideaProgression();
                
                // Draw bud if # ratings < 2
                if (visualVars[2] < Configuration.AUTHOR_RATINGS_THRESHOLDS[0])
                	spr = ideaStages[0];
                else if(visualVars[2] < Configuration.AUTHOR_RATINGS_THRESHOLDS[1])
                	spr = ideaStages[1];
                else if(visualVars[2] < Configuration.AUTHOR_RATINGS_THRESHOLDS[2])
                	spr = ideaStages[2];
                else
                	spr = ideaStages[3];
				*/
				
				             
				spr.x = xPixel;
                spr.y = yPixel;
                spr.name = id.toString();				
				spr.buttonMode = true;
				spr.addEventListener(MouseEvent.CLICK, handleDotClick);  
				spr.addEventListener(MouseEvent.MOUSE_OVER, dotOver);
					
                /*
                var spr:Sprite = createCircle(xPixel,
		                                   yPixel,
		                                   id.toString(), 
		                                   mapScoreToRadius(id.toString(), commentScore),
		                                   dotAlpha,
		                                   dotColor);
				*/
                if (this.parentApplication.refreshAndBang || queryRefreshAndBang) 
                {	
                	// have the point fade in
                	spr.alpha = 0;
                	
					if(!userSignedUp)
                		bigBang.$(spr).alpha = 1; // Added a fix here to avoid having the alphas cascade. Old colde was: dotAlpha;
					else
						fadeOutSprites.push(spr);
                	// IF rated, mark by making it less transparent
                	/*
					if (storedCommentRating[id.toString()] != null && storedAgreementRating[id.toString()] != null) 
					{
	                	if (storedCommentRating[id.toString()] != -1 && storedAgreementRating[id.toString()] != -1)
	                	{ 
	                		bigBang.$(spr).alpha = Configuration.IDEA_RATED_ALPHA;
	                	}    
	                } */
                	
                	// have the point grow in size
                	spr.scaleX = .1;
					spr.scaleY = .1;
                	bigBang.$(spr).scaleX = 1;
                	bigBang.$(spr).scaleY = 1;                	
                }                
                
				// Added for first time
				/*if (!this.parentApplication.isUserAuthenticated && id == firstTimeHighlightedPointId)
				{
					var halo:Sprite = createHalo(0, 0, id.toString()+'halo', 2, .4, 30, Configuration.USER_DOT_COLOR);
	       			hasHalo[spr.name] = true;
	       			idToHaloRadius[spr.name] = 10;
	       			spr.addChild(halo);
					
					// create notification
					if(firstTimeTutorialNumRated == 0 && firstTimeTooltip == null)
					{
						firstTimeTooltip = new HBox();
						firstTimeTooltip.percentWidth = 70;
						firstTimeTooltip.x = 40;
						firstTimeTooltip.y = 50;
						var firstTimeTooltipText:Text = new Text();
						firstTimeTooltipText.htmlText = Configuration.HIGHLIGHTED_POINT_CLICK_NOTICE;
						firstTimeTooltipText.percentWidth = 100;
						firstTimeTooltipText.styleName = "firstTimeIntroPromptText";
						firstTimeTooltip.addChild(firstTimeTooltipText);
						plotCanvas.addChild(firstTimeTooltip);
					}
	       			
	       			setTimeout(haloRadiation, 2000, halo);
				} else*/
				
				hasHalo[spr.name] = false;
				
					
				/* Remove the halo code for now
				// Add a halo to each point. Only turn on the halos for top rated points
        		var haloRadius:Number = 10;
        		var on:Boolean = false;
                for (var m:int = 0; m < topResponseUids.length; m++) {
	                if (topResponseUids[m] == id.toString()) {
                    	if (userIdToCommentConfidence[id.toString()] != null) {
		                	if (userIdToCommentConfidence[id.toString()] <= .15) {
		                		if (m <= 5) haloRadius = 30;
		                		else if (m <= 10) haloRadius = 22;
		                		else haloRadius = 18;
								on = true;		
		                	}
		                }	
	                }
               	}
        		
        		var halo:Sprite = createHalo(0, 0, id.toString()+'halo', HALO_THICKNESS, .4, haloRadius, dotColor);
        		if (!on) halo.alpha = 0;
       			hasHalo[spr.name] = true;
       			idToHaloRadius[spr.name] = haloRadius;
       			spr.addChild(halo);
       			
       			if (allRadiating && on) setTimeout(haloRadiation, Math.random()*5000, halo);
                */
                var gradientGlow:GradientGlowFilter = new GradientGlowFilter();
                gradientGlow.distance = 0;
                gradientGlow.angle = 0;
                gradientGlow.colors = [0x000000, dotColor, dotColor, dotColor];
                gradientGlow.alphas = GRADIENT_GLOW_ALPHA;
                gradientGlow.ratios = GRADIENT_GLOW_RATIO;
                gradientGlow.blurX = 20;
                gradientGlow.blurY = 20;
                gradientGlow.strength = 4;
                gradientGlow.quality = BitmapFilterQuality.MEDIUM;
                gradientGlow.type = BitmapFilterType.OUTER;
                //spr.filters = [gradientGlow];
				
				originalCoordinates[spr.name] = new Point(x, y);
                spriteObjects[spr.name] = spr;
                spriteNames.push(spr.name);
                inContainer[spr.name] = true;
                container.addChild(spriteObjects[spr.name]);				
                if (lowConfidence) lowConfidenceArray.push(spr);
            }
            
            /**
            * Transforms x cartesian coordinate to pixel value
            * 
            * This coordinate space assumes the upper left corner is (0,0)
            */ 
            private function transformXCoorToPixels(x:Number):Number {
                var delta:Number = Math.abs(x - _graphMin.x);
                var ratio:Number = delta / xAxisMax;
                
                return ratio * (flareVis.width - xUpperPadding  - xLowerPadding) + xLowerPadding;
            }
            
            /**
            * Transforms y cartesian coordinate to pixel value
            * 
            * This coordinate space assumes the upper left corner is (0,0)
            */ 
            private function transformYCoorToPixels(y:Number):Number {
                var delta:Number = Math.abs(y - _graphMin.y);
                var ratio:Number = delta / yAxisMax;
                return ratio * (flareVis.height - yUpperPadding  - yLowerPadding) + yLowerPadding;
            }
			
			/**
			 * Transforms y pixel value into coordinate space
			 * 
			 * Both pixel and coordinate space assume the upper left is (0,0)
			 */ 
			private function transformPixelsToYCoor(y:Number):Number {
				return (y - yLowerPadding)*yAxisMax/(flareVis.height - yUpperPadding  - yLowerPadding) + _graphMin.y;
			}
			
			/**
			 * Transforms x pixel value into coordinate space
			 * 
			 * Both pixel and coordinate space assume the upper left is (0,0)
			 */
			private function transformPixelsToXCoor(x:Number):Number {
				return (x - xLowerPadding)*xAxisMax/(flareVis.width - xUpperPadding  - xLowerPadding) + _graphMin.x;
			}
  
            /**
            * Maps a comment ratinging to a color
            */ 
            private function mapCommentRatingToColor(userId:String, commentRating:Number):Number {
                if (commentRating == -1) return Configuration.OTHER_DOT_COLOR;
                if (commentRating <= 0.17) return Configuration.BUCKET_1_COLOR;
                if (commentRating <= 0.33) return Configuration.BUCKET_2_COLOR;
                if (commentRating <= 0.50) return Configuration.BUCKET_3_COLOR;
                if (commentRating <= 0.66) return Configuration.BUCKET_4_COLOR;
                if (commentRating <= 0.83) return Configuration.BUCKET_5_COLOR;
                if (commentRating > 0.83) return Configuration.BUCKET_6_COLOR;
                return Configuration.OTHER_DOT_COLOR;
            }
            
            /**
            * Maps a normalized score to a radius for points on the space
            * 
            * Looks up size using userIdToCommentScoreBucket
            */ 
            private function mapScoreToRadius(userId:String, score:Number):int {
                // If there is no comment stored for this user
                if (storedComments[userId] == null && userId != "curUser") 
                    return POINT_SIZES[0];
                
                // TODO: Improve code for user's size
                
                if (Configuration.LENSES_ENBALED && approvedForLenses)
                {
                	return POINT_SIZES[0];
                }
                
                if (userId == 'curUser') return POINT_SIZES[POINT_SIZES.length-1];
                
                return POINT_SIZES[userIdToCommentScoreBucket[userId] - 1];
                
                /*
				switch (userIdToCommentScoreBucket[userId])
				{
					case 1:
						return INTERVAL2_DOT_SIZE;
					case 2:
						return INTERVAL3_DOT_SIZE;
					case 3:
						return INTERVAL4_DOT_SIZE;
					case 4:
						return INTERVAL5_DOT_SIZE;
					case 5:
						return INTERVAL6_DOT_SIZE;
					case 6:
						return INTERVAL7_DOT_SIZE;
					case 7:
						return INTERVAL8_DOT_SIZE;
					default:
						return -1;
				}                
                
                /*
                var interval:Number = 1/7;
                if (score == -1) return INTERVAL3_DOT_SIZE; // If there has been no ratings, score is -1
                if (score <= interval) return INTERVAL2_DOT_SIZE;
                if (score <= 2*interval) return INTERVAL3_DOT_SIZE;
                if (score <= 3*interval) return INTERVAL4_DOT_SIZE;
                if (score <= 4*interval) return INTERVAL5_DOT_SIZE;
                if (score <= 5*interval) return INTERVAL6_DOT_SIZE;
                if (score <= 6*interval) return INTERVAL7_DOT_SIZE;
                if (score <= 7*interval) return INTERVAL8_DOT_SIZE;
                return -1;*/
            }
            
            /**
            * Maps a avg agreement ratingto a color for points on the space
            * 
            * Looks up size using userIdToAvgAgreementBucket
            */ 
            private function mapUidToColor(userId:String):int {
                if (Configuration.LENSES_ENBALED && approvedForLenses)
                {
                	return POINT_COLORS[0];
                }
                
                return POINT_COLORS[userIdToAvgAgreementBucket[userId] - 1];
            }            
            
            /**
            * Adjusts the dot's radius to the given score. A bit complicated because it must
            * re-draw the dot's color. This must also take into consideration the mouse-over coloring.
            */ 
            private function adjustDotRadius(name:String, newScore:Number):void {
                    var radius:Number = mapScoreToRadius(name, newScore);
                    var spr:Sprite;
                    var dotAlpha:Number;
                    var dotColor:Number;
                    
                    // Locate the sprite object
                    if (name == "curUser") 
                    	return;//spr = curUserDot; 
                    else spr = spriteObjects[name];
                    
                    // Clear the drawing
                    spr.graphics.clear();
                    
                    // Set the dot color and alpha
                    if (name == "curUser") {
                    	dotAlpha = Configuration.USER_DOT_ALPHA;
                    	dotColor = Configuration.USER_DOT_COLOR;
                    } else {
                        var colorAndAlpha:Dictionary = getAlphaAndColor(name);
                		dotAlpha = colorAndAlpha['alpha'];
                		dotColor = colorAndAlpha['color'];
                    }
					
                    // Set the fill for the dot
                    spr.graphics.beginFill(dotColor, dotAlpha);
                    
                    // Set the fill for halo if it has one
                    if (hasHalo[spr.name]) {
                    	if (spr != curUserDot) {
                    		var halo:Sprite = Sprite(spr.getChildAt(0));
                    		halo.graphics.clear();
                        	halo.graphics.lineStyle(HALO_THICKNESS, dotColor, 0.4);            	
            				halo.graphics.drawCircle(0, 0, idToHaloRadius[spr.name]);
                    	}
                    }
                    
                    spr.graphics.drawCircle(0, 0, radius);

                    var gradientGlow:GradientGlowFilter = new GradientGlowFilter();
                    gradientGlow.distance = 0;
                    gradientGlow.angle = 0;
                    gradientGlow.colors = [0x000000, dotColor, dotColor, dotColor];
	                gradientGlow.alphas = GRADIENT_GLOW_ALPHA;
	                gradientGlow.ratios = GRADIENT_GLOW_RATIO;
                    gradientGlow.blurX = 20;
                    gradientGlow.blurY = 20;
                    gradientGlow.strength = 4;
                    gradientGlow.quality = BitmapFilterQuality.MEDIUM;
                    gradientGlow.type = BitmapFilterType.OUTER;
                    spr.filters = [gradientGlow];
            }
            
            /**
            * This is the periodic refresh every k seconds
            */ 
            public function autoRefresh():void {
                this.parentApplication.sendRefreshOS();
                setTimeout(autoRefresh, AUTO_REFRESH_TIMEOUT);
            }
            
            /**
            * Computes the dx and dy for a given zoom change
            */ 
            private function computeZoomDeltas(sprX:Number, sprY:Number, zoomCenterX:Number, zoomCenterY:Number, oldZoom:Number, newZoom:Number, id:String):Object {
                var x:Number = Math.abs(zoomCenterX - sprX); 
                var y:Number = Math.abs(zoomCenterY - sprY);
                var deltaArray:Object = new Object();
                if (x != 0 && y != 0) {         
                    var xSqd:Number = Math.pow(x,2);
                    var ySqd:Number = Math.pow(y,2);
                    deltaArray['x'] = (newZoom/oldZoom - 1)*(Math.sqrt( xSqd + ySqd )) 
                                      / ( Math.pow( (1 + ySqd/xSqd), 1/2 ));
                    deltaArray['y'] = deltaArray['x'] * y/x;
                } else {
                    if (x == 0) {
                        deltaArray['x'] = 0;
                        deltaArray['y'] = y * (newZoom/oldZoom - 1);
                    }
                    if (y == 0) {
                        deltaArray['x'] = x * (newZoom/oldZoom - 1);
                        deltaArray['y'] = 0;
                    }
                }
                return deltaArray;
            }
            
            /**
            * Resets the big bang
            */ 
            public function resetBigBang():void {
                bigBang = new Transitioner(2, Easing.easeInOutPoly(4)); // Change the easing to get a different effect         	
            }
            
            /**
            * This will make a call to the server to update the otherDots ArrayCollection with new data
            */
            public function refreshOtherDots():void {
                twinkleOn = false;               
                refreshingOtherUsers = true;
                
                // Create the other users' dots.
                if (Configuration.LENSES_ENBALED && approvedForLenses)
                {
                	// Show all dots if lenses enabled
                	getAllCurrentComments.url = this.parentApplication.httpUtils.getServiceUrl("os/all/" + this.parentApplication.opinionSpaceId + "/");
                	getAllCurrentComments.send();
                } else
                {
                	// Normal operation
					var parameters:Object = new Object();
            	
	            	// Send entry code for authentication if needed                
	                if (Configuration.USE_ENTRY_CODES)
		            	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
		            
		            if (!this.parentApplication.isUserAuthenticated)
		            	parameters['no_statements'] = Configuration.NO_STATEMENTS;
		            	
		            getNeverSeenComments.send(parameters);
                	
                	// TEMP DEBUG LOGGING
                	if (Configuration.DEBUG_LOGGING)
						this.parentApplication.log.logUserEvent(1, -1, "getNeverSeenComments called - in refreshOtherDots");
                }
            }
            
            /**
            * Draws a basic circle sprite 
            */
            private function createCircle(x:Number, y:Number, id:String, radius:int, alpha:Number, color:Number, background:Boolean = false):Sprite {
                var sprite:Sprite = new Sprite();
                
                sprite.graphics.beginFill(color, alpha);
                sprite.graphics.drawCircle(0, 0, radius);
                        
                sprite.x = x;
                sprite.y = y;
                sprite.name = id;
				
				if (!background)
				{
					sprite.buttonMode = true;
					sprite.addEventListener(MouseEvent.CLICK, handleDotClick);  
					sprite.addEventListener(MouseEvent.MOUSE_OVER, dotOver);	
				}
				
                return sprite;
            }

			/**
			 * Draws a ring as a normal point in the space. Not used currently
			 */             
            private function createRing(x:Number, y:Number, id:String, radius:int, alpha:Number, color:Number):Sprite {
                var sprite:Sprite = new Sprite();
                
            	sprite.graphics.lineStyle(2, color, alpha);            	
            	sprite.graphics.drawCircle(0, 0, radius);
                        
                sprite.x = x;
                sprite.y = y;
                sprite.name = id;
                sprite.buttonMode = true;
                sprite.addEventListener(MouseEvent.CLICK, handleDotClick);  
                sprite.addEventListener(MouseEvent.MOUSE_OVER, dotOver);
                return sprite;
            }            
            
            /**
            * Draws a user halo
            */ 
            private function createHalo(x:Number, y:Number, id:String, lineThickness:Number, alpha:Number, radius:int, color:Number):Sprite {            
            	var sprite:Sprite = new Sprite();
            	
            	sprite.graphics.lineStyle(lineThickness, color, alpha);            	
            	sprite.graphics.drawCircle(0, 0, radius);
            	sprite.x = x;
            	sprite.y = y;
            	sprite.name = id;
            	return sprite;
            }

			/**
			 * Creates a rectangle for point highlighting
			 */ 
            private function createRectangle (x:Number, y:Number, id:String, lineThickness:Number, alpha:Number, width:int, height:int, color:Number):Sprite
            {
            	var sprite:Sprite = new Sprite();
            	
            	sprite.graphics.lineStyle(lineThickness, color, alpha);            	
            	sprite.graphics.drawRect(0, 0, width, height);
            	sprite.x = x;
            	sprite.y = y;
            	sprite.name = id;
            	return sprite;
            }
            
            /**
            * Draws a line between the two specified points
            */ 
            private function createLine(pt1:Sprite, pt2:Sprite, id:String, lineThickness:Number, alpha:Number, color:Number):Sprite {
            	var sprite:Sprite = new Sprite();
            	
            	sprite.graphics.lineStyle(lineThickness, color, alpha);   
            	sprite.graphics.lineTo(pt2.x-pt1.x, pt2.y-pt1.y);
            	sprite.x = pt1.x;
            	sprite.y = pt1.y;
            	sprite.name = id;
            	return sprite;            	
            }
            
            /**
            * Redraws a line
            */
            private function redrawLine(line:Sprite, pt1:Sprite, pt2:Sprite, lineThickness:Number, alpha:Number, color:Number):void {
            	line.graphics.clear();
            	
            	line.graphics.lineStyle(lineThickness, color, alpha);   
            	line.graphics.lineTo(pt2.x-pt1.x, pt2.y-pt1.y);
            	line.x = pt1.x;
            	line.y = pt1.y;
            }
               
            /**
            * Event handlers for mouse-over highlighting functionality
            */ 
            private function selectedDotOut(e:MouseEvent):void {
            	try {
           	 		if (dotToolTip != null) {
                		ToolTipManager.destroyToolTip(dotToolTip);
                	}
             	} catch (e:ArgumentError) {}
            }
            
            private function dotOut(e:MouseEvent):void {
                try {
                	try {
                    	if (dotToolTip != null) {
                        	ToolTipManager.destroyToolTip(dotToolTip);
                    	}
                 	} catch (e:ArgumentError) {}
                    var spr:Sprite = Sprite(e.target);
                    if (spr.name.indexOf("halo") != -1) return;
                    
                } catch (e:Error) {}
                
            }
            
            private function dotOver(e:MouseEvent):void {
                //try{
				//Alert.show(getFlareVisHeight() + " " + getFlareVisWidth() + " " + getLeftPanelWidth());
                    var spr:Sprite = Sprite(e.currentTarget);
                    if (spr.name.indexOf("halo") != -1 || spr.name.indexOf("curUser") != -1){
						moveToFront(spr);
						return;
					}
					
					if (storedCommentRating[spr.name] != null && storedAgreementRating[spr.name] != null) 
					{
						if (storedCommentRating[spr.name] != -1 && storedAgreementRating[spr.name] != -1)
						{
							moveToBackRated(spr);
						}
						else
						{
							moveToFront(spr);
						}
					}
					else
					{
						moveToFront(spr);
					}
					
					if (sprIsAnimating[spr.name] == null || sprIsAnimating[spr.name] == false)
					{
						
						var t1:Tween = new Tween(spr, .75, {rotation:180});
						var t2:Tween = new Tween(spr, .75, {rotation:0});
						var seq:Sequence = new Sequence(t1,t2);
						seq.addEventListener(TransitionEvent.END, function():void{sprIsAnimating[spr.name]=false;});
						sprIsAnimating[spr.name] = true;
						seq.play();
					}
					               
            }
            
            public function showDotToolTipAfterDelay():void {
	            if (dotToolTipTimeoutId != -1) {
	            	clearTimeout(dotToolTipTimeoutId);
	            }
	            dotToolTipTimeoutId = setTimeout(showDotToolTip, 250);
            }
            
            public function showDotToolTipTemporarily():void {
                showDotToolTip();
            }
            
            public function showDotToolTip():void {
                dotToolTip.visible = true;
            }
            
            public function hideDotToolTip():void {
                dotToolTip.visible = false;
            }

			/**
			 * Changes a given sprite's color and alpha 
			 */ 
            public function changeColor(spr:Sprite, color:Number, alpha:Number):void {
            	return;
            	      
                spr.graphics.clear();
                spr.graphics.beginFill(color, alpha);
                if (true) spr.graphics.drawCircle(0, 0, mapScoreToRadius(spr.name, storedCommentScore[spr.name]));             
                else if (spr == curUserDot) {
	                var userDotRadius:Number = mapScoreToRadius("curUser", this.parentApplication.userCommentNormalizedScore);
	                spr.graphics.drawCircle(0, 0, userDotRadius);                     	
                } 
                else spr.graphics.drawCircle(0, 0, INTERVAL7_DOT_SIZE); // This is a landmark
            }
            
            /**
            * Determines the dot color and alpha
            */ 
            public function getAlphaAndColor(name:String):Dictionary {
                var dotAlpha:Number = Configuration.OTHER_DOT_ALPHA;
                var dotColor:Number = Configuration.OTHER_DOT_COLOR;
            
                // If there is a comment, set color and alpha if it is low conf
                // Otherwise set a gray point
                if (storedComments[name] != null) {
					if (userIdToCommentConfidence[name] != null) {
	                	if (userIdToCommentConfidence[name] > .15) {
	                		dotColor = Configuration.LOW_CONFIDENCE_DOT_COLOR;
	                		dotAlpha = Configuration.LOW_CONF_ALPHA;
	                	}
	                }                            
                } else {
                	dotAlpha = Configuration.OTHER_DOT_UNCOMMENTED_ALPHA;
                }
                
            	// Determine color based off a stored rating if there is one
                if (storedCommentRating[name] != null) {
                	if (storedCommentRating[name] != -1) 
                		dotColor = mapCommentRatingToColor(name, storedCommentRating[name]);    
                }  
                
               if(filterColorMap[name] != null)
		         {
					dotColor = filterColorMap[name];	                
		         }
		         
		        // Added for first time tutorial
		        //if (!this.parentApplication.isUserAuthenticated && spriteObjects[name] != spriteObjects[firstTimeHighlightedPointId] && firstTimeTutorialNumRated == 0)
					//dotAlpha = firstTimeTutorialAlpha;
				
				/*if (firstTimeTutorialInsightRatings[name] != null)
                {
                	dotColor = mapCommentRatingToColor(name, firstTimeTutorialInsightRatings[name]);
                }*/
				
                var ret:Dictionary = new Dictionary();
                ret['color'] = dotColor;
                ret['alpha'] = dotAlpha;
                return ret;
            }
            
            public function turnOnTwinkle():void {
                twinkleOn = true;
            }
            
            public function turnOffTwinkle():void {
                twinkleOn = false;
            }
            
            /**
            * Random twinkle effects - currently references a null object 5/31/10
            */ 
            public function twinkle():void {
                if (twinkleOn && (spriteNames.length > 0)) { // Don't twinkle when there are no sprites!
                    if (!glowing) tweenGlow();

                    var repeat:int = Math.random() * TWINKLE_TIME_BASE;
    
                    if (repeat < MIN_TWINKLE_FREQ)
                        repeat = MIN_TWINKLE_FREQ;
                        
                    if (repeat > MAX_TWINKLE_FREQ)
                        repeat = MAX_TWINKLE_FREQ;

                    setTimeout(twinkle, repeat);
                }
            }
            
            // Function to shrink a dot, but not used for twinkling
            /*
            private function tweenShrink(name:String):void {
                try{
                    var t1:Tween = new Tween(container.getChildByName(name), SHRINK_TIME, {scaleX:.3, scaleY:.3});  
                    t1.easing = Easing.none;
                    var t2:Tween = new Tween(container.getChildByName(name), SHRINK_TIME, {scaleX:1, scaleY:1});
                    t2.easing = Easing.none;
                
                    var seq:Sequence = new Sequence(
                        t1, t2
                    );
                    
                    seq.play();
                } catch (e:Error) {
                    trace(e.message);
                }
            }
            */
            
            /**
            * Makes one randomly selected dot glow.
            * Note: the glowing boolean is set to false before the glowing of a dot is done. Perhaps this is an issue?
            */ 
            private function tweenGlow():void {
                try {
                    glowing = true;
					
					/*
					// ADDED FOR 2.0 - top dot scores twinkle
					var n:int = Math.random() * (topResponseUids.length - 1);
					
					// ADDED FOR 2.0 - quick fix, if the dot is a low confidence dot, don't twinkle
					if (userIdToCommentConfidence[topResponseUids[n]] != null) {
	                	if (userIdToCommentConfidence[topResponseUids[n]] > .15) {
	                		glowing=false;
	                		return;
	                	}
	                }				
                    
                    var spr:Sprite = spriteObjects[topResponseUids[n]];
                    */
                    
                    var n:int = Math.random() * (spriteNames.length - 1);
                    
                    var spr:Sprite = spriteObjects[spriteNames[n]];
                    
	                var twn:Tween = new Tween(spr, GLOW_SPEED, {"filters[0].alphas":[0, .3, .5, .7],
	                                                   "filters[0].ratios":[0, 25, 50, 127],
	                                                   scaleX:1, scaleY:1});
	                twn.easing = Easing.none;
	                var twn1:Tween = new Tween(spr, GLOW_SPEED, {"filters[0].alphas":GRADIENT_GLOW_ALPHA,
	                                                   "filters[0].ratios":GRADIENT_GLOW_RATIO,
	                                                   scaleX:1, scaleY:1});
	                twn1.easing = Easing.none;
                    var seq:Sequence = new Sequence(twn, twn1);
                    seq.addEventListener(TransitionEvent.START, glowStart);
                    seq.addEventListener(TransitionEvent.END, glowEnd);
                    
                    var myMaxTwinkleThreads:int = Math.min(MAX_TWINKLE_THREADS, Math.max(MIN_TWINKLE_THREADS, (spriteNames.length / TWINKLE_THREAD_FACTOR)));
                    if (twinkleThreads <= myMaxTwinkleThreads) {
                        seq.play();
                    }

                    glowing = false;
                } catch (e:Error) {
                    trace(e.message);   
                }
            }
            
            /**
            * Event handlers for glowing
            */ 
            private function glowStart(event:TransitionEvent):void {
                twinkleThreads++;
            }
            
            private function glowEnd(event:TransitionEvent):void {
                twinkleThreads--;
            }
            
            /**
             * Handler for when a user clicks on a dot
             */
            private function handleDotClick(e:MouseEvent):void {
            	try {
            		if (dotToolTip != null) {
                		ToolTipManager.destroyToolTip(dotToolTip);
                	}
             	} catch (e:ArgumentError) {}
            	
                e.stopPropagation();

				try {
	                var spr:Sprite = Sprite(e.currentTarget);
	                
	                processDotClick(spr);
   				} catch (e:Error) {
   					// do nothing
   				}	
            }
            
			
            /**
            * The meat of the click handler
            */ 
            private function processDotClick(spr:Sprite):void {
				if (spr.name.indexOf("halo") != -1 || spr.name.indexOf("fake") > -1)
				{
					return;
				}
				commentModule.removeSuggestionBox();
                // don't process dot clicks during placing of point
				if(vslider.visible && vsliderText.visible)
				{
					return; 
				}
				
                // If in the middle of signup, disallow
                if (mapOverlay.currentState == 'signup' || mapOverlay.currentState == 'statements')
                	return;
				
				                
                // Shrink the previously selected point if it's new
                if (curSelectedSprite != null && curSelectedSprite != spr)
                {
                	var t1:Tween = new Tween(curSelectedSprite, 1, {scaleX:1, scaleY:1});
					t1.play();	
					refreshIdea(curSelectedSprite.name)
                }
                
                /*
            	if (highlightBox == null) {
            		//highlightBox = createRectangle(spr.x - 35, spr.y - 35, 'highlightBox', 3, 0, 70, 70, 0x3555a5);
            		highlightBox = createHalo(spr.x, spr.y, 'highlightBox', HALO_THICKNESS, 1, USER_DOT_HALO_RADIUS, 0xffffff);
            		container.addChild(highlightBox);
            	} else {
            		highlightBox.x = spr.x;
            		highlightBox.y = spr.y;
            		showHighlightBox();
            	}
            	moveToFront(highlightBox);*/
            	moveToFront(spr);
            	highlightedPoint = spr;                
                curSelectedSprite = spr;
				
				// Enlarge the flower
				if (curSelectedSprite != curUserDot)
				{
					var t2:Tween = new Tween(spr, 1, {scaleX:2.5, scaleY:2.5});
					t2.play();
				}
				
				//Alert.show(originalCoordinates[spr.name].x + " " + originalCoordinates[spr.name].y)

                if (curSelectedSprite != null) {
					
					/*if(firstTimeTooltip != null && plotCanvas.contains(firstTimeTooltip) )
					{
						plotCanvas.removeChild(firstTimeTooltip)
					}*/
					
                    if (curSelectedSprite != curUserDot) {
		                var colorAndAlpha:Dictionary = getAlphaAndColor(curSelectedSprite.name);
		                var dotAlpha:Number = colorAndAlpha['alpha'];
		                var dotColor:Number = colorAndAlpha['color'];                                              
                        
                        // 2011.06.20
                        // TODO: 
                        // Rewrite the code to highlighting flowers
                        
                        //changeColor(curSelectedSprite, dotColor, dotAlpha);
                    } else if (curSelectedSprite == curUserDot) changeColor(curSelectedSprite, Configuration.USER_DOT_COLOR, Configuration.USER_DOT_ALPHA); 
                    //else changeColor(curSelectedSprite, Configuration.LANDMARK_COLOR, Configuration.LANDMARK_ALPHA);
                }
               
                if (curSelectedSprite != curUserDot) 
				{
					
					// Show comment panel or a text snippet
					if (!Configuration.VERTICAL_ORIENTATION)
                		refreshCommentPanel();
                	else
                	{
                		bloomSnippet.visible = true;
                		bloomSnippet.includeInLayout = true;
                		snippetUsername.text = String(userIdUsernameLocation[curSelectedSprite.name]['username']).toUpperCase() + ": ";
                		snippetText.text = "\"" + storedComments[curSelectedSprite.name] + "\"";
                	}
				}
                
                // Ensure that the rating panel is shown if the user's dot is clicked
                if (curSelectedSprite == curUserDot) {
					this.parentApplication.log.logUserEvent(this.parentApplication.opinionSpaceId,
						Log.USER_CLICKUSERDOT);
						
					if (!Configuration.VERTICAL_ORIENTATION)	
                    	showRatingModule();
                    else
                	{
                		bloomSnippet.visible = true;
                		bloomSnippet.includeInLayout = true;
                		snippetUsername.text = String(Configuration.YOUR_PROFILE_TITLE).toUpperCase();
                		if (hasFinishedComment)
                			snippetText.text = myComment;
                		else
                			snippetText.text = "Click '"+snippetExpand.label+"' to leave a response!";
                	}
                }
            }
            
            public function clickUserDot():void {
            	processDotClick(curUserDot);
            }
            
            /**
            * If the argumentUsername is not the current user's point, call this function
            */ 
            public function processArgumentUsername():void {
				// Show the comment module if there was an argument username
				var uid:String = usernameToUid[this.parentApplication.argumentUsername.toString().toLowerCase()];
				if (uid != null) {
					if (spriteObjects[uid] != null) 
						processDotClick(spriteObjects[uid]);	
				}
				
				this.parentApplication.argumentUsername = "";            	
            }
                       
			/**
			 * Function that handles any changes to the comment panel.
			 * It updates the comment panel to reflect new information when a dot is clicked
			 */                        
            public function refreshCommentPanel():void {
                var commentPanelVisible:Boolean = true;
                var commentRatingBarVisible:Boolean = true;
                var commentRatingBarTeaserVisible:Boolean = false;
                var xPixel:Number;
                var yPixel:Number;
                
				commentModule.oldValueAgreement = .5;
				commentModule.oldValueComment = .5;
				
				if (!loggedIn && firstTimeUserScore == 0)
				{
					transitionDemoText(Configuration.INSTRUCTIONS_2);
				}
				
                // If the dot is the user's, show his comment
                if (curSelectedSprite == curUserDot) {
						
                    curCommentUserId = USER_COMMENT_ID;
                    setComment(myComment, false, curCommentUserId.toString());
                    
                    xPixel = curUserDot.x;
                    yPixel = curUserDot.y;
                    
                    commentRatingBarVisible = false;
                    commentModule.commentTextAreaHeight = CommentModule.COMMENT_DISPLAY_HEIGHT
                }
                // Otherwise, if the dot is another user's, fetch it from storedComments (if it 
                // was also fetched from the DB) or from the DB
                else if (curSelectedSprite != null) {
                    var userId:String = curSelectedSprite.name;
                    if (userId != null) {
                        // For now, the error number is -1; we can think about a better number later
                        xPixel = curSelectedSprite.x;
                        yPixel = curSelectedSprite.y;
                        
                        var commentId:int;
                        if (storedCommentIds[userId] != null) {
                            commentId = storedCommentIds[userId]
                        }
                        else {
                            commentId = -1;
                        }
                        
                        commentModule.commentTextAreaHeight = CommentModule.COMMENT_DISPLAY_HEIGHT
                        this.parentApplication.log.logCommentView(commentId);
                        
                        
                        // If the comment is in storedComments, show it
                        if (storedComments[userId] != null) {
                            curCommentUserId = int(userId);
  							
  							// REWRITTEN: Added first time tutorial logic
  							if (!this.parentApplication.isUserAuthenticated)
  							{
  								// First time tutorial logic
  								if (firstTimeTutorialInsightRatings[userId] != null)
  									setCommentRating(firstTimeTutorialInsightRatings[userId]);
  								else
  									setCommentRating(-1);
  								
  								if (firstTimeTutorialAgreementRatings[userId] != null)
  									setCommentAgreement(firstTimeTutorialAgreementRatings[userId]);
	                            else 
	                            	setCommentAgreement(-1);
	                            	
  							} else
  							{
  								// Logged in logic
								if (storedCommentRating[userId] != null) {
	                               setCommentRating(storedCommentRating[userId]);
	                            }
	                            if (storedAgreementRating[userId] != null) setCommentAgreement(storedAgreementRating[userId]);
	                            else setCommentAgreement(-1);
  							}
                            
                            setComment(storedComments[userId], true, userId);
                            
                            // Give comment module comment id for suggestion box
                            commentModule.setCommentId(commentId);
                            
                            // Show rating bars
                            commentModule.setToRateResponse();
                            
                            // If the user is not logged in, don't show the rating bar even if the current comment exists
                            if (!loggedIn) {
                                commentRatingBarVisible = false;
                                commentRatingBarTeaserVisible = true;
                            }
                            else {
                                commentRatingBarVisible = true;
                                commentRatingBarTeaserVisible = false;
                            }
							
                        }
                        // Otherwise, there is no comment for this userId
                        else {
                            setComment(null, false, userId);
                            commentRatingBarVisible = false;
                        }
						
						showSelectedUserRatings();
						
						var picData:Object = userDataPairs[userId];
						if(picData != null)
						{
							var picURL:String = picData['picture']
							if(picURL == null || picURL == "null" || picURL == "")
							{
								commentModule.profile_pic.source = Configuration.UNKNOWN_USER;
							}
							else{
								commentModule.profile_pic.source = picURL;	
							} 
						}
						else{
							commentModule.profile_pic.source = Configuration.UNKNOWN_USER;
						}
						
						                       
                    }
                }
                // Otherwise, don't show the comment panel or rating bar
                else {
                    commentPanelVisible = false;
                    commentRatingBarVisible = false;
                    commentModule.commentTextAreaHeight = CommentModule.COMMENT_DISPLAY_HEIGHT;
                }
               
                if (commentPanelVisible) {
                    showCommentPanel();
                }
                else {
                    hideCommentPanel();
                }
                
                if (commentRatingBarVisible) {
                    showCommentRatingBar();
                }
                else if (commentRatingBarTeaserVisible) {
                    showCommentRatingBarTeaser();
                }
                else {
                    hideCommentRatingBar();
                }
            }
            
            public function hidePanels():void {
                if (Configuration.VERTICAL_ORIENTATION)
                {
                	hideRatingModule();
                	bloomSnippet.visible = false;
                    bloomSnippet.includeInLayout = false;
                }
                hideCommentPanel();
            }
            
            public function hideCommentPanel():void {
            	// Handle the coloring of the currently selected dot
				commentModule.removeSuggestionBox();
                if (curSelectedSprite != null) {
                    if (curSelectedSprite != curUserDot) {
		                var colorAndAlpha:Dictionary = getAlphaAndColor(curSelectedSprite.name);
		                var dotAlpha:Number = colorAndAlpha['alpha'];
		                var dotColor:Number = colorAndAlpha['color'];
                        
                        changeColor(curSelectedSprite, dotColor, dotAlpha);
                    }
                    else if (curSelectedSprite == curUserDot)  changeColor(curSelectedSprite, Configuration.USER_DOT_COLOR, Configuration.USER_DOT_ALPHA);
                    //else changeColor(curSelectedSprite, Configuration.LANDMARK_COLOR, Configuration.LANDMARK_ALPHA);
                }               
                
                commentModule.commentPanel.visible = false;
                
                this.leftPanelOtherUserViewer.visible = false;
                this.leftPanelOtherUserViewer.includeInLayout = false;
            	leftPanelOtherUserViewerLoggedout.visible = false;
            	leftPanelOtherUserViewerLoggedout.includeInLayout = false;
            	//flareVis.width = Configuration.SPACE_DIMENSIONS;
				//flareVis.height = Configuration.SPACE_DIMENSIONS;
            	// 2010.09.29: REMOVED FOR FIRST TIME TUTORIAL
            	//introTextBox.visible = true;
            	//introTextBox.includeInLayout = true;
                
                // Collapse the rating views after the panel is invisible
                // Note: This doesnt work completely because we there is a fadeout
                
                // TODO FOR 2.0 - never close user or landmark ratings
                //collapseUserRatings();
                //collapseLandmarkRatings();
                
                // Shrink the flower				
				// deselect cur selected sprite
                curSelectedSprite = null;
				
				// remove associated prompts if on screen
				removeFloatingPrompt(rateResponsePrompt);
				removeFloatingPrompt(leaveSuggestionPrompt);
				removeFloatingPrompt(ratedTranslucentPrompt);
				if(this.parentApplication.isUserAuthenticated && this.parentApplication.usernameSearch)
					removeTooltipOnUser()
					
            }
                
            public function showCommentPanel():void {
            	
            	// remove associated prompts if on screen
				removeFloatingPrompt(rateResponsePrompt);
				removeFloatingPrompt(leaveSuggestionPrompt);
				removeFloatingPrompt(ratedTranslucentPrompt);
				if(this.parentApplication.isUserAuthenticated && this.parentApplication.usernameSearch)
					removeTooltipOnUser()
            	
				this.parentApplication.ratingModule.suggestionModule.removeEditCommentBox();
				commentModule.commentPanel.visible = true;
            	
            	this.leftPanelOtherUserViewer.visible = true;
                this.leftPanelOtherUserViewer.includeInLayout = true;	
            	leftPanelOtherUserViewerLoggedout.visible = true;
            	leftPanelOtherUserViewerLoggedout.includeInLayout = true;
            	
            	// 2010.09.29: REMOVED FOR FIRST TIME TUTORIAL
            	//introTextBox.visible = false;
            	//introTextBox.includeInLayout = false;
            	
            	if (!this.parentApplication.isUserAuthenticated)
            	{
            		/// display another prompt when the comment module is displayed
            		if (!usernameSearchFirstTime && firstTimeIntroPromptText.text != Configuration.INCREASE_SCORE_PROMPT_LANGUAGE)
            			firstTimeIntroPromptText.text = Configuration.INCREASE_SCORE_PROMPT_LANGUAGE; 
            	} else
            	{
            		// Only would be visisble if it's the first time they're signing up
	        		firstTimeIntroPrompt.visible = false;
	        		firstTimeIntroPrompt.includeInLayout = false;
            	}
            	
                hideRatingModule(); // To make room for the comment panel (if rating module open)
				
				// rating response prompt
				if(numFullyRatedResponses==0 && !this.parentApplication.usernameSearch)// && numFullyRatedResponses==0)
				{
					//setTimeout(this.parentApplication.opinionMap.showRatingPrompt,1000);
					showRatingPrompt();
				}
            }
            
            /**
             * Handler for when a user clicks on the plot (but not a specific dot)
             */
            public function handlePlotClick():void {
                // Only hide panels and remove the selected dot color if this was a click and not a drag                 
				this.parentApplication.log.logUserEvent(this.parentApplication.opinionSpaceId,
					Log.USER_PLOTCLICK);
				
				if (!wasPanning) {
                	
                	// Clear the selected dot color
	                if (curSelectedSprite != null) {
						
	                    if (curSelectedSprite != curUserDot) {
			                var colorAndAlpha:Dictionary = getAlphaAndColor(curSelectedSprite.name);
							
							//mofo
			                var dotAlpha:Number = colorAndAlpha['alpha'];
			                var dotColor:Number = colorAndAlpha['color'];
		                	
							var t1:Tween = new Tween(curSelectedSprite, 1, {scaleX:1, scaleY:1});
							t1.play();
							
	                        changeColor(curSelectedSprite, dotColor, dotAlpha);
	                    }
	                    else if (curSelectedSprite == curUserDot)  changeColor(curSelectedSprite, Configuration.USER_DOT_COLOR, Configuration.USER_DOT_ALPHA);
	                    //else changeColor(curSelectedSprite, Configuration.LANDMARK_COLOR, Configuration.LANDMARK_ALPHA);
						refreshIdea(curSelectedSprite.name)
	                }                	
                	
                	// Close the panels
                    closedFromPanning = true;
                    hidePanels();
                    closedFromPanning = false;
                    
                    // Deselect any items in the leaderboards and hide the highlight box
                    leftList.selectedIndex = -1;
                    rightList.selectedIndex = -1;
                    hideHighlightBox();
                    
                    // Close the response stats box if open
                    hideResponseStats();
                    
                    // Close the related links box if open
                    this.parentApplication.hideRelatedLinks();
                    
                    // Show the default map left panel
                    //showMapLeftPanelDefault();
                    if (!Configuration.VERTICAL_ORIENTATION)
                    	showRatingModule();
                }
                wasPanning = false;
            }
            
            /**
             * Handler for when a user clicks on the comment flagging button
             */
            public function handleFlagClick():void {
                flagComment.url = this.parentApplication.httpUtils.getServiceUrl("os/flagcomment/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/");
                
                var parameters:Object = new Object();
                if (Configuration.USE_ENTRY_CODES)
                	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                
                flagComment.send(parameters);
            }
            
            /**
             * Callback handler for getComment: saves the comment in storedComments,
             * and shows it
             */
            private function handleGetComment():void {
                var commentDecoded:Object = JSON.decode(getComment.lastResult.toString());
                getComment.disconnect(); //kill the connection after we are done
                
                // TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(commentDecoded))
                	return;
                
                try {
                	var comment:Object = commentDecoded['comment'];

					
					storeLeaderboardInfo(commentDecoded['list_1'], commentDecoded['list_2'], commentDecoded['list_3']);
					storeCommentJSON([comment]);
					
					var userId:String = getUserId(comment);
					
					// Remove the back glow 2011.08.02
                    //adjustDotRadius(userId, commentScore);
                    
                    // Refresh idea
                    refreshIdea(userId, comment);
                    
                    curCommentUserId = int(userId);
					
					if(commentModule.currentState == 'history')
						commentModule.refreshHistory(true);
					
					if (spriteToMoveToBack!= null && storedCommentRating[spriteToMoveToBack.name] != -1 && storedAgreementRating[spriteToMoveToBack.name] != -1)
					{ 
						moveToBack(spriteToMoveToBack);
						spriteToMoveToBack = null;
					} 
                }
                catch (e:RangeError) {
                    // TODO: log error
                }
            }
            
            /**
             * Callback handler for flagComment: stores whether or not the comment
             * has been flagged during this session, and disables the flag button if it has
             */
            private function handleFlagComment():void {
                var result:Object = JSON.decode(flagComment.lastResult.toString());
				flagComment.disconnect(); //kill the connection after we are done;
                
                // TODO: Better error handling
                if (AuthenticationUtils.resultIsAuthRequired(result))
                	return;
                
                if (result["success"]) {
                    disableFlag();
                }
                else {
                    // TODO: log error
                    Alert.show("There was an error reporting this comment. Please try again.");
                }
            }
            
            /**
             * Shows the argument string as a comment (if the argument is a non-empty string),
             * and also handles whether or not to enable the flag button
             */
            private function setComment(comment:String, showFlagButton:Boolean, userId:String):void {
                if (comment == null || comment == '') {
                    commentModule.commentText.text = "This person has not yet responded to the current discussion question.";
                    hideFlag();
                    hideCommentRatingBar();
                }
                else {
                    if (comment != COMMENT_LOADING_MESSAGE && userId != USER_COMMENT_ID.toString()){
                        showCommentRatingBar();
                    }
                    
					if(Configuration.COMMENT_TITLES && comment.charAt(0) == '<' && comment.indexOf('>') != -1)
					{
						commentModule.title.text = comment.substring(1,comment.indexOf('>'));
						commentModule.commentText.text = comment.substring(comment.indexOf('>')+1,comment.length);
					}
					else
					{
						commentModule.title.text = "";
						commentModule.commentText.text = comment;
					}
					
                    if (showFlagButton && this.parentApplication.isUserAuthenticated) {
                        enableFlag();
                    }
                    else {
                        hideFlag();
                    }
                }
            }
            
            private function setCommentRating(value:Number):void {
                if (value == -1) {
                    commentModule.commentSlider.value = (Constants.MAX_RATING - Constants.MIN_RATING) / 2;
                }
                else {
                    commentModule.commentSlider.value = value;
                }            
            }
            
            private function setCommentAgreement(value:Number):void {
                if (value == -1) {
                    commentModule.agreementSlider.value = (Constants.MAX_RATING - Constants.MIN_RATING) / 2;
                }
                else {
                    commentModule.agreementSlider.value = value;
                }              	
            }
            
            private function hideFlag():void {
            	commentModule.flagButton.includeInLayout = false;
                commentModule.flagButton.visible = false;
                //commentModule.flagIcon.includeInLayout = false;
                //commentModule.flagIcon.visible = false;
            }
            
            private function showFlag():void {
            	commentModule.flagButton.includeInLayout = true;
                commentModule.flagButton.visible = true;
                //commentModule.flagIcon.includeInLayout = true;
                //commentModule.flagIcon.visible = true;
            }
            
            /**
             * Disables the flag comment button and changes its label accordingly
             */
            private function disableFlag():void {
                commentModule.flagButton.enabled = false;
                //commentModule.flagButton.toolTip = FLAGGED_LABEL;
                //commentModule.disableFlagIconMouseOver();
                showFlag();
            }
            
            /**
             * Enables the flag comment button and changes its label accordingly
             */
            private function enableFlag():void {
                commentModule.flagButton.enabled = true;
                //commentModule.flagButton.toolTip = UNFLAGGED_LABEL;
                //commentModule.enableFlagIconMouseOver();
                showFlag();
            }          
            
            /**
            * Checks the bounds of the sprite, if it is out of bounds, it removes the object
            */ 
            private function checkBounds(temp:DisplayObject, name:String):void {
                if (outOfBounds(temp.x, temp.y, name)){
                        if (inContainer[temp.name]) {
                            container.removeChild(temp);
                            inContainer[temp.name] = false;
                        }
                    } else { 
                        if (!inContainer[temp.name]) {
                            container.addChild(temp);
                            inContainer[temp.name] = true;

							adjustDotLayers();
                        }
                    }     
            }
            
            /**
            * Returns whether the object in quesiton is out of bounds
            * Note: This checks the x,y coordinate of the sprite. In regards to circles, the
            * x,y coordinate is the center of the circle. In regards to images and other sprites,
            * the x,y coordinate is the location of the sprite's top left pixel.
            */ 
            private function outOfBounds(x:Number, y:Number, name:String):Boolean {
                var radius:Number = getRadiusByName(name);
                
                if (x < radius - panZoomXLPad ||                        
                    x > (flareVis.width - radius - panZoomXUPad) ||
                    y < radius - panZoomYLPad || 
                    y > (flareVis.height - radius - panZoomYUPad)){
                        return true;
                    }
                return false;                  
            }
 
            
            /**
            * Gets the proper radius value for this object
            */ 
            private function getRadiusByName(name:String):Number {
                if (name == curUserDot.name) {
                    return USER_DOT_RADIUS;
                } else {
                    return mapScoreToRadius(name, storedCommentScore[name]);
                }               
            }
            
            /**
             * The doZoom function moves the dots away from the center, creating a zooming effect
             */
            public function doZoom():void {
                doZoomWithCenter(_graphOriginalCenter.x, _graphOriginalCenter.y);
            }
             
            public function doZoomWithCenter(x:Number, y:Number, mouseWheel:Boolean = false):void {
               /*TODO: try{
                	if (bigBang.running) return;
                	
                    var value:Number = zoomSlider.value;
                    var delta:Number = value - lastZoomVal;
                    var transitioner:Transitioner = null;
                    var parallel:Parallel = null;
                    
                    if (tweenZoom) {
                        transitioner = new Transitioner(TWEEN_ZOOM_TIME);
                        transitioner.easing = Easing.none;
                        parallel = new Parallel();
                        parallel.duration = TWEEN_ZOOM_TIME;
                    }
                    
                    //if (Math.abs(delta) < .04) return;
                    
                    // Zoom the graph center - this is to have accurate panning/zooming
                    var deltaCenter:Object = computeZoomDeltas(_graphCenter.x, _graphCenter.y, x, y, lastZoomVal, value, "graphCenter");
                    if (!isNaN(deltaCenter['x']) && !isNaN(deltaCenter['y'])) {
                        if (_graphCenter.x < x) {
                            _graphCenter.x -= deltaCenter['x'];
                        } else {
                            _graphCenter.x += deltaCenter['x'];                     
                        }
                        if (_graphCenter.y < y) {
                            _graphCenter.y -= deltaCenter['y']; 
                        } else {
                            _graphCenter.y += deltaCenter['y'];
                        }
                    }
                    
                    // Zoom the user's dot
                    adjustForResizing(curUserDot, _graphOriginalCenter, transitioner, parallel);
                    
                    // Zoom the other dots
                    for(var m:int = 0; m<spriteNames.length; m++) {
                        var temp:Sprite = spriteObjects[spriteNames[m]];
                        adjustForResizing(temp, _graphOriginalCenter, transitioner, parallel);
                    }
					
					// Zoom the highlight box
                    if (highlightBox != null) adjustNonDotPosition(highlightBox, highlightedPoint, _graphOriginalCenter, transitioner, parallel, 30);
                    
                    hideArrowBox();
                    
                    if (tweenZoom){
                        parallel.add(transitioner);
                        
                        // Add an event listener to redraw the lines per step of the transition
                        if (linesShown) parallel.addEventListener(TransitionEvent.STEP, adjustLines);
                        parallel.play();
                    }
                }
                catch (e:Error) {
                    trace('zooming error: '+e.message);
                }   
                    lastZoomVal = value; */
            }
            
            /**
             * Increments the zoom slider value to zoom in
             */
            public function doZoomIncrement():void {
/*TODO:                if (zoomSlider.value != ZOOM_SLIDER_MAX) {
                    zoomSlider.value += .25;
                    doZoom();       
                }*/
            }
            
            /**
             * Decrements the zoom slider value to zoom out
             */
            public function doZoomDecrement():void {
/*TODO:                if (zoomSlider.value != ZOOM_SLIDER_MIN) {
                    zoomSlider.value -= .25;
                    doZoom();
                }*/
            }
            
            /**
             * Sets the zoom slider value to the lowest possible
             */
            private function zoomFullyOut():void {
/*TODO:                if (zoomSlider.value != 1) {
                    zoomSlider.value = 1;
                    doZoom();
                }
                centerMap(_graphCenter.x,_graphCenter.y); */
            }
            
            /**
            * Adjusts the dot locations for any change in the screen size
            */ 
            public function adjustForFullScreen():void {
                _graphOriginalCenter.x = transformXCoorToPixels(_graphMin.x + xAxisMax/2);
                _graphOriginalCenter.y = transformYCoorToPixels(_graphMin.y + yAxisMax/2);
                
                // Find the original ratio by removing padding, apply it to the new width and height, then reapply padding
                // it is a slight bit off, I think due to rounding in the pixel values
                var adjustedCenterX:Number = (_graphCenter.x-xLowerPadding)/(lastWidth - xUpperPadding  - xLowerPadding) * (flareVis.width - xUpperPadding  - xLowerPadding) + xLowerPadding;
                var adjustedCenterY:Number = (flareVis.height - yUpperPadding) - ((lastHeight - yUpperPadding) - _graphCenter.y)/(lastHeight - yUpperPadding - yLowerPadding) * (flareVis.height - yUpperPadding - yLowerPadding);
                
                _graphCenter.x = adjustedCenterX;
                _graphCenter.y = adjustedCenterY;
                
                adjustForResizing(curUserDot, _graphOriginalCenter);
                
				alignMeTxt();
                    
                for (var m:int = 0; m<spriteNames.length; m++) {
                    var temp:Sprite = spriteObjects[spriteNames[m.toString()]];
                    adjustForResizing(temp, _graphOriginalCenter);
                }

				if (highlightBox != null) adjustNonDotPosition(highlightBox, highlightedPoint, _graphOriginalCenter, null, null, 0);
				
				// Adjust the lines
				if (linesShown) adjustLines();
				
				// Adjust the center instructions
				//if (centerInstructions.visible) showCenterInstructions();

                lastWidth = flareVis.width;
                lastHeight = flareVis.height;
            }
            
            /**
            * Function that takes any sprite and adjusts the point for a change in zoom or screen size.
            * This function also takes care of any changes due to a refresh
            */ 
            private function adjustForResizing(spr:DisplayObject, center:Point, transitioner:Transitioner=null, parallel:Parallel = null):void {
                var point:Point = calculateNewPosition(spr, center);
                
                var rawX:Number = point.x;
                var rawY:Number = point.y;
                
                if (transitioner == null && parallel == null) {
                    spr.x = rawX;
                    spr.y = rawY;
                } else {
                    if (!outOfBounds(rawX, rawY, spr.name) && inContainer[spr.name]) {
                        // Check if the endpoint is in the container
                        transitioner.$(spr).x = rawX;
                        transitioner.$(spr).y = rawY;
                    } else {
                    	// If the endpoint is not in the container, we need to remove
                    	// the point at the correct time
                        var t:Tween = new Tween(spr, TWEEN_ZOOM_TIME, {x:rawX, y:rawY});
                        t.easing = Easing.none;
                        t.addEventListener(TransitionEvent.STEP, tweenZoomStep);
                        parallel.add(t);                        
                    }
                }
                
                // The transitioner takes care checking the boundaries of the dots
                //checkBounds(spr, spr.name); Removed 2011.12.06 as there's no more pan and zoom, but points may be removed if user is resizing window         
            }
            
            /**
            * Takes a dot sprite and calculates it's position given the pan and zoom settings
            */ 
            private function calculateNewPosition(spr:DisplayObject, center:Point):Point {
                var rawX:Number = transformXCoorToPixels(originalCoordinates[spr.name].x);
                var rawY:Number = transformYCoorToPixels(originalCoordinates[spr.name].y);
                
                // This adjusts the point given zoom
/*TODO:                if (zoomSlider.value != 1) {    
                    var deltaXY:Object = computeZoomDeltas(rawX, rawY, center.x, center.y, 1, zoomSlider.value, "dotResizing" + spr.name);
                    if (!isNaN(deltaXY['x']) && !isNaN(deltaXY['y'])) {
                        if (rawX < center.x) {
                            rawX -= deltaXY['x'];
                        } else {
                            rawX += deltaXY['x'];                       
                        }
                        if (rawY < center.y) {
                            rawY -= deltaXY['y'];   
                        } else {
                            rawY += deltaXY['y'];
                        }
                    } 
                }*/

				// This adjusts the point given panning
                rawX -= _graphOriginalCenter.x - _graphCenter.x;
                rawY -= _graphOriginalCenter.y - _graphCenter.y;
                
                return new Point(rawX, rawY);            	
            }
            
            /**
            * Adjusts a non point in the space (i.e. a box or any other graphic)
            * Takes a representative Sprite to follow in whatever action was taken
            * such as a zoom or fullscreen
            */ 
            private function adjustNonDotPosition(nonDot:Sprite, spr:Sprite, center:Point, transitioner:Transitioner=null, parallel:Parallel = null, offset:Number = 0):void {
            	var point:Point = calculateNewPosition(spr, center);
            	
            	// We don't check to remove the nonDot. It will be covered by the borders
            	// This will result in the box sometimes covering a dot without the dot being inside
                if (transitioner == null && parallel == null) {
                    nonDot.x = point.x - offset;
                    nonDot.y = point.y - offset;
                } else {
                    transitioner.$(nonDot).x = point.x - offset;
                    transitioner.$(nonDot).y = point.y - offset;
                }            	
            }
            
            private function tweenZoomStep(e:TransitionEvent):void {
                var spr:DisplayObject = DisplayObject(e.target.target);
                //checkBounds(spr, spr.name); Removed 2011.12.06 as there's no more pan and zoom, but points may be removed if user is resizing window
            }
            
            private function goFullScreen():void {
                stage.displayState = StageDisplayState.FULL_SCREEN;
            }
            
            /**
            * This centers the map from a current (x,y) to the center 
            */
            private function centerMap(x:Number, y:Number):void {
                panBy( _graphOriginalCenter.x - x,  _graphOriginalCenter.y - y , false);
            }

            /**
             * Sets the view to be centered on the user's dot
             */            
            private function findUser():void {
                var xPixel:Number = curUserDot.x;
                var yPixel:Number = curUserDot.y;
                centerMap(xPixel, yPixel);
                
                showArrowBoxTemporarily();
            }
            
            public function handleFirstTimeTutorialRatings(ratingsDictionary:Dictionary, value:Number):void
            {
            	if (ratingsDictionary[curCommentUserId.toString()] == null)
				{            		
            		firstTimeTutorialNumRated += 1;
    			}

        		// Save value of rating
        		ratingsDictionary[curCommentUserId.toString()] = value;
				var newScore:Number = calculateFirstTimeScoreDifference(firstTimeTutorialInsightRatings,firstTimeTutorialAgreementRatings);
				
				// IF NO_STATEMENTS, use the slider rating as the statement value, with 
				// user's id as the statement number
				if (ratingsDictionary == firstTimeTutorialAgreementRatings && Configuration.NO_STATEMENTS)
				{
					if(curCommentUserId <= 3)
						firstTimeStatements[curCommentUserId.toString()] = value;
				}
				
				// Close the comment panel if user rated on both sliders
				/*if (firstTimeTutorialInsightRatings[curCommentUserId.toString()] != null &&
					firstTimeTutorialAgreementRatings[curCommentUserId.toString()] != null)
				{
					setTimeout(hideCommentPanel, 1000);
					var spr:Sprite = spriteObjects[curCommentUserId]
					spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
					var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
					twn.easing = Easing.none;  
					twn.play();
					moveToBack(spr);
				}*/				
				
				// set a delay before score is updated        		
				/*if (firstTimeUserScore == 0 && newScore != 0)
				{
					var fadeIn:Transitioner = new Transitioner(2.5, Easing.none); // Other easing effects to be added here
					for (var i:int = 0; i < spriteNames.length; i++)
					{
						var colorAndAlpha:Dictionary = getAlphaAndColor(spriteNames[i]);
						changeColor(spriteObjects[spriteNames[i]], colorAndAlpha['color'], colorAndAlpha['alpha']);
						
						spriteObjects[spriteNames[i]].alpha = firstTimeTutorialAlpha;
						fadeIn.$(spriteObjects[spriteNames[i]]).alpha = 1; // Important to transition to 1, or else we double count alpha
					}
					
					fadeIn.play();
					
					// Change the prompt text
					setTimeout(function():void{
						firstTimeIntroPromptText.text = Configuration.INCREASE_SCORE_PROMPT_LANGUAGE;
//						first_time_reg_button.visible = true;
	//					first_time_reg_button.includeInLayout = true;
					}, 1000, 1);

				}*/
				
        		// Show the save and save status text
        		commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_DONE;
        		setTimeout(clearRatingSaveStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
				
				setTimeout(function(value:Number):void{firstTimeUserScore = value}, 1000, newScore);
				
				if(newScore >= Configuration.EXPLORE_THRESHOLD_RATINGS)
				{
					firstTimeTutorialCompleted = true;
					// Hide counter and show button only after the increment
					setTimeout(function():void{
						// Hide the score
						//firstTimeExploreCounter.visible = false;
						//firstTimeExploreCounter.includeInLayout = false;
						
						// Go straight to statements or signup
						//claimYourScore();						
						// Show next prompt
						if (!Configuration.NO_STATEMENTS)
						{
							firstTimeIntroPromptText.text = Configuration.PLACE_SEED_INTRO;
						}
						else
						{
							firstTimeIntroPromptText.text = Configuration.REGISTER_SEED_PROMPT_NO_STATEMENTS;
						}
						}, 1500);
				}
				
				// Draw the color
				// Remove the back glow 2011.08.02
				//adjustDotRadius(curCommentUserId.toString(), storedCommentScore[curCommentUserId.toString()]);
            }
			
			public function hideCurrentIdea():void {
								
				if(loggedIn)
				{
					if((storedCommentRating[curSelectedSprite.name] == -1 || storedAgreementRating[curSelectedSprite.name] == -1))
						return;
				}
				else
				{
					if (firstTimeTutorialInsightRatings[curCommentUserId.toString()] == null ||
						firstTimeTutorialAgreementRatings[curCommentUserId.toString()] == null)
						return;
				}
					
				
				if(firstTimeTutorialCompleted)
				{
					claimYourScore();
					firstTimeTutorialCompleted = false;
				}
				
				hideCommentPanel();
				var spr:Sprite = spriteObjects[curCommentUserId]
				spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
				var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
				twn.easing = Easing.none;  
				twn.play();
				moveToBack(spr);
				var oneArray:Array = new Array(curCommentUserId.toString());
				playPlusOne(Configuration.SCORE_SCALE_FACTOR);
				setTimeout(removeUsers,750,oneArray);
			}
            
            public function sendCommentRating(value:Number):void {
            					
            	// Added for first time tutorial
            	if (!this.parentApplication.isUserAuthenticated)
            	{
					this.parentApplication.log.logFirstTime(curCommentUserId,value,'insight');
            		handleFirstTimeTutorialRatings(firstTimeTutorialInsightRatings, value);	
					
					/*if ((firstTimeTutorialInsightRatings[curCommentUserId.toString()] != null &&
						firstTimeTutorialAgreementRatings[curCommentUserId.toString()] != null))
					{
						setTimeout(hideCommentPanel, 1000);
						var spr:Sprite = spriteObjects[curCommentUserId]
						spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
						var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
						twn.easing = Easing.none;  
						twn.play();
						moveToBack(spr);
						var oneArray:Array = new Array(curCommentUserId.toString());
						setTimeout(removeUsers,750,oneArray);
					}*/
					
            		return;
            	}
            	
                commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_LOADING;
                storedCommentRating[curCommentUserId.toString()] = value;
                curQueryInsightRating[curCommentUserId.toString()] = value;
				
				if ((storedCommentRating[curSelectedSprite.name] != -1 && storedAgreementRating[curSelectedSprite.name] != -1))
				{
					/*setTimeout(hideCommentPanel, 1000);
					var spr:Sprite = spriteObjects[curCommentUserId]
					spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
					var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
					twn.easing = Easing.none;  
					twn.play();
					moveToBack(spr);*/
					var count:int = 0;
					for(var m:int = 0; m<spriteNames.length; m++) {
						if (storedCommentRating[spriteNames[m]] != -1 && storedAgreementRating[spriteNames[m]] != -1)
							count = count + 1;
					}
					
					if (count == spriteNames.length)
					{
						sendGetNeverSeenComments();
					}
				}
                
                var parameters:Object = new Object();
                parameters['rating'] = value;
                
                // Set the discussion statement
                if (this.selectedDiscussionStatementId == -1) 
                	saveCommentRating.url = this.parentApplication.httpUtils.getServiceUrl("os/savecommentrating/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/");
                else
                	saveCommentRating.url = this.parentApplication.httpUtils.getServiceUrl("os/savecommentrating/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/" + this.selectedDiscussionStatementId + "/");
                
                if (Configuration.USE_ENTRY_CODES)
                	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                	
                saveCommentRating.send(parameters);
            }        

            private function handleSaveCommentRating():void {
                var decodedResult:Object = JSON.decode(saveCommentRating.lastResult.toString());
                saveCommentRating.disconnect();
                var success:Boolean = AuthenticationUtils.handleErrorsNoFields(decodedResult, this);
                
                // TODO: Better error handling
                if(AuthenticationUtils.resultIsAuthRequired(decodedResult))
                	return;
				
                if (success) {
                    commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_DONE;
                    
					/* Now that we are removing points after rating, no longer need to update the comment
                    // Get the comment again (now that it'll have a new average rating/score)
                    if (this.selectedDiscussionStatementId == -1)
                    	getComment.url = this.parentApplication.httpUtils.getServiceUrl("os/getcomment/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/");
                    else
                    	getComment.url = this.parentApplication.httpUtils.getServiceUrl("os/getcomment/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/" + this.selectedDiscussionStatementId + "/");
                    
                    var parameters:Object = new Object();
                    if (Configuration.USE_ENTRY_CODES)
                    	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                    getComment.send(parameters);
                    */
					
					// initiate a comment update request
					var modified_user_id:int = decodedResult['modified_user_id'];
					if (this.selectedDiscussionStatementId == -1)
						updateComment.url = this.parentApplication.httpUtils.getServiceUrl("os/updatecomment/" + this.parentApplication.opinionSpaceId + "/" + modified_user_id + "/");
					else
						updateComment.url = this.parentApplication.httpUtils.getServiceUrl("os/updatecomment/" + this.parentApplication.opinionSpaceId + "/" + modified_user_id + "/" + this.selectedDiscussionStatementId + "/");
					
					var parameters:Object = new Object();
					if (Configuration.USE_ENTRY_CODES)
						parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
					updateComment.send(parameters);
					
                    // Wait some time before clearing the save status (i.e. the "Saved" message)
                    setTimeout(clearRatingSaveStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
                    
                    // set the score to the newly calculated amount
                    this.parentApplication.userRaterScore = decodedResult['updated_reviewer_score'];
                    reviewerScore = decodedResult['updated_reviewer_score'];
                    
                    // update the numer of fully rated responses
                    numFullyRatedResponses = decodedResult['updated_num_fully_rated'];
					
					//moving to off click
					//refreshIdea(String(modified_user_id));
					
					// hide rate prompt if user has fully rated 1 or more participants
					if(numFullyRatedResponses != 0)
					{
						removeFloatingPrompt(rateResponsePrompt);
						if(this.parentApplication.isUserAuthenticated && this.parentApplication.usernameSearch)
							removeTooltipOnUser()
						//show suggestion prompt if user has not given a suggestion
						if(this.parentApplication.numSuggestions==0)
						{
							showSuggestionPrompt();
						}
					} 
				
                }
                else {
                    commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_ERROR;
                    setTimeout(clearRatingSaveStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
                }         
            }
            
            public function sendCommentAgreement(value:Number):void {
            	
            	// Added for first time tutorial
            	if (!this.parentApplication.isUserAuthenticated)
            	{
					this.parentApplication.log.logFirstTime(curCommentUserId,value,'agreement');
            		handleFirstTimeTutorialRatings(firstTimeTutorialAgreementRatings, value);
					/*if ((firstTimeTutorialInsightRatings[curCommentUserId.toString()] != null &&
						firstTimeTutorialAgreementRatings[curCommentUserId.toString()] != null))
					{
						setTimeout(hideCommentPanel, 1000);
						var spr:Sprite = spriteObjects[curCommentUserId]
						spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
						var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
						twn.easing = Easing.none;  
						twn.play();
						moveToBack(spr);
						var oneArray:Array = new Array(curCommentUserId.toString());
						setTimeout(removeUsers,750,oneArray);
					}*/
            		return;
            	}
            	
                commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_LOADING;
                
                storedAgreementRating[curCommentUserId.toString()] = value;
                curQueryAgreeRating[curCommentUserId.toString()] = value;
				
				if ((storedCommentRating[curSelectedSprite.name] != -1 && storedAgreementRating[curSelectedSprite.name] != -1))
				{
					/*setTimeout(hideCommentPanel, 1000);
					var spr:Sprite = spriteObjects[curCommentUserId]
					spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
					var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
					twn.easing = Easing.none;  
					twn.play();
					moveToBack(spr);*/
					var count:int = 0;
					for(var m:int = 0; m<spriteNames.length; m++) {
						if (storedCommentRating[spriteNames[m]] != -1 && storedAgreementRating[spriteNames[m]] != -1)
							count = count + 1;
					}
					
					if (count == spriteNames.length)
					{
					sendGetNeverSeenComments();
					}
				}
                
                var parameters:Object = new Object();
                parameters['agreement'] = value;
                
                if (this.selectedDiscussionStatementId == -1)
                	saveCommentAgreement.url = this.parentApplication.httpUtils.getServiceUrl("os/savecommentagreement/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/");
                else
                	saveCommentAgreement.url = this.parentApplication.httpUtils.getServiceUrl("os/savecommentagreement/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/" + this.selectedDiscussionStatementId + "/");
                
                if (Configuration.USE_ENTRY_CODES)
                	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                
                saveCommentAgreement.send(parameters);            	
            }
            
            private function handleSaveCommentAgreement():void {
                var decodedResult:Object = JSON.decode(saveCommentAgreement.lastResult.toString());
				saveCommentAgreement.disconnect();
                var success:Boolean = AuthenticationUtils.handleErrorsNoFields(decodedResult, this);

				// TODO: Better error handling
                if(AuthenticationUtils.resultIsAuthRequired(decodedResult))
                	return;
                	                
                if (success) {
                    commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_DONE;
                    setTimeout(clearRatingSaveStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
                    
					/* We dont need this anymore since the comment will be removed 
                    // Get the comment again (now that it'll have a new average rating/score)
                    if (this.selectedDiscussionStatementId == -1)
                    	getComment.url = this.parentApplication.httpUtils.getServiceUrl("os/getcomment/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/");
                    else
                    	getComment.url = this.parentApplication.httpUtils.getServiceUrl("os/getcomment/" + this.parentApplication.opinionSpaceId + "/" + curCommentUserId + "/" + this.selectedDiscussionStatementId + "/");
                    
                    var parameters:Object = new Object();
                    if (Configuration.USE_ENTRY_CODES)
                    	parameters['entrycode'] = this.parentApplication.ENTRY_CODE;
                    getComment.send(parameters);
                    */
					
                    // set the score to the newly calculated amount
                    this.parentApplication.userRaterScore = decodedResult['updated_reviewer_score'];
                    reviewerScore = decodedResult['updated_reviewer_score'];
                    
                    // update the numer of fully rated responses
                    numFullyRatedResponses = decodedResult['updated_num_fully_rated'];				
					
					// refreshing the idea
					var modified_user_id:int = decodedResult['modified_user_id'];
					//moving to off click
					//refreshIdea(String(modified_user_id));
					
					// hide rate prompt if user has fully rated 1 or more participants
					if(numFullyRatedResponses != 0)
					{
						removeFloatingPrompt(rateResponsePrompt);
						if(this.parentApplication.isUserAuthenticated && this.parentApplication.usernameSearch)
							removeTooltipOnUser()
						//show suggestion prompt if user has not given a suggestion
						if(this.parentApplication.numSuggestions==0)
						{
							showSuggestionPrompt();
						}
					} 
                }
                else {
                    commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_ERROR;
                    setTimeout(clearRatingSaveStatus, Constants.CLEAR_SAVE_STATUS_TIMEOUT);
                }             	
            }
            
            private function clearRatingSaveStatus():void {
                commentModule.saveRatingStatus.visible = true;
                commentModule.saveRatingStatus.text = Constants.SAVE_COMMENT_RATING_STATUS_DEFAULT;
            }
            
            private function hideCommentRatingBar():void {
            	commentModule.commentSliderVBox.includeInLayout = false;
                commentModule.commentSlider.visible = false;
                commentModule.commentSlider.includeInLayout = false;
//               commentModule.commentTeaserText.visible = false;
  //             commentModule.commentTeaserText.includeInLayout = false;
                commentModule.commentSlider.value = (Constants.MAX_RATING - Constants.MIN_RATING) / 2;
                commentModule.commentIntroText.visible = false;
				commentModule.commentIntroText.includeInLayout = false;
                
                // Agreement Slider
                commentModule.agreementIntroText.visible = false;
				commentModule.agreementIntroText.includeInLayout = false;
                commentModule.agreementSlider.visible = false;
                commentModule.agreementSlider.includeInLayout = false;
                commentModule.agreementSlider.value = (Constants.MAX_RATING - Constants.MIN_RATING) / 2;
                commentModule.commentTeaser.visible = false;
               commentModule.commentTeaser.includeInLayout = false;
                
                commentModule.saveRatingStatus.text = "";
                commentModule.showHideAgreeText(false);
            }
            
            private function showCommentRatingBar():void {
            	commentModule.commentSliderVBox.includeInLayout = true;                                      
                commentModule.commentSlider.visible = true;
                commentModule.commentSlider.includeInLayout = true;
        //       commentModule.commentTeaserText.visible = false;
          //      commentModule.commentTeaserText.includeInLayout = false;
                commentModule.commentIntroText.visible = true;
				commentModule.commentIntroText.includeInLayout = true;
                
                // Agreement Slider
                commentModule.agreementIntroText.visible = true;
				commentModule.agreementIntroText.includeInLayout = true;
                commentModule.agreementSlider.visible = true;
                commentModule.agreementSlider.includeInLayout = true;
            	 commentModule.commentTeaser.visible = false;
              	commentModule.commentTeaser.includeInLayout = false;
                
                commentModule.showHideAgreeText(true);
            }
            
            /**
            * Adding first time tutorial, so this function name is a bit of a misnomer now
            * If a user is not logged in, they can still move the sliders, but their ratings
            * won't be saved until they register. If they don't register, their ratings are 
            * not saved.
            */ 
            private function showCommentRatingBarTeaser():void {

            	// Added for first time tutorial
            	showCommentRatingBar();
            	
				/*            	                                      
                commentModule.commentSlider.visible = false;
                commentModule.commentSlider.includeInLayout = false;
                //commentModule.commentTeaserText.visible = true;
                //commentModule.commentTeaserText.includeInLayout = true;
               commentModule.commentIntroText.visible = false;
			   commentModule.commentIntroText.includeInLayout = false;
                
                // Agreement Slider
                commentModule.agreementIntroText.visible = false;
				commentModule.agreementIntroText.includeInLayout = false;
                commentModule.agreementSlider.visible = false;
                commentModule.agreementSlider.includeInLayout = false;
               commentModule.commentTeaser.visible = true;
               commentModule.commentTeaser.includeInLayout = true;
                
                commentModule.showHideAgreeText(true);
                */
            }
            
            public function hideRatingModule():void {
                this.parentApplication.ratingModule.ratingModuleBox.visible = false;
				this.parentApplication.ratingModule.ratingModuleBox.includeInLayout = false;
                this.leftPanelUserViewer.visible = false;
                this.leftPanelUserViewer.includeInLayout = false;
                
                // hide map overlay components if they are visible
                if (mapOverlay.currentState == 'statements')
                {
                	mapOverlay.clearState();
                	
                	// Hide opinion prompt
					this.parentApplication.opinionMap.firstTimeIntroPrompt.visible = false;
					this.parentApplication.opinionMap.firstTimeIntroPrompt.includeInLayout = false;
                }
            }
            
            public function showRatingModule():void {
	        	if (!(Configuration.LENSES_ENBALED && approvedForLenses) && Configuration.RATING_MODULE_VISIBLE)
	        	{
	        		// don't show rating module if lens interface is on
					this.parentApplication.ratingModule.ratingModuleBox.visible = true;
					this.parentApplication.ratingModule.ratingModuleBox.includeInLayout = true;
		            this.leftPanelUserViewer.visible = true;
		            this.leftPanelUserViewer.includeInLayout = true;
		            hideCommentPanel(); // To make room for the rating module (if comment panel open)
					//this.parentApplication.ratingModule.switchToState('profile');
		            //hideMapLeftPanelDefault();
		            
		            // Refresh notifications
					this.parentApplication.refreshStats();
		            this.parentApplication.refreshNotifications();
	         	}
            }
            
            public function showHideRatingModule():void {
                if (this.parentApplication.ratingModule.visible == true){
                    hideRatingModule();
                } else {
                    showRatingModule();
                }               
            }
            
            /**
            * Function that initiates the HTTP service to retrieve a selected user's opinions
            */ 
            public function showSelectedUserRatings():void {
				if(userIdUsernameLocation[curSelectedSprite.name] != null)
				{
					commentModule.username = userIdUsernameLocation[curSelectedSprite.name]['username'];
					
					if(userIdUsernameLocation[curSelectedSprite.name]['location'] != null || userIdUsernameLocation[curSelectedSprite.name]['location'] != '')
						commentModule.location = userIdUsernameLocation[curSelectedSprite.name]['location'];
				}
            	/*if (commentModule.viewRatingLabel == SHOW_RATING_LABEL) {
	            	if (curSelectedSprite != curUserDot) {
	            		if (isLandmark[curSelectedSprite.name]) {
							getLandmarkRatings.url = this.parentApplication.httpUtils.getServiceUrl('os/getlandmarkratings/' + this.parentApplication.opinionSpaceId + '/') + landmarkInfo[curSelectedSprite.name]['id'] + '/';
							getLandmarkRatings.send();						
	            		} else {
							
							if(userIdUsernameLocation[curSelectedSprite.name] != null)
							{
								commentModule.username = userIdUsernameLocation[curSelectedSprite.name]['username'];
								
								if(userIdUsernameLocation[curSelectedSprite.name]['location'] != null || userIdUsernameLocation[curSelectedSprite.name]['location'] != '')
									commentModule.location = userIdUsernameLocation[curSelectedSprite.name]['location'];
							}
							
							// Populate from stored ratings
							handleGetRatings(storedRatings[curSelectedSprite.name], commentModule.userViewSliderBoxWrapper, false);
		            	}
		            	
		            	//commentModule.viewRatingLabel = RATING_LOADING_MESSAGE;
	            	}
            	} else {
            		//collapseUserRatings();
            		//collapseLandmarkRatings();
            	}*/
            }
            
            private function collapseUserRatings():void {
        	 	commentModule.userViewSliderBox.height = 0;
        	 	commentModule.commentBoxHeight = CommentModule.COMMENT_BOX_HEIGHT + commentModule.userViewSliderBox.height;
        	 	commentModule.userViewSliderBox.visible = false;
        	 	//commentModule.viewRatingLabel = SHOW_RATING_LABEL;              	
            }
            
            /**
            * Function that does the work for both getting landmark and user ratings
            * Creates the necessary flex components in actionscript (only once)
            * 
            * Updated 2011.08.17 to take an array of ratings [s1, s2, s3, s4, s5]
            * 
            */ 
            private function handleGetRatings(ratings:Object, viewSliderBox:VBox, isLandmark:Boolean):void {            	 
        	 	var tempHBox:HBox;
        	 	var tempVBoxLeft:VBox;
        	 	var tempVBoxRight:VBox;
        	 	var tempTxtBox:HBox;
        	 	var tempSliderBox:HBox;
        	 	var tempSlider:OpinionSlider;
        	 	var txt:Text;
            	
            	if (ratings.length != 0) { 
	            	 if (viewSliderBox.numChildren == 1) { // The text, containers, and sliders have already been created
	            	 	var tVBox:VBox = VBox(viewSliderBox.getChildAt(0));
	            	 	
	            	 	// Set values for each slider
	            	 	for (var j:int = 0; j < this.parentApplication.ratingModule.statements.length; j++) {
	            	 		tempSliderBox = HBox(HBox(tVBox.getChildAt(j)).getChildAt(1));
	            	 		tempSlider = OpinionSlider(tempSliderBox.getChildAt(0));
	            	 		
	            	 		if (!isLandmark) {
	            	 			
	            	 			if (ratings[statements[j].toString()] != null)
	            	 			{
	            	 				tempSlider.value = ratings[statements[j].toString()];
	            	 			}
	            	 			else
	            	 			{
	            	 				tempSlider.value = Constants.DEFAULT_SLIDER_VALUE;	            	 				
	            	 			}
	            	 			
	            	 			/*
		            	 		// Loop through the decoded statements to find a corresponding value
		            	 		// This is necessary because if a user did not move a slider, there 
		            	 		// will be no rating saved for that slider. i.e. a decoded array
		            	 		// may contain the ratings for only statements 1, 3, and 5.
		            	 		for (var x:int = 0; x < decoded.length; x++) {
		            	 			if (decoded[x][0] == statements[j]) { // The statement number matches the statement id of the slider box
		            	 				tempSlider.value = decoded[x][1];
		            	 				break;
		            	 			}
		            	 			
		            	 			if (x == (decoded.length - 1)) { // No matching rating was found
		            	 				tempSlider.value = Constants.DEFAULT_SLIDER_VALUE;
		            	 			}
		            	 		}
		            	 		*/
		            	 	} else 
		            	 	{
		            	 		//tempSlider.value = decoded[j][1];
		            	 	}
	            	 	}
	            	 } else { // We need to create the text, containers, and sliders
	            	 	var tempVBox:VBox = new VBox();// This will hold the containers for the text and sliders
	            	 	tempVBox.setStyle('verticalGap', 0);
	            	 	tempVBox.setStyle('horizontalAlign', 'right');
						 
	            	 	// Populate the short statements in the text box
	            	 	for (var i:int = 0; i < this.parentApplication.ratingModule.statements.length; i++) {		
	             	 		var tempStatementBox:HBox = new HBox();
	             	 		tempStatementBox.setStyle('horizontalGap', 0);
	             	 		tempStatementBox.setStyle('paddingLeft', 2);
	             	 		tempStatementBox.setStyle('verticalAlign', 'middle');
	             	 		 
	             	 		txt = new Text();
	             	 		txt.text = this.parentApplication.ratingModule.shortStatements[i];
	             	 		txt.toolTip = this.parentApplication.ratingModule.statements[i];
	             	 		txt.styleName = 'ratingModuleStatement';
	             	 		tempStatementBox.addChild(txt);
	             	 		tempVBox.addChildAt(tempStatementBox, i);          	 		
	             	 	}
	             	 	
	             	 	// Populate the sliders in the slider box
	             	 	for (i = 0; i < this.parentApplication.ratingModule.statements.length; i++) {
	            	 		tempSliderBox = new HBox();
	            	 		tempSlider = new OpinionSlider();
	            	 		tempSlider.enabled = false;
	            	 		tempSlider.percentWidth = 100;
	            	 		
	            	 		if (!isLandmark) {
	            	 			
	            	 			if (ratings[statements[i].toString()] != null)
	            	 			{
	            	 				tempSlider.value = ratings[statements[i].toString()];
	            	 			}
	            	 			else
	            	 			{
	            	 				tempSlider.value = Constants.DEFAULT_SLIDER_VALUE;	            	 				
	            	 			}
	            	 		} else {
	            	 			// No support for landmarks 2011.08.20
	            	 		}           	 		
	            	 		
	            	 		/*
	            	 		var leftTxt:Text = new Text();
	            	 		leftTxt.text = "Disagree";
	            	 		leftTxt.styleName = "commentRedLabelOtherUser";
	            	 		leftTxt.width = 65;
	            	 		
	            	 		var rightTxt:Text = new Text();
	            	 		rightTxt.text = "Agree";
	            	 		rightTxt.styleName = "commentGreenLabelOtherUser";
						    rightTxt.width = 50;
	            	 		*/
	            	 		
	            	 		tempSliderBox.styleName = 'sliderHBox';
	            	 		//tempSliderBox.addChild(leftTxt);
	            	 		tempSliderBox.addChild(tempSlider);
	            	 		//tempSliderBox.addChild(rightTxt);
	            	 		HBox(tempVBox.getChildAt(i)).addChild(tempSliderBox);
	             	 	}
	             	 	
	             	 	// Add a horizontal divide
	             	 	/*
						for (i = 0; i < this.parentApplication.ratingModule.statements.length; i++) {
							var box:Box = new Box();
							box.styleName = "horizontalBoxLine";
							box.height = 1;
							box.percentWidth = 100;
							if (i != this.parentApplication.ratingModule.statements.length - 1) 
								VBox(tempVBox.getChildAt(i)).addChild(box);
						}
						*/
	            	 	viewSliderBox.addChild(tempVBox);
	            	}
            	}
            }
            
            /**
            * HTTP callback function for getting landmark ratings
            */  
            private function handleGetLandmarkRatings():void {
            	var decoded:Object = JSON.decode(getLandmarkRatings.lastResult.toString());
				getLandmarkRatings.disconnect();
            	
            	// Changed functionality to take an array of ratings 2011.08.17
            	//handleGetRatings(decoded, commentModule.landmarkViewSliderBox, true);
            }
            
            /**
            * Initiates the call to get the previous comment for the selected dot
            */ 
            public function requestPreviousComment():void {
/*            	if (commentModule.previousCommentLabel == OpinionMap.GET_PREVIOUS_COMMENT_LABEL) {
            		if (curSelectedSprite != null && curSelectedSprite != curUserDot) {
	            		prevCommentUserId = curSelectedSprite.name;
	            		
	            		commentModule.previousCommentLabel = COMMENT_LOADING_MESSAGE;
	            		
	            		getPreviousComment.url = this.parentApplication.httpUtils.getServiceUrl('os/getpreviouscomment/' + this.parentApplication.opinionSpaceId + '/') + prevCommentUserId + '/';
	            		getPreviousComment.send();
            		}	
            	} else {
            		refreshCommentPanel();
            	}*/
            }
            
            /**
            * HTTP callback function for getting the previous comment
            */ 
            private function handleGetPreviousComment():void {
            	var decoded:Object = JSON.decode(getPreviousComment.lastResult.toString());
				getPreviousComment.disconnect();
            	
            	// If there is a previous question
            	if (!decoded.hasOwnProperty("error")){
					//commentModule.previousCommentLabel = OpinionMap.GET_CURRENT_COMMENT_LABEL;
					
					hideFlag();
					hideCommentRatingBar();
					
					if (decoded[1] == null || decoded[1] == '') commentModule.commentText.text = "This person has not responded to the previous discussion question.";
					else {
						//commentModule.prevQuestion.text = decoded[0];
						commentModule.commentText.text = decoded[1];
						commentModule.commentTextAreaHeight = CommentModule.COMMENT_DISPLAY_HEIGHT_WITH_PREVQ;	
					}
            	} else {
            		//commentModule.previousCommentLabel = OpinionMap.GET_PREVIOUS_COMMENT_LABEL;
            		//commentModule.previousCommentText.text = "There are no previous questions.";
            		//setTimeout(hidePreviousCommentText, 3000);		
            	}	
            }

            /**
            * Plays the big bang effect
            */ 
            public function playBigBang():void {
            	if (queryRefreshAndBang)
            	{
            		// Check to see if the animation has finished
            		// NOTE: Serialization done only for the animation. The removal of points
            		// and adding of new points isn't serialized.
					
            		//if (fadePointsOut.running)
            		//{
            			//setTimeout(playBigBang, 250);
            			//return;
            		//}
            		
            		// Turn off the flag
            		queryRefreshAndBang = false;
            	}
            	
            	// Diable the sliders during the effect
            	//this.parentApplication.ratingModule.disableSliders();
            	
            	bigBang.addEventListener(TransitionEvent.END, endBigBang);
            	bigBang.addEventListener(TransitionEvent.STEP, bigBangStep); 
            	bigBang.play();
            }
            
            /**
            * Handles any in-transition cleanup needed
            */ 
            private function bigBangStep(e:TransitionEvent):void {
            	// in case the user draws the lines during the effect
            	adjustLines();
            }
            
            /**
            * Handles any cleanup needed with the effect
            */ 
            private function endBigBang(e:TransitionEvent=null):void {
            	if (queryInProcess) // Do cleanup for query
            	{
            		// Move user dot and background to front
	                adjustDotLayers(); 
	                
	                // Set flag for query processing
	            	queryInProcess = false;					
            	} 
            	else // end refresh if it was a system refresh
            	{
            		endRefresh();
            	}
            	
            	// enable the user to use sliders
				this.parentApplication.ratingModule.enableSliders();
            }
            
            /**
            * Handles the end of the loading of the opinionMap from a refresh on the first creation 
            * 	- dislpays the demo
            * 	- displays either the rating module or the comment module depending on if there was an argument username
            */ 
			public function endRefresh():void {
            	// Show demo if it is the user's first time
            	if (userSignedUp) {
            		//displayFirstTimeInstructions = true;
            		userSignedUp = false; // reset the flag
					//mapOverlay.showCommentsPage();
            		
            		// Show prompt unless the user has already clicked on step1
            		if (!mapOverlayPrompt.visible && !mapOverlayPrompt.includeInLayout)
            		{
						if(usernameSearchFirstTime)
						{
							firstTimeIntroPrompt.visible = true;
							firstTimeIntroPrompt.includeInLayout = true;
							firstTimeIntroPromptText.text = "YOUR RATINGS FOR " +this.parentApplication.argumentUsernameSaved.toUpperCase()+ " HAVE BEEN SAVED."
						}
						else if (!Configuration.NO_STATEMENTS)
						{
	            			//firstTimeIntroPromptText.text = Configuration.FIRST_TIME_ENTER_SPACE;
	            			//mapOverlay.showOverlayNotification(Configuration.POST_REGISTRATION_TITLE, Configuration.POST_REGISTRATION_TEXT, 'postregistration');
	     				}
	            		else
	            		{
	            			// TODO: Add something here like showOverlayNotification for the first time you register
	            			// on a space with NO_STATEMENTS = true (2011.12.19)
	            			//firstTimeIntroPromptText.text = Configuration.FIRST_TIME_ENTER_SPACE_NO_STATEMENTS;
	            		}
            		} 
            	}
				else{
					if(usernameSearchFirstTime)
					{
						firstTimeIntroPrompt.visible = true;
						firstTimeIntroPrompt.includeInLayout = true;
						firstTimeIntroPromptText.text = "YOUR RATINGS FOR " +this.parentApplication.argumentUsernameSaved.toUpperCase()+ " HAVE BEEN SAVED.";
						setTimeout(hideIntroPrompt,5000);
					}
					
				}				
				
			}
			
			private function hideIntroPrompt():void{
				firstTimeIntroPrompt.visible = false;
				firstTimeIntroPrompt.includeInLayout = false;
			}
			
            /**
            * Transitions from refresh (and create) to map without any animations, including 
            * big bang 
            */ 
            public function endRefreshNoAnimation():void {
            	// end the refresh
				endRefresh();
            }            
            
            /**
            * Leaderboard click handler methods 
            */
            private function toggleAuthorControl():void {
            	if (topAuthorControl.source == CLOSED_LIST_IMAGE || topAuthorControl.source == CLOSED_LIST_IMAGE_OVER) {
					
					// if the reviewer list is shown
            		if (topReviewerControl.source != CLOSED_LIST_IMAGE) toggleReviewerControl();
            		// if rising author list is shown
            		if (risingAuthorControl.source != CLOSED_LIST_IMAGE) toggleRisingAuthorControl();
            		             		
            		// Initialize the data
            		initTopAuthorsList();
            		topAuthorControl.source = EXPANDED_LIST_IMAGE;
            		//topAuthorHeaderBox.setStyle("backgroundColor", 0xDDDDDD);
            		
            		showHideLists(true);
            	} else {
            		showHideLists(false);
            		topAuthorControl.source = CLOSED_LIST_IMAGE;
            		//topAuthorHeaderBox.setStyle("backgroundColor", 0xAAAAAA);
            	}
            }
            
            private function toggleReviewerControl():void {
            	if (topReviewerControl.source == CLOSED_LIST_IMAGE || topReviewerControl.source == CLOSED_LIST_IMAGE_OVER) {
            		
            		// if the author list is shown
            		if (topAuthorControl.source != CLOSED_LIST_IMAGE) toggleAuthorControl();
            		// if rising author list is shown
            		if (risingAuthorControl.source != CLOSED_LIST_IMAGE) toggleRisingAuthorControl();
            		
            		// Initilialize the data
            		initTopReviewerList();
            		topReviewerControl.source = EXPANDED_LIST_IMAGE;
            		//topReviewerHeaderBox.setStyle("backgroundColor", 0x2f487a);
            		
            		showHideLists(true);
            	} else {
            		showHideLists(false);            		
            		topReviewerControl.source = CLOSED_LIST_IMAGE;
            //		topReviewerHeaderBox.setStyle("backgroundColor", 0x163058);
            	}
            }
            
            private function toggleRisingAuthorControl():void {
            	if (risingAuthorControl.source == CLOSED_LIST_IMAGE || risingAuthorControl.source == CLOSED_LIST_IMAGE_OVER) {
            		
            		// if the author list is shown
            		if (topAuthorControl.source != CLOSED_LIST_IMAGE) toggleAuthorControl();
					// if the reviewer list is shown
            		if (topReviewerControl.source != CLOSED_LIST_IMAGE) toggleReviewerControl();            		
            		
            		// Initilialize the data
            		initRisingAuthorsList();
            		risingAuthorControl.source = EXPANDED_LIST_IMAGE;
            	//	risingAuthorHeaderBox.setStyle("backgroundColor", 0x2f487a);
            		
            		showHideLists(true);
            	} else {
            		showHideLists(false);            		
            		risingAuthorControl.source = CLOSED_LIST_IMAGE;
            //		risingAuthorHeaderBox.setStyle("backgroundColor", 0x163058);
            	}
            }
            
            private function listControlOver(control:Image, text:Text):void {
            	text.setStyle('color', Configuration.TEXT_OVER);
            	switch (control.source) {
            		case CLOSED_LIST_IMAGE:
            			control.source = CLOSED_LIST_IMAGE_OVER;
            			break;
            		case EXPANDED_LIST_IMAGE:
            			control.source = EXPANDED_LIST_IMAGE_OVER;
            			break;
            	}
            }
            
            private function listControlOut(control:Image, text:Text):void {
            	text.setStyle('color', Configuration.TEXT_NORMAL);
            	switch (control.source) {
            		case CLOSED_LIST_IMAGE_OVER:
            			control.source = CLOSED_LIST_IMAGE;
            			break;
            		case EXPANDED_LIST_IMAGE_OVER:
            			control.source = EXPANDED_LIST_IMAGE;
            			break;
            	}
            }
            
            private function showHideLists(isShowing:Boolean):void {
        		leftList.visible = isShowing;
        		leftList.includeInLayout = isShowing;
        		rightList.visible = isShowing;
        		rightList.includeInLayout = isShowing;            	
            }
            
            private function initTopAuthorsList():void {
            	initLeaderboardList(0);
            }   
            
            private function initTopReviewerList():void {
            	initLeaderboardList(1);
            }
            
            private function initRisingAuthorsList():void {
            	initLeaderboardList(2);
            }
            
            /**
            * Initializes the leaderboards corresponding to the data in the state variables
            */ 
            private function initLeaderboardList(state:int):void {
            	var left:ArrayCollection = new ArrayCollection();
            	var right:ArrayCollection = new ArrayCollection();
				var entry:String;
				var sourceArray:Array;
		
				// 2011.11.20 - NOTICE: Top reviewers are no longer sent. It is top authors 11-20.
				// For now we'll keep this unless there is a clear use case for the top reviewers 

				switch(state) {
					case 0:
						sourceArray = topResponses;
						break;
					case 1:
						sourceArray = topReviewers;
						break;
					case 2:
						sourceArray = risingAuthors;
						break;
				}
				
				var count:int = 0;
            	for (var i:int = 0; i < sourceArray.length; i++) {
            		if (count == 10) break;
            		
            		// We are guaranteed sanitized scores
					var scr:Number; 
					switch (state) {
						case 0:
							scr = sourceArray[i]['total_score'];
							//scr = scr * 100;
							break;
						case 1:
							scr = sourceArray[i]['rev_score'];
							break;
						case 2:
							scr = sourceArray[i]['total_score'];
							//scr = scr * 100;
							break;
					}
        			
        			// We check for null objects in case any of the top reviewers/authors have
        			// no ratings for the statements but have a response... highly unlikely in an older space
        			// To check if the user is the current user, we compare usernames
        			//if (spriteObjects[sourceArray[i]['uid']] != null || sourceArray[i]['uid'] == this.parentApplication.curUserId) {
        				
        				// Add the number the user is on the list
        				// Since top reviewers is state = 1 and we've changed the leaderboard to top ideas 1-20, the below code works
        				entry = (i+1+state*10).toString() + '. ' + String(sourceArray[i]['username']);
        				
        				if (Configuration.SHOW_SCORE && Configuration.SHOW_LEADERBOARD_SCORE) {
        					 entry += '  ' + scoreFormatter.format(scr);	
        				} 
            			
            			if (count < 5) left.addItem({label:entry, data:sourceArray[i]['uid']});
	            		else right.addItem({label:entry, data:sourceArray[i]['uid']});
	            		
	            		count += 1
        			//}
            	}
            	
            	leftList.dataProvider = left;
            	leftList.labelField = 'label';
            	
            	rightList.dataProvider = right;
            	rightList.labelField = 'label'
            }
			
            
            private function leaderBoardClick(event:ListEvent):void {
            	// If the big bang effect is playing we don't want the highlight box to show up
				var username:String = event.target.selectedItem.label;
				sendAddUserToMap(username.split(" ")[1],event.target.selectedItem.data);
				
            	if (bigBang.running || Configuration.ROLLING_LEADERBOARD) {
            		leftList.selectedIndex = -1;
            		rightList.selectedIndex = -1;
					//var username:String = event.target.selectedItem.label;
					//sendAddUserToMap(event.target.selectedItem.data);
            		return;
            	}
            	
            	var spr:Sprite;
            	if (event.target.selectedItem.data == this.parentApplication.curUserId) spr = curUserDot; 
            	else spr = spriteObjects[event.target.selectedItem.data]; 

				// Deselect the item in the other list
				if (event.target == leftList) rightList.selectedIndex = -1;
            	if (event.target == rightList) leftList.selectedIndex = -1;
            	
				processDotClick(spr);
            }
            
            
            private function filterableKeysDropDownChange():void {
            	possibleFilterValues.dataProvider = filterableKeys[filterableKeysDropDown.selectedItem];
            	if (filterableKeys[filterableKeysDropDown.selectedItem].length < 6)
            		possibleFilterValues.rowCount = filterableKeys[filterableKeysDropDown.selectedItem].length;
            	else
            		possibleFilterValues.rowCount = 5;
            		
            	//possibleFilterValues.labelField = 'label'; -> implicit, but this is what makes the {'label': Male, 'color': 0xff0000} thing work
            	possibleFilterValues.enabled = true;
            }
            
            /**
            * Sets the url of getOtherUsers and refreshOS to the corresponding discussion statement id
            */ 
            public function discussionStatementDropDownChange(i:int=-1):void {
				var disc_stmt_id:int;
				if(i == -1)
            		disc_stmt_id = discussionQuestionsDropDown.selectedItem.data;
				else
					disc_stmt_id = i;
            	selectedDiscussionStatementId = disc_stmt_id;
            	
            	getNeverSeenComments.url = this.parentApplication.httpUtils.getServiceUrl('os/neverseencomments/' + this.parentApplication.opinionSpaceId+ '/' + disc_stmt_id + '/');
            	//getOtherUsers.url = this.parentApplication.httpUtils.getServiceUrl('os/otherusers/' + this.parentApplication.opinionSpaceId+ '/' + disc_stmt_id + '/');
            	this.parentApplication.refreshOS.url = this.parentApplication.httpUtils.getServiceUrl('os/show/' + this.parentApplication.opinionSpaceId + '/' + disc_stmt_id + '/');
            	
            	// Set big bang flag on for system refresh
				if (this.parentApplication.bangOn) this.parentApplication.refreshAndBang = true;
            	
            	this.parentApplication.sendRefreshOS();
            }
            
            /**
            * Aligns the selected item on the drop down with the current discussion question (if the user has not selected a discusson question)
            * or the discussion question the user has selected
            */ 
            public function alignDiscussionStatementDropDownSelection():void {
            	if (selectedDiscussionStatementId == -1) {
	            	for (var i:int = 0; i < this.parentApplication.discussionStatementsArray.length; i++) {
						if (this.parentApplication.discussionStatementsArray[i]['is_current'] == 1)
							discussionQuestionsDropDown.selectedIndex = i;
					}
            	} else {
            		for (var j:int = 0; j < this.parentApplication.discussionStatementsArray.length; j++) {
						if (this.parentApplication.discussionStatementsArray[j]['id'] == selectedDiscussionStatementId)
							discussionQuestionsDropDown.selectedIndex = j;
					}
            	}
            }
            
            /**
            * Initializes the comboBox with the discussion statements data
            */ 
            public function initDiscussionStatementsList():void {
				var data:ArrayCollection = new ArrayCollection();
				var idx:int = -1;
				
				if (this.parentApplication.discussionStatementsArray.length == 1)
				{
					discussionStatementDropDownActive = false;
					return;
				}
				
				for (var i:int = 0; i < this.parentApplication.discussionStatementsArray.length; i++) {
					var l:String = this.parentApplication.discussionStatementsArray[i]['short'];
					var d:Number = this.parentApplication.discussionStatementsArray[i]['id'];
					data.addItem({label:l, data:d});
					
					if (this.parentApplication.discussionStatementsArray[i]['is_current'] == 1) {
						idx = i;
					}
				}

				discussionQuestionsDropDown.labelField = 'label';
				discussionQuestionsDropDown.selectedIndex = idx;
				discussionQuestionsDropDown.dataProvider = data;
            }
            
            /**
            * Various animation effects
            */ 
            private function radiationEffect(spr:Sprite, resetHalo:Boolean, repeat:Boolean):void {
                var twn:Tween = new Tween(spr, GLOW_SPEED, {alpha:0, scaleX:1.5, scaleY:1.5});
                twn.easing = Easing.none;
                
                var twn1:Tween = new Tween(spr, 0, {alpha:1});
                twn1.easing = Easing.none;
                
                var twn2:Tween = new Tween(spr, GLOW_SPEED, {alpha:0, scaleX:2, scaleY:2});
                twn2.easing = Easing.none; 
                
                var twn3:Tween = new Tween(spr, 0.1, {scaleX:.5, scaleY:.5});
                twn3.easing = Easing.none;         
                
                var twn4:Tween = new Tween(spr, GLOW_SPEED, {alpha:1, scaleX:1, scaleY:1}); 
                twn4.easing = Easing.none;
                
                var seq:Sequence;
                if (resetHalo) seq = new Sequence(twn, twn1, twn2, twn3, twn4);
                else seq = new Sequence(twn, twn1, twn2);
                
                if (repeat) seq.addEventListener(TransitionEvent.END, restartRadiation);
                seq.play();  
            }
            
            public function haloRadiation(spr:Sprite):void {
            	if (radiation) {
            		radiationEffect(spr, true, true);
            	}
            }   
            
            private function restartRadiation(e:TransitionEvent):void {
            	if (radiation) {
					var seq:Sequence = Sequence(e.target);
            		setTimeout(helpPlay, Math.random() * 8000, seq);
            		/*
        			if (numRad > 15) setTimeout(helpPlay, Math.random() * 12000, seq);
        			else { 
        				seq.play();
        				numRad+=1;
        			}*/
            	}
            }
            
            private function helpPlay(seq:Sequence):void {
            	seq.play();
            }
            
            private function highlightLowConfidencePoints():void {
            	if (refreshingOtherUsers) return;
        		radiateAndBounceEffect();
            }
	
			private function cycleHighlight(e:TransitionEvent):void {
            	if (radiation) {
        			if (!refreshingOtherUsers) radiateAndBounceEffect();
            	}				
			}
            
            private function radiateAndBounceEffect():void {
            	var idx:int = Math.random() * lowConfidenceArray.length;
            	
            	var dot:Sprite = lowConfidenceArray[idx];
            	var spr:Sprite = Sprite(dot.getChildAt(0));
            	spr.scaleX = 1;
            	spr.scaleY = 1;

				// First pulse                
                var twn:Tween = new Tween(spr, GLOW_SPEED, {alpha:1, scaleX:1.5, scaleY:1.5});
                twn.easing = Easing.none;
                var twn1:Tween = new Tween(spr, 0.1, {alpha:0});
                twn1.easing = Easing.none;
                var firstPulse:Sequence = new Sequence(twn, twn1);

				// Second pulse
                var twn2:Tween = new Tween(spr, GLOW_SPEED, {alpha:1, scaleX:2, scaleY:2});
                twn2.easing = Easing.none; 
                var twn3:Tween = new Tween(spr, GLOW_SPEED/2, {alpha:0, scaleX:2.5, scaleY:2.5});
                twn3.easing = Easing.none;
                var secondPulse:Sequence = new Sequence(twn2,twn3);
                
				// Bouncing effect
                var btwn:Tween = new Tween(dot, GLOW_SPEED/2, {scaleX:.5, scaleY:.5});
                btwn.easing = Easing.none;
                var btwn1:Tween = new Tween(dot, GLOW_SPEED/2, {scaleX:2, scaleY:2});
                btwn1.easing = Easing.none;
                var btwn2:Tween = new Tween(dot, GLOW_SPEED, {scaleX:1, scaleY:1});
                btwn2.easing = Easing.easeOutBounce;                
                var bounce:Sequence = new Sequence(btwn, btwn1, btwn2);
                var bouncing:Sequence = new Sequence(bounce,bounce);
				
				// Play secondAndRestore with glowing
				//var p:Parallel = new Parallel(secondPulse,bounce);
				
				// Final sequence
				var final_effect:Sequence = new Sequence(firstPulse, secondPulse, bounce);
				final_effect.addEventListener(TransitionEvent.END, cycleHighlight);
				final_effect.play();            	
            }
            
            private function pointBounceEffect(dot:Sprite):void {
                var btwn:Tween = new Tween(dot, GLOW_SPEED/2, {scaleX:.5, scaleY:.5});
                btwn.easing = Easing.none;
                var btwn1:Tween = new Tween(dot, GLOW_SPEED/2, {scaleX:2, scaleY:2});
                btwn1.easing = Easing.none;
                var btwn2:Tween = new Tween(dot, GLOW_SPEED, {scaleX:1, scaleY:1});
                btwn2.easing = Easing.easeOutBounce;                
                var bounce:Sequence = new Sequence(btwn, btwn1, btwn2);
                var bouncing:Sequence = new Sequence(bounce,bounce);
                
				bouncing.play();         	
            }
            
            private function glimmerEffect(spr:Sprite):void {
                var twn:Tween = new Tween(spr, GLOW_SPEED/2, {alpha:1});
                twn.easing = Easing.none;
                var twn1:Tween = new Tween(spr, GLOW_SPEED*2, {alpha:1});
                twn1.easing = Easing.easeOutBounce;
                var glimmer:Sequence = new Sequence(twn, twn1);
                var tripleGlimmer:Sequence = new Sequence(glimmer,glimmer,glimmer);
                
				tripleGlimmer.play();    
            }
            
            private function radiateAndGlowEffect(spr:Sprite, dot:Sprite):void {
				// First pulse                
                var twn:Tween = new Tween(spr, GLOW_SPEED, {alpha:1, scaleX:1.5, scaleY:1.5});
                twn.easing = Easing.none;
                var twn1:Tween = new Tween(spr, 0, {alpha:0});
                twn1.easing = Easing.none;
                var firstPulse:Sequence = new Sequence(twn, twn1);

				// Second pulse
                var twn2:Tween = new Tween(spr, GLOW_SPEED, {alpha:1, scaleX:2, scaleY:2});
                twn2.easing = Easing.none; 
                var twn3:Tween = new Tween(spr, GLOW_SPEED/2, {alpha:0, scaleX:2.5, scaleY:2.5});
                twn3.easing = Easing.none;
                var secondPulse:Sequence = new Sequence(twn2,twn3);
                
				// Glowing effect
				var twn_p:Tween = new Tween(dot, 0.5, {alpha:1});
				twn_p.easing = Easing.none;
                var twn_g:Tween = new Tween(dot, GLOW_SPEED, {"filters[0].alphas":[0, .3, .5, .7],
                                   "filters[0].ratios":[0, 25, 50, 127],
                                   scaleX:1, scaleY:1});
	            twn_g.easing = Easing.none;
	            var twn_g1:Tween = new Tween(dot, GLOW_SPEED, {"filters[0].alphas":GRADIENT_GLOW_ALPHA,
	                                               "filters[0].ratios":GRADIENT_GLOW_RATIO,
	                                               scaleX:1, scaleY:1});
	            twn_g1.easing = Easing.none;
	            var twn_p1:Tween = new Tween(dot, 0.5, {alpha:Configuration.OTHER_DOT_ALPHA});
	            twn_p1.easing = Easing.none;
	            var glow:Sequence = new Sequence(twn_p, twn_g, twn_g1, twn_p1);
				
				// Play secondAndRestore with glowing
				var p:Parallel = new Parallel(secondPulse,glow);
				
				// Final sequence
				var final_effect:Sequence = new Sequence(firstPulse, p);
				final_effect.play();
            }
            
            /**
            * Adjusts the meTxt's location so it is next to the curUser's point
            */ 
            private function alignMeTxt():void {
            	
            	if (!this.parentApplication.isUserAuthenticated)
            	{
            		if (fakeUserDot != null)
            		{
	            		// Align you arrow
		            	meTxt.x = fakeUserDot.x - meTxt.width - 30;
		            	meTxt.y = fakeUserDot.y - meTxt.height/2;
	            	}
            	} else
            	{
            		var containerPt:Point = new Point(curUserDot.x, curUserDot.y);
		        	var globalPt:Point = container.localToGlobal(containerPt);
		        	var plotPt:Point = meTxtBox.globalToLocal(globalPt);
		        	meTxt.x = plotPt.x - meTxt.width - 30;
		        	meTxt.y = plotPt.y - meTxt.height/2;	
            	}
            	            
            }
            
            /**
            * Toggles the visiblity of the response statistics menu
            */ 
            private function toggleResponseStats():void {
            //	if (responseStats.visible) responseStats.visible = false;
            //	else responseStats.visible = true;
            }
            
            /**
            * Hides the response stats box
            */ 
            private function hideResponseStats():void {
            	//responseStats.visible = false;
            }
            
            
            /**
            * Below are functions that draw lines to the users who have rated you - currently unused  
            */
             
            /**
            * Draws lines to the users that have rated you - button button currently unused
            */ 
            private function linkResponseRaters():void {
            	if (!linesShown) {
	            	for (var i:int = 0; i<curUserRatedByUids.length; i++) {
	            		if (spriteObjects[curUserRatedByUids[i].toString()] == null) continue; // if the rater has ratings stored, if not then there is no sprite object
	            		var spr:Sprite = createLine(curUserDot, spriteObjects[curUserRatedByUids[i].toString()], curUserDot.name+curUserRatedByUids[i].toString()+'line', 2, .5, Configuration.USER_DOT_COLOR);
	            		container.addChild(spr);
	            		linesDict[curUserRatedByUids[i]] = spr;
	            	}
	            	for (var j:int = 0; j<curUserRatedByUids.length; j++) {
	            		if (spriteObjects[curUserRatedByUids[j].toString()] == null) continue; // if the rater has ratings stored, if not then there is no sprite object
	            		moveDotToFront(spriteObjects[curUserRatedByUids[j].toString()]);
	            	}
	            	moveDotToFront(curUserDot);
	            	//linesButton.label = Configuration.HIDE_RATERS_BUTTON;
	            	linesShown = true;
	            }
				else {
					removeLines();
					//linesButton.label = Configuration.SHOW_RATERS_BUTTON;
					linesShown = false;
				}				
            }
            
            /**
            * Adjusts the lines for a pan or zoom 
            */ 
            private function adjustLines(e:TransitionEvent = null):void {
            	for (var id:Object in linesDict) {
					var line:Sprite = linesDict[id];
					redrawLine(line, curUserDot, spriteObjects[id], 2, .5, Configuration.USER_DOT_COLOR);
            	}            	
            }
            
            /**
            * Removes the lines from the display
            */ 
            private function removeLines():void {
            	if (linesShown) {
					for (var id:Object in linesDict) {
						container.removeChild(linesDict[id]);
					}            	
					linesDict = new Dictionary();	
            	}
            }
            
            /**
            * Highlights the text on mouse over
            */ 
            private function highlightText(txt:Text):void {
            	txt.setStyle('color', 0x3555a5);
            }
            
            /**
            * Restores the original text color. Assumes black.
            */ 
            private function restoreTextColor(txt:Text):void {
            	txt.setStyle('color', 0xffffff);
            }
            
            private function highlightAuthorText():void {
            	//highlightText(authorScoreText);
            	//highlightText(authorScoreNumber);
            }
            
            private function restoreAuthorText():void {
            	//restoreTextColor(authorScoreText);
            	//restoreTextColor(authorScoreNumber);
            }
            
            /**
            * Displays the box for the Opinion Space Demo
            */ 
            public function showCenterInstructions():void {
            	adjustCenterInstructions(curUserDot);
				centerInstructions.visible = true;					
            }
            
            public function hideCenterInstructions():void {
            	centerInstructions.visible = false;
            }
            
            /**
            * Moves the center instructions to avoid covering the argument sprite
            */ 
            public function adjustCenterInstructions(spr:Sprite):void {
            	if (spr.y < _graphOriginalCenter.y) centerInstructions.y = flareVis.height - 125;
				else centerInstructions.y = 25;
				centerInstructions.x = flareVis.width * .475;
            }            
            
            private function displayWelcomeInfo():void {
            	/*if (mainWelcomeBox.visible) {
            		mainWelcomeBox.visible = false;
            		mainWelcomeBox.includeInLayout = false;
	            	secondaryWelcomeBox.visible = true;
	            	secondaryWelcomeBox.includeInLayout = true;
	            	
	            	panBy(0, 100, false);
	            } else {
            		mainWelcomeBox.visible = true;
            		mainWelcomeBox.includeInLayout = true;
	            	secondaryWelcomeBox.visible = false;
	            	secondaryWelcomeBox.includeInLayout = false;
	            	
	            	panBy(0, -100, false);
	            }*/
            }
            
            private function storeAgreement(arr:Array):void {
            	for (var i:int = 0; i < arr.length; i++) {
            		storedAgreementRating[arr[i][0]] = arr[i][1];
            	}
            }
            
            /**
            * Redraws the arcs
            */ 
            public function refreshArcs():void {
            	removeArcs();
            	redrawArcs();
            }
            
            
            /**
            * Removes the currently drawn arcs from the mapMask
            */ 
            private function removeArcs():void {
            	for (var i:int = 0; i < mapMask.rawChildren.numChildren; i++) 
            		Sprite(mapMask.rawChildren.getChildAt(i)).graphics.clear();
            }
            
            /**
            * Doesn't work completely
            */ 
            private function redrawArcs():void {
     			var blur:BlurFilter = new BlurFilter();
     			blur.blurX = 15;
     			blur.blurY = 0;
     			blur.quality = BitmapFilterQuality.HIGH;
     			var temp:Sprite;            	
            	for (var i:int = 0; i < mapMask.rawChildren.numChildren; i++) {
            		temp = Sprite(mapMask.rawChildren.getChildAt(i));
            		switch (i) {
            			case 0:
			            	temp.graphics.lineStyle(1, 0x163058, 1);
			            	temp.graphics.beginFill(0x163058, 1);
			            	temp.graphics.moveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
			            	temp.graphics.curveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET - Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, plotCanvas.height);
			            	temp.graphics.lineTo(0 , plotCanvas.height);
			            	temp.graphics.lineTo(0, 0);
			            	temp.graphics.lineTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
			            	temp.graphics.endFill();
			            	temp.x = Constants.ARC_MASK_OFFSET;
			            	temp.filters = [blur];
			            case 1:
				            temp.graphics.lineStyle(1, 0x163058, 1);
			            	temp.graphics.beginFill(0x163058, 1);
			            	temp.graphics.moveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
			            	temp.graphics.curveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET - Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, plotCanvas.height);
			            	temp.graphics.lineTo(0, plotCanvas.height);
			            	temp.graphics.lineTo(0, 0);
			            	temp.graphics.lineTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
			            	temp.graphics.endFill();  
			            case 2:
			            	temp.graphics.lineStyle(1, 0x163058, 1);
			            	temp.graphics.beginFill(0x163058, 1);
			            	temp.graphics.moveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
			            	temp.graphics.curveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET + Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width - Constants.ARC_RIGHT_OFFSET, plotCanvas.height);
			            	temp.graphics.lineTo(plotCanvas.width, plotCanvas.height);
			            	temp.graphics.lineTo(plotCanvas.width, 0);
			            	temp.graphics.lineTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
			            	temp.graphics.endFill();
			            	temp.filters = [blur];
			            case 3:
							temp.graphics.lineStyle(1, 0x163058, 1);
			            	temp.graphics.beginFill(0x163058, 1);
			            	temp.graphics.moveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
			            	temp.graphics.curveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET + Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width - Constants.ARC_RIGHT_OFFSET, plotCanvas.height);
			            	temp.graphics.lineTo(plotCanvas.width, plotCanvas.height);
			            	temp.graphics.lineTo(plotCanvas.width, 0);
			            	temp.graphics.lineTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
			            	temp.graphics.endFill();
			            	temp.x = Constants.ARC_MASK_OFFSET;
            		}
            	}
            }
            
            /**
            * Draws the arcs for the viewfinder and adds them to mapMask
            */ 
            private function createArcs():void {
            	// Left blur portion
            	var left_arc_blur:Sprite = new Sprite();
            	left_arc_blur.graphics.lineStyle(1, 0x163058, 1);
            	left_arc_blur.graphics.beginFill(0x163058, 1);
            	left_arc_blur.graphics.moveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
            	left_arc_blur.graphics.curveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET - Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, plotCanvas.height);
            	left_arc_blur.graphics.lineTo(0 , plotCanvas.height);
            	left_arc_blur.graphics.lineTo(0, 0);
            	left_arc_blur.graphics.lineTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
            	left_arc_blur.graphics.endFill();
            	left_arc_blur.x = Constants.ARC_MASK_OFFSET;
            	
            	// Left mask portion
            	var left_arc_mask:Sprite = new Sprite();
            	left_arc_mask.graphics.lineStyle(1, 0x163058, 1);
            	left_arc_mask.graphics.beginFill(0x163058, 1);
            	left_arc_mask.graphics.moveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
            	left_arc_mask.graphics.curveTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET - Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, plotCanvas.height);
            	left_arc_mask.graphics.lineTo(0, plotCanvas.height);
            	left_arc_mask.graphics.lineTo(0, 0);
            	left_arc_mask.graphics.lineTo(plotCanvas.width * .2 + Constants.ARC_LEFT_OFFSET, 0);
            	left_arc_mask.graphics.endFill();
            	      
            	// Right blur portion
				var right_arc_blur:Sprite = new Sprite();
            	right_arc_blur.graphics.lineStyle(1, 0x163058, 1);
            	right_arc_blur.graphics.beginFill(0x163058, 1);
            	right_arc_blur.graphics.moveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
            	right_arc_blur.graphics.curveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET + Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width - Constants.ARC_RIGHT_OFFSET, plotCanvas.height);
            	right_arc_blur.graphics.lineTo(plotCanvas.width, plotCanvas.height);
            	right_arc_blur.graphics.lineTo(plotCanvas.width, 0);
            	right_arc_blur.graphics.lineTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
            	right_arc_blur.graphics.endFill();
            	
            	// Right mask portion
				var right_arc_mask:Sprite = new Sprite();
            	right_arc_mask.graphics.lineStyle(1, 0x163058, 1);
            	right_arc_mask.graphics.beginFill(0x163058, 1);
            	right_arc_mask.graphics.moveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
            	right_arc_mask.graphics.curveTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET + Constants.ARC_CURVE_OFFSET, plotCanvas.height/2, plotCanvas.width - Constants.ARC_RIGHT_OFFSET, plotCanvas.height);
            	right_arc_mask.graphics.lineTo(plotCanvas.width, plotCanvas.height);
            	right_arc_mask.graphics.lineTo(plotCanvas.width, 0);
            	right_arc_mask.graphics.lineTo(plotCanvas.width - Constants.ARC_RIGHT_OFFSET, 0);
            	right_arc_mask.graphics.endFill();
            	right_arc_mask.x = Constants.ARC_MASK_OFFSET;				            	
     			
     			// Blurs
     			var blur:BlurFilter = new BlurFilter();
     			blur.blurX = 15;
     			blur.blurY = 0;
     			blur.quality = BitmapFilterQuality.HIGH;
     			
     			right_arc_blur.filters = [blur];
     			left_arc_blur.filters = [blur];
                            	
            	mapMask.rawChildren.addChild(left_arc_blur);
            	mapMask.rawChildren.addChild(left_arc_mask);
            	mapMask.rawChildren.addChild(right_arc_blur);
            	mapMask.rawChildren.addChild(right_arc_mask);
            }
            
            /**
            * Writes the loggedout view welcome text on the map
            */ 
            private function writeWelcomeText():void {
            	// Welcome to Opinion Space 2.0 Text
                //var helvetica:Font = new Helvetica();
                var txtFormat:TextFormat = new TextFormat();
                txtFormat.color = Configuration.WELCOME_TEXT_COLOR;
                //txtFormat.font = helvetica.fontName;
				txtFormat.size = 17;
                welcomeTxt = new TextField();
                welcomeTxt.text = Configuration.WELCOME_TEXT_INTRODUCTION;
                welcomeTxt.embedFonts = true;               
     			welcomeTxt.setTextFormat(txtFormat);
     			welcomeTxt.width = Configuration.WELCOME_TEXT_WIDTH;
     			welcomeTxt.x = this.mapLeftPanel.x + this.mapLeftPanel.width/2 - welcomeTxt.width/2;
     			welcomeTxt.y = this.mapLeftPanel.y + Configuration.WELCOME_TEXT_OFFSET_Y;
     			welcomeTxt.height = 50;
     			welcomeTxt.visible = !this.parentApplication.isUserAuthenticated; // required since on initState, this var is null 
     			
     			plotCanvas.rawChildren.addChild(welcomeTxt); 
            }
            
            /**
            * Opinion Space Demo methods
            * 
            *   opinionSpaceDemoNext controls the state of the demo
            * 
            * 	opinionSpaceDemo1: Shows the user's point
            * 			""		2: Moves the user's sliders
            * 			""	3 & 4: Shows a user how to rate another user (chooses the #1 top author)
            * 			""		5: Shows user the feedback option
            */ 
            private function opinionSpaceDemoNext():void {
            	switch (demoState) {
            		case 1:
            			opinionSpaceDemo2();
            			break;
            		case 2:
            			opinionSpaceDemo3();
            			break;
            		case 3:
            			opinionSpaceDemo4();
            			break;
            		case 4:
            			opinionSpaceDemo5();
            			break;
            		case 5:
            			opinionSpaceDemoEnd();
            			break;
            		default:
            			break;
            	}
            }
            
            private function opinionSpaceDemo1():void {
            	if (DEMO_PLAYING) return;

				DEMO_PLAYING = true;
				//this.parentApplication.log.log(Log.INFO, this.parentApplication.opinionSpaceId, "DEMO_PLAYED");
				
				// Initialize the demo state
				demoState = 1;
				
            	// Show the current user's point and meTxt
            	processDotClick(curUserDot);
            	showArrowBoxTemporarily();
            	
            	// Write the text describing the user's point
            	demoText.text = "The bright blue point represents your position in the space...";
            	//showCenterInstructions();
            }
            
            private function opinionSpaceDemo2():void {
            	// In case the meTxt is still shown
            	hideArrowBox();
            	
            	// In case the user has clicked on the map
            	processDotClick(curUserDot);
            	
            	// Set demo state
            	demoState = 2;
            	
            	// move the arrow
            	adjustDemoArrow();
            	ANIMATION_PLAYING = true; // Disable the next button so the user can't rush through the demo
            	
            	demoText.visible = false;
            	demoText.text = "You can change your opinion on the initial 5 statements by moving the sliders. Your position will update in real time...";
            	demoText.visible = true;
	            
	            // Allow the user some time to read the slider text
				setTimeout(opinionSpaceDemoMoveSliders, 1000);
            }
            
            private function opinionSpaceDemoMoveSliders():void {
            	var originalSliderValue:Number = this.parentApplication.ratingModule.sliders[2].value;
            	
            	// Demonstrate moving the user's sliders to 1, to 0, and then back to the original value
            	var sliderTween1:Tween = new Tween(this.parentApplication.ratingModule.sliders[2], SLIDER_TWEEN_DURATION, {value: 1});
                sliderTween1.easing = Easing.none;
            	
            	var sliderTween2:Tween = new Tween(this.parentApplication.ratingModule.sliders[2], SLIDER_TWEEN_DURATION, {value: 0});
                sliderTween2.easing = Easing.none;
                
                var sliderTween3:Tween = new Tween(this.parentApplication.ratingModule.sliders[2], SLIDER_TWEEN_DURATION, {value: originalSliderValue});
                sliderTween3.easing = Easing.none;
            	
            	var sliderTweenSeq:Sequence = new Sequence(sliderTween1, sliderTween2, sliderTween3);
            	sliderTweenSeq.addEventListener(TransitionEvent.END, endDemoAnimation);
            	sliderTweenSeq.play();
            }
            
            private function opinionSpaceDemo3(e:Event=null):void {
            	// Set demo state
            	demoState = 3;
            	
            	demoText.visible = false;
	            demoText.text = "You can read and rate the responses of others by clicking on the points in the space...";
	            demoText.visible = true;
            }
            
            private function opinionSpaceDemo4():void {
            	// Set demo state
            	demoState = 4;
            	
            	// move the arrow
            	adjustDemoArrow();
            	ANIMATION_PLAYING = true; // Disable the next button so the user can't rush through the demo
            	
            	// Click on the #1 top author
            	adjustCenterInstructions(spriteObjects[topResponseUids[0]]);
	            processDotClick(spriteObjects[topResponseUids[0]]);
	            
	            demoText.visible = false;
	            demoText.text = "Use the first slider to indicate how much you agree with the response and the second slider to rate the insightfulness of the response...";
	            demoText.visible = true;
	            
	            setTimeout(opinionSpaceDemoWiggleReponseSliders, 1000);
            }
            
            private function opinionSpaceDemoWiggleReponseSliders():void {
            	var originalAgreementSliderValue:Number = this.parentApplication.commentModule.agreementSlider.value;
            	var originalInsightfulnessSliderValue:Number = this.parentApplication.commentModule.commentSlider.value;
            	
            	//  Wiggle effects for the agreement slider 
            	var agreementSliderTween1:Tween = new Tween(this.parentApplication.commentModule.agreementSlider, SLIDER_WIGGLE_DURATION, {value: originalAgreementSliderValue + demoWiggleValue});
                agreementSliderTween1.easing = Easing.none;
            	
            	var agreementSliderTween2:Tween = new Tween(this.parentApplication.commentModule.agreementSlider, SLIDER_WIGGLE_DURATION, {value: originalAgreementSliderValue - demoWiggleValue});
                agreementSliderTween2.easing = Easing.none;
                
                var agreementSliderTween3:Tween = new Tween(this.parentApplication.commentModule.agreementSlider, SLIDER_WIGGLE_DURATION, {value: originalAgreementSliderValue});
                agreementSliderTween3.easing = Easing.none;
                var agreementSliderSeq:Sequence = new Sequence(agreementSliderTween1, agreementSliderTween2, agreementSliderTween3);
                
                // Wiggle effects for the insightful slider
                var insightfulSliderTween1:Tween = new Tween(this.parentApplication.commentModule.commentSlider, SLIDER_WIGGLE_DURATION, {value: originalInsightfulnessSliderValue + demoWiggleValue});
                insightfulSliderTween1.easing = Easing.none;
            	
            	var insightfulSliderTween2:Tween = new Tween(this.parentApplication.commentModule.commentSlider, SLIDER_WIGGLE_DURATION, {value: originalInsightfulnessSliderValue - demoWiggleValue});
                insightfulSliderTween2.easing = Easing.none;
                
                var insightfulSliderTween3:Tween = new Tween(this.parentApplication.commentModule.commentSlider, SLIDER_WIGGLE_DURATION, {value: originalInsightfulnessSliderValue});
                insightfulSliderTween3.easing = Easing.none;
                var insightfulSliderSeq:Sequence = new Sequence(insightfulSliderTween1, insightfulSliderTween2, insightfulSliderTween3);
                
                var wiggleSeq:Sequence = new Sequence(agreementSliderSeq, insightfulSliderSeq)
                wiggleSeq.addEventListener(TransitionEvent.END, endDemoAnimation);
                wiggleSeq.play();
            }
            
            private function opinionSpaceDemo5(e:Event=null):void {
				// Set demo state
            	demoState = 5;
            	
            	// Highlight the user's point again
            	processDotClick(curUserDot);
            	
            	demoText.visible = false;
	            demoText.text = "This concludes the demo. Thank you for trying Opinion Space! Please leave your feedback by clicking the Feedback link above.";
	            demoText.visible = true;
            }
            
            public function opinionSpaceDemoEnd():void {
            	hideCenterInstructions();
            	DEMO_PLAYING = false;
            	ANIMATION_PLAYING = false;
            	demoState = 0;
            }
			
			private function usersThatHaveRatedMeVisible():Boolean{
				
				return Configuration.ALLOW_USER_TO_SEE_RATERS && ! displayFirstTimeInstructions;
			}			
            
            private function adjustDemoArrow():void {
            	switch (demoState) {
            		case 2:
//            			demoArrowBox.x = flareVis.width * .325;
  //          			demoArrowBox.y = flareVis.height * .225;
            			break;
            		case 4:
    //        			demoArrowBox.x = flareVis.width * .325;
      //      			demoArrowBox.y = flareVis.height * .575;
            			break;
            		default:
            			break;
            	}
            }
            
            private function endDemoAnimation(e:Event = null):void {
            	ANIMATION_PLAYING = false;
            }
            
            /**
            * Filters the points based on what is selected on the possibleFilterValues drop down
            * 
            */ 
            private function filterPoints(filterOut:Boolean):void {
            	if (queryInProcess) return;
            	
            	if (possibleFilterValues.selectedIndex < 0) return; 
            	
            	var toRemoveShowOnly:Array = []
            	var toRemoveFilterOut:Array = []
            	var filterMatch:Array = []
            	
            	// Find points to remove
            	for (var j:int = 0; j < spriteNames.length; j++) 
            	{
            		// no user data for the user
            		if (userDataPairs[spriteNames[j]] == null) 
            		{
            			if (spriteObjects[spriteNames[j]].visible)
            			{
            				toRemoveShowOnly.push(spriteNames[j]);
            				toRemoveFilterOut.push(spriteNames[j]);
            			}
            			
            			continue;
            		}
            		
            		// no field for current filter
            		if (userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem] == null)
            		{
            			if (spriteObjects[spriteNames[j]].visible)
            			{
            				toRemoveShowOnly.push(spriteNames[j]);
            				toRemoveFilterOut.push(spriteNames[j]);
            			}
		        		
		        		continue;
            		}
            		
            		// iterate through selected items to look for a match
            		var match:Boolean = false;
            		for (var i:int = 0; i<possibleFilterValues.selectedItems.length; i++)
            		{
	            		if (userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem] == possibleFilterValues.selectedItems[i])
	            		{
							match = true;
							break;
	            		}
            		}
            		
            		if (spriteObjects[spriteNames[j]].visible)
            		{
            			if (match)
            				toRemoveFilterOut.push(spriteNames[j]); // filterout removes those points that match the query
            			else
            				toRemoveShowOnly.push(spriteNames[j]); // showonly removes points that don't match
            		}
        						
            		// color fields accordingly code
            		/*
            		for(var index:String in filterableKeys[filterableKeysDropDown.selectedItem])
            		{
            			try 
            			{
            				
							if (userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem] == filterableKeys[filterableKeysDropDown.selectedItem][index]['label'])
	            			{
	            				 var colorNamePair:Object = new Object();
	            				 colorNamePair['color'] = filterableKeys[filterableKeysDropDown.selectedItem][index]['color'];
	            				 colorNamePair['name'] = spriteNames[j];
	            				 filterMatch.push(colorNamePair);
	            			}
	            			
						} catch(e:Error) {continue;}
            		}
            		*/
            	}
				
				// remove points 
				var pointsToRemove:Array;
				var type:String;
				if (filterOut) 
				{
					pointsToRemove = toRemoveFilterOut;
					type = "Filtered out";
				} else
				{ 
					pointsToRemove = toRemoveShowOnly;
					type = "Showing only";
				}
				
				// hide them
				for (var l:int=0; l<pointsToRemove.length; l++)
				{
					spriteObjects[pointsToRemove[l]].visible = false;
				}
				
				// remove the highlight box in case
				hideHighlightBox();
				
				// Add to history
				if (lensesHistoryIdx != lensesPointHistory.length - 1)
				{
					// make a copy up to the current state
					var tempPoints:Array = new Array();
					var tempSummary:VBox = new VBox();
					var tempFieldHist:Array = new Array();
					
					for (var q:int=0; q<lensesHistoryIdx+1; q++)
					{
						tempPoints.push(lensesPointHistory[q]);
						tempSummary.addChild(summaryNotesBox.getChildAt(q));
						tempFieldHist.push(lensesFieldHistory[q]);
					}
					
					// reassign
					lensesPointHistory = tempPoints;
					
					filterSummaryBox.removeChild(summaryNotesBox);
					summaryNotesBox = tempSummary;
					summaryNotesBox.percentWidth = 100;
					//summaryNotesBox.maxHeight = 150;
					filterSummaryBox.addChild(summaryNotesBox);
					
					lensesFieldHistory = tempFieldHist;
				}
				
				// add to front of history
				lensesPointHistory.push(pointsToRemove);
				lensesHistoryIdx = lensesPointHistory.length - 1;
				
				// keep track of categories + type of query + fields used (for smarter color palettes) 
				lensesFieldHistory.push([filterableKeysDropDown.selectedItem, filterOut, possibleFilterValues.selectedItems]);
				
				// write summary
				var pointsDisplayed:int = 0;
				for (var x:int = 0; x < spriteNames.length; x++)
        		{
        			if (spriteObjects[spriteNames[x]].visible)
        				pointsDisplayed += 1;
        		}
				addToFilterSummary(type + ' ' + filterableKeysDropDown.selectedItem + ' = ' + possibleFilterValues.selectedItems + '.\n' + pointsToRemove.length + ' points removed. ' + pointsDisplayed + '/' + spriteNames.length + ' points displayed'); 
				
				/*
				// do the coloring
				for (var i:int = 0; i < filterMatch.length; i++) 
				{
					if (filterMatch[i] == highlightedPoint.name) 
						hideHighlightBox();
						
					//spriteObjects[filterOut[i]].visible = false;
					//TODO FIX COLORS
					changeColor(spriteObjects[filterMatch[i]['name']], StyleManager.getColorName(filterMatch[i]['color']), Configuration.USER_DOT_ALPHA);
					filterColorMap[filterMatch[i]['name']] = StyleManager.getColorName(filterMatch[i]['color']);
				}*/
            }
            
            private function lensesSegmentByColor():void
            {
            	if (queryInProcess) return;
            	
            	// clear any other previous coloring
            	removeColorLens();

				// identify which fields are eligible for coloring
				var viableFields:Array = filterableKeys[filterableKeysDropDown.selectedItem];
				var filterOutFields:Array = new Array();
				for (var l:int = 0; l < lensesHistoryIdx + 1; l ++)
				{
					// check for correct cateogry
					if (lensesFieldHistory[l][0] == filterableKeysDropDown.selectedItem)
					{
						if (lensesFieldHistory[l][1])
						{
							// add to filter out list
							// using "union" logic
							filterOutFields=filterOutFields.concat(lensesFieldHistory[l][2]);
						} else
						{
							// use "intersection" logic with viable fields, 
							// if a user selects to show only A + B, and then selects show only A, only A should appear
							var tmp:Array = new Array();
							for (var r:int=0; r<lensesFieldHistory[l][2].length; r++)
							{
								// Take only the items that appear in both
								if (viableFields.indexOf(lensesFieldHistory[l][2][r]) != -1)
									tmp.push(lensesFieldHistory[l][2][r]);
							}
							
							viableFields = tmp;
						}
					}
				}
				
				// remove all elements that are in filter out
				var temp:Array = new Array();
				for (var b:int = 0; b < viableFields.length; b++)
				{
					if (filterOutFields.indexOf(viableFields[b]) == -1)
						temp.push(viableFields[b]);
				}
				viableFields = temp;
				
				// Disallow color segmentation beyond 11 fields
				if (viableFields.length > 11)
				{
					Alert.show('Color segmenting only supports up to 11 distinct fields per cateogry. Please narrow the fields down by filtering out or showing only certain fields.');
					return;
				}
				
				// create color map
				var colorMap:Dictionary = new Dictionary();
				var spacing:int = Configuration.LENSES_COLOR_PALETTE.length/viableFields.length; // rounds down
				for (var p:int=0; p<viableFields.length; p++)
					colorMap[viableFields[p]] = Configuration.LENSES_COLOR_PALETTE[p*spacing]; 
            	
				
            	var toHide:Array = new Array(); // hide points w/o value 
            	for (var j:int = 0; j < spriteNames.length; j++) 
            	{
            		// no user data for the user
            		if (userDataPairs[spriteNames[j]] == null) 
            		{
            			if (spriteObjects[spriteNames[j]].visible)
            				toHide.push(spriteNames[j]);
            			
            			continue;
            		}
            		
            		// no field for current filter
            		if (userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem] == null)
            		{
            			if (spriteObjects[spriteNames[j]].visible)
            				toHide.push(spriteNames[j]);
		        		
		        		continue;
            		}
            		
            		// only need to check for visibility
					if (spriteObjects[spriteNames[j]].visible)
            		{
            			changeColor(spriteObjects[spriteNames[j]], colorMap[userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem]], Configuration.USER_DOT_ALPHA);
            			filterColorMap[spriteNames[j]] = colorMap[userDataPairs[spriteNames[j]][filterableKeysDropDown.selectedItem]];
            		}
            	}
            	
            	// write summary
            	//addToFilterSummary('Colored points given the following fields: ' + viableFields);
            	
            	// draw legend
            	for (var c:int=0; c<viableFields.length; c++)
            	{
            		var hBox:HBox = new HBox();
            		hBox.setStyle('verticalAlign', 'middle');
            		hBox.percentWidth = 100;
            		var label:Text = new Text();
            		label.percentWidth = 100;
            		label.text = viableFields[c];
            		var box:Box = new Box();
            		box.height = 10;
            		box.width = 10;
            		box.setStyle('backgroundColor', colorMap[viableFields[c]]);
            		hBox.addChild(box);
            		hBox.addChild(label);
            		if (c % 2 == 0)
            			legendLeft.addChild(hBox);
            		else
            			legendRight.addChild(hBox);
            	}
            	lensesColorLegend.visible = true;
            	lensesColorLegend.includeInLayout = true;
            }
            
            private function lensesUndo():void
            {
            	if (lensesPointHistory.length != 0 && lensesHistoryIdx >= 0)
            	{
            		var restore:Array = lensesPointHistory[lensesHistoryIdx];
            		for (var l:int=0; l<restore.length; l++)
					{
						spriteObjects[restore[l]].visible = true;
					}
					
					summaryNotesBox.getChildAt(lensesHistoryIdx).visible = false;
					Text(summaryNotesBox.getChildAt(lensesHistoryIdx)).includeInLayout = false;
					lensesHistoryIdx -= 1;
            	}
            }
            
            private function lensesRedo():void
            {
				if (lensesPointHistory.length != 0 && lensesHistoryIdx < lensesPointHistory.length - 1)
            	{
            		lensesHistoryIdx += 1;
            		
            		var hide:Array = lensesPointHistory[lensesHistoryIdx];
            		for (var l:int=0; l<hide.length; l++)
					{
						spriteObjects[hide[l]].visible = false;
					}
					
					summaryNotesBox.getChildAt(lensesHistoryIdx).visible = true;
					Text(summaryNotesBox.getChildAt(lensesHistoryIdx)).includeInLayout = true;
            	}
            }
            
            private function restorePoints():void {
            	if (queryInProcess) return;
            	
            	// clear the summary box
            	clearFilterSummaryBox();
            	
            	// show all points
            	for (var i:int = 0; i < spriteNames.length; i++)
        		{
        			spriteObjects[spriteNames[i]].visible = true;
        		}
            	
            	// remove history
            	lensesPointHistory = new Array();
            	lensesFieldHistory = new Array();
            	lensesHistoryIdx = -1;
            	
            	// remove coloring if any
            	removeColorLens();
            }
            
            private function removeColorLens():void
            {
            	// restore original color
            	for (var i:int = 0; i < spriteNames.length; i++)
        		{
        			filterColorMap[spriteNames[i]] = null;
        			changeColor(spriteObjects[spriteNames[i]], getAlphaAndColor(spriteNames[i])['color'], getAlphaAndColor(spriteNames[i])['alpha']);
        		}
            	
				// remove legend
				lensesColorLegend.visible = false;
            	lensesColorLegend.includeInLayout = false;
            	legendLeft.removeAllChildren();
            	legendRight.removeAllChildren();
            }
            
            
            private function addToFilterSummary(text:String):void {
            	if (!filterSummaryBox.visible && !filterSummaryBox.includeInLayout)
            	{
					filterSummaryBox.visible = true;
					filterSummaryBox.includeInLayout = true;
            	}
            	
            	var txt:Text = new Text();
            	txt.text = text;
            	txt.percentWidth = 100;
            	summaryNotesBox.addChild(txt);
            }
            
            private function clearFilterSummaryBox():void {
            	filterSummaryBox.visible = false;
				filterSummaryBox.includeInLayout = false;
				summaryNotesBox.removeAllChildren();
            }
            
            public function showHighlightBox():void {
				highlightBox.visible = true;
            }
            
            public function hideHighlightBox():void {
            	if (highlightBox != null) highlightBox.visible = false;
            }
            
            public function showMapLeftPanelDefault():void {
            	mapLeftPanelDefault.visible = true;
            	mapLeftPanelDefault.includeInLayout = true;
            }
            
            public function hideMapLeftPanelDefault():void {
            	mapLeftPanelDefault.visible = false;
            	mapLeftPanelDefault.includeInLayout = false;
            }
            
            public function goToLeftPanelDefault():void {
            	hidePanels();
            	showMapLeftPanelDefault();
            }
			
			private function handleFaultOrTimeout(event:FaultEvent):void
			{
				if(drawingUsers == true) //some error with get/otherusers most likeley a 500 error, in which case you fall back down to the empty screen
				{
					terminateHandleGetOtherUsers();
				}
				
				clearRatingSaveStatus(); //in case the fail is in the process of saving a rating
			}
			
			private function playPlusOne(diff:Number):void
			{
				if(!Configuration.SHOW_SCORE)
					return;
				
				if (diff != 0 && !isNaN(diff) && !plusOnePar.running) // to avoid animating in no score is changed
				{
					plusText.text = "+ " + diff.toString();
					plusText.setStyle('color','0x00730A');
					// Adjust the position of the +1 to the mouse location
					plusOneBox.x = plotCanvas.width-370; 
					plusOneBox.y = plotCanvas.height-150;
					sessionScore = sessionScore + 1;
					
					plusOneBox.visible = true;
					plusOneBox.includeInLayout = true;
					
					// Show the +1 image
					var twn_appear:Tween = new Tween(plusOneBox, 1,{alpha:1, scaleX:1.5, scaleY:1.5});
					twn_appear.easing = Easing.none;
					
					var twn_move:Tween = new Tween(plusOneBox, 2.5, {x:plotCanvas.width-370, y:20});
					
					var twn_fade:Tween = new Tween(plusOneBox, 1.3, {alpha:0, scaleX:2.5, scaleY:2.5});
					twn_fade.easing = Easing.none;
					
					var seq:Sequence = new Sequence(twn_appear, twn_fade);
					
					plusOnePar = new Parallel(twn_move, seq);
					plusOnePar.addEventListener(TransitionEvent.END, hidePlusOneBox);
					
					// Highlight the reviewer score text
					//highlightTextMomentarily(this.parentApplication.headerReviewerScoreText, Configuration.USER_DOT_COLOR, 0x00415c, 2000);
					
					if(!loggedIn)
					{
						if(firstRating)
						{
							this.parentApplication.opinionMap.transitionDemoText(Configuration.INSTRUCTIONS_3,true);
							firstRating = false;
						}
						firstTimeScore.visible = true;
					}
					
					// Play them both at once
					plusOnePar.play();
				}
			}
			
			private function hidePlusOneBox(e:TransitionEvent):void
			{
				plusOneBox.scaleX = 1;
				plusOneBox.scaleY = 1;
				plusOneBox.x = flareVis.width * .375;
				plusOneBox.visible = false;
				plusOneBox.includeInLayout = false;
			}
			
			private function highlightTextMomentarily(text:Text, color:Number, originalColor:Number, duration:Number):void
			{
				text.setStyle('color', color);
				setTimeout(resetTextColor, duration, text, originalColor);
			}
			
			private function resetTextColor(text:Text, color:Number):void
			{
				text.setStyle('color', color);
			}
			
			/**
			 * Draws a non interactable the point on the background
			 */ 
			private function drawOnBackground(x:Number, y:Number, id:int):void
			{
				/*
				var spr:Sprite = this.parentApplication.PointDrawer.drawDaisy(7 , [.35,.35], 5 + 4*Math.random(), [0xFFFF00,0xFFFFFF], [0,10]);/*createCircle(transformXCoorToPixels(x),
					transformYCoorToPixels(y),
					id.toString(),
					1, // radius
					Configuration.BACKGROUND_POINT_MAX_ALPHA * Math.random(), // alpha
					0x7fbb03, // color
					true);*/ 
				var spr:Sprite = new Sprite();
				spr.graphics.beginFill(0x303030,Configuration.BACKGROUND_POINT_MAX_ALPHA);
				spr.graphics.drawCircle(0,0,3);	
				
				backgroundContainer.addChild(spr);
				bgSpriteNames.push(spr.name);
				originalBGCoordinates[spr.name] = new Point(x, y);
				bgSpriteObjects[spr.name] = spr;
			}
			
			public function drawBackgroundPoints(ratings:Array):void
			{
				storeRatingsJSONandDraw(ratings, true);
			} 
			
			/**
			 * Get functions for first time tutorial variables
			 */ 
			public function getFirstTimeInsightRatings():Dictionary
			{
				
				return this.firstTimeTutorialInsightRatings;
			}

			public function getFirstTimeAgreeRatings():Dictionary
			{
				return this.firstTimeTutorialAgreementRatings;
			}
			
			public function resetFirstTimeTutorialVariables():void
			{
				firstTimeHighlightedPointId = -1;
				firstTimeTutorialAlpha = 0.15;
				firstTimeTutorialInsightRatings = new Dictionary();
				firstTimeTutorialAgreementRatings = new Dictionary();
				firstTimeUserScore = 0;
				firstTimeTutorialNumRated = 0;
				oldFirstTimeScore = 0;
				
				if(firstTimeTooltip != null)
				{	
					if(plotCanvas.contains(firstTimeTooltip))
						plotCanvas.removeChild(firstTimeTooltip);
					firstTimeTooltip = null;
				}
				
			//	first_time_reg_button.visible = true;
				//first_time_reg_button.includeInLayout = true;
				
				firstTimeIntroPrompt.visible = false;
				firstTimeIntroPrompt.includeInLayout = false;
				firstTimeIntroPromptText.text = Configuration.FIRST_TIME_RATING_NOTICE;
				//first_time_reg_button.visible = false;
				//first_time_reg_button.includeInLayout = false;
				mapOverlayPrompt.visible = false;
				mapOverlayPrompt.includeInLayout = false;
				
				firstTimeExploreCounter.visible = true;
				firstTimeExploreCounter.includeInLayout = true;
				claimYourSeedButton.visible = false;
				claimYourSeedButton.includeInLayout = false;
				
				//clean up on statements page
				mapOverlay.resetStatementsPageSliders();
				mapOverlay.resetStatementsPageCommentText();
				
				//clean up rating module
				this.parentApplication.ratingModule.currentPage = 0;
				this.parentApplication.ratingModule.showSliderPage(0);
				
				meTxt.visible = false;
			}
			
			public function claimYourScore():void{	
				claimYourSeedButton.visible = false;
				claimYourSeedButton.includeInLayout = false;
				
				if(Configuration.USE_ENTRY_CODES)
				{
					//firstTimeUserScore
					DisplayUtils.displayPopup(this.parentApplication, 'loginForm');
					return;
				}
				else if(this.parentApplication.numStatements == 2)
				{
					//vsBox.visible = true;
					//hsBox.visible = true;
					showFlareVisSliders();
					vslider.enabled=true;
					hslider.enabled=true;
					//join_box.visible = false;
					//join_box.includeInLayout = false;
					
					createFakeUserPoint(plotCanvas.width*.85, plotCanvas.height*.5);
				}
				else
				{
					if(!signupContinue)
						this.mapOverlay.showStatementsPage();
				}
				
				//hideCommentPanel();
				
				// Show Stage 2 prompt (prompt for the drag and drop is in dragTxt)
				if (this.parentApplication.numStatements > 2 && !Configuration.NO_STATEMENTS)
					firstTimeIntroPromptText.text = Configuration.PLACE_SEED_PROMPT;
					
				
				//first_time_reg_button.visible = false;
				//first_time_reg_button.includeInLayout = false;
				
				// hide first prompt
				//firstTimeIntroPrompt.visible = false
				//firstTimeIntroPrompt.includeInLayout = false
				
				/*mapOverlayPrompt.visible = true;
				mapOverlayPrompt.includeInLayout = true;
				mapOverlayPrompt.x = mapRightArea.width + 80;
				mapOverlayPromptText.text = Configuration.SIGNUP_NOTIFICATION;
				mapOverlayPromptSubText.text = Configuration.SIGNUP_SUB_NOTIFICATION;*/
			}
			
			private function calculateClientSideScoreDifference(authorScore:Number, reviewerScore:Number, hasFinishedStatements:Boolean, hasFinishedComment:Boolean, numFullyRatedResponses:int):Number
			{
				var newScore:Number = Configuration.calculateClientSideScore(authorScore, reviewerScore, hasFinishedStatements, hasFinishedComment, numFullyRatedResponses);
				
				if (!this.parentApplication.refreshing && !this.parentApplication.creating) {
					
					// If it's okay to play the animation  
					//playPlusOne(newScore - oldClientScore);
					
					// set a delay before score is updated
					setTimeout(function(value:Number):void{oldClientScore = value}, 1000, newScore);
				} else {
					// there's no animation before system done loading
					// just update the score
					oldClientScore = newScore;
				}
				
				return newScore;
			}
			
			private function calculateFirstTimeScoreDifference(insightRatings:Dictionary, agreementRatings:Dictionary):Number
			{
				var newScore:Number = Configuration.calculateFirstTimeScore(insightRatings, agreementRatings,usernameSearchFirstTime);
				
				if(this.parentApplication.usernameSearch && !this.parentApplication.isUserAuthenticated && newScore != oldFirstTimeScore)
				{
					//removeTooltipOnUser();
					usernameSearchFirstTime = true;
					//firstTimeIntroPrompt.visible = true;
					//firstTimeIntroPrompt.includeInLayout = true;
					//firstTimeIntroPromptText.text = "TO SAVE YOUR RATING FOR " + this.parentApplication.argumentUsernameSaved.toUpperCase() + ", SIGN IN ON THE UPPER RIGHT OR CREATE AN ACCOUNT BY FIRST RATING 2 BLOOMS USING BOTH SLIDERS IN THE RIGHT PANEL. CLICK ON ANY BLOOM TO GET STARTED.";
					return oldFirstTimeScore;
				}
				
				//Alert.show(newScore + "");
				if (!this.parentApplication.refreshing && !this.parentApplication.creating) {
					
					// If it's okay to play the animation
					//if (!claimYourSeedButton.visible && !claimYourSeedButton.includeInLayout)  
						//playPlusOne(newScore - oldFirstTimeScore);
					
					// set a delay before score is updated
					setTimeout(function(value:Number):void{oldFirstTimeScore = value}, 1000, newScore);
				} else {
					// there's no animation before system done loading
					// just update the score
					oldFirstTimeScore = newScore;
				}
				
				return newScore;
			}
			
			public function showMapNotification(text:String, timeout:int):void
			{
				mapNotificationPrompt.visible = true;
				mapNotificationPrompt.includeInLayout = true;
				mapNotificationPromptText.text = text;
				setTimeout(hideMapNotification, timeout);
			}
			
			private function hideMapNotification():void
			{
				mapNotificationPrompt.visible = false;
				mapNotificationPrompt.includeInLayout = false;
			}
			
			private function parseAndStoreRatings(ratingsDecoded:Array):void{
				
				if (ratingsDecoded.length == 0) return;
				
				for (var i:int=0; i < ratingsDecoded.length; i++){
					var entry:Array = ratingsDecoded[i];
					if (entry[0].toString() in storedRatings) {
						storedRatings[entry[0].toString()][entry[1].toString()] = entry[2];
					} else {
						storedRatings[entry[0].toString()] = new Dictionary();
						storedRatings[entry[0].toString()][entry[1].toString()] = entry[2]; 
					}
				}
			}
			
			public function populateStatementsDropdown(statementsDecoded:Array):void{
				var data:Array = new Array()
				for(var i:int = 0; i < statementsDecoded.length; i++)
					data.push(statementsDecoded[i][2]);//toString().split(",")[2]);
				stmdIdDropDown.dataProvider = data;
				setupColoringUI();
			}
			
			public function setupColoringUI():void{
				for (var c:int=0; c < Configuration.LENSES_COLOR_BY_RESPONSE_COLORS.length; c++)
				{
					var box:Box = new Box();
					box.alpha = 0.8;
					box.height = 3;
					box.alpha = 0.8;
					box.percentWidth = 100.0/(Configuration.LENSES_COLOR_BY_RESPONSE_COLORS.length);
					box.x = c*colorBar.width/(Configuration.LENSES_COLOR_BY_RESPONSE_COLORS.length)
					box.setStyle('backgroundColor', Configuration.LENSES_COLOR_BY_RESPONSE_COLORS[c]);
					colorBar.addChild(box);
				}
				var lbox1:Box = new Box();
				lbox1.id = 'leftbound';
				lbox1.height = 7;
				lbox1.width = 2;
				lbox1.x = (colorSlider.value-0.15)*boundaryBarsBox.width-3;
				lbox1.setStyle('backgroundColor', 'white');
				boundaryBarsBox.addChild(lbox1);
				var lbox2:Box = new Box();
				lbox2.id = 'rightbound';
				lbox2.height = 7;
				lbox2.width = 2;
				lbox2.x = (colorSlider.value+0.15)*boundaryBarsBox.width;
				lbox2.setStyle('backgroundColor', 'white');
				boundaryBarsBox.addChild(lbox2);
			}
			
			private function adjustBoundsBoxes():void{
				var value:Number = colorSlider.value;
				var range:Number = colorRangeSlider.value;
				var bounds:Array = boundaryBarsBox.getChildren();
				var newleftbound:Number = value - range;
				bounds[0].x = newleftbound < Constants.MIN_RATING? 0.0 : newleftbound*boundaryBarsBox.width-3 ;
				var newrightbound:Number = value + range;
				bounds[1].x = newrightbound > Constants.MAX_RATING ? boundaryBarsBox.width-3: newrightbound*boundaryBarsBox.width;
			}
						
			private function handleColorSliderChange():void{
				
				if (queryInProcess) return;
				
				var value:Number = colorSlider.value;
				var range:Number = colorRangeSlider.value;

				adjustBoundsBoxes();
				
				var selected:int = stmdIdDropDown.selectedIndex;
				var stmtid:int = parseInt(statements[selected]);
				
				for (var j:int = 0; j < spriteNames.length; j++) 
				{
					// only need to check for visibility
					if (spriteObjects[spriteNames[j]].visible)
					{
						var rating:Number = storedRatings[spriteNames[j]][stmtid.toString()];
						if(!(value-range < rating && rating < value+range))
							spriteObjects[spriteNames[j]].alpha = 0.2;
						else
							spriteObjects[spriteNames[j]].alpha = Configuration.USER_DOT_ALPHA;
					}
				}
			}
			
			private function colorPointsByResponse():void
			{
				if (queryInProcess) return;
				
				colorFocusBox.visible=true;
				colorFocusBox.includeInLayout=true;
				
				// clear any other previous coloring
				removeColorLens();
				
				//var stmtid:int = 1;
				var selected:int = stmdIdDropDown.selectedIndex;
				var stmtid:int = parseInt(statements[selected]);
				
				// create color map
				var intervals:Number = 1.0/Configuration.LENSES_COLOR_BY_RESPONSE_COLORS.length;
				
				for (var j:int = 0; j < spriteNames.length; j++) 
				{
					// only need to check for visibility
					if (spriteObjects[spriteNames[j]].visible)
					{
						var index:int = -1;
						var rating:Number = storedRatings[spriteNames[j]][stmtid.toString()];
						if (!(stmtid.toString() in storedRatings[spriteNames[j]]))
							rating = Constants.DEFAULT_SLIDER_VALUE;
						var temp:Number = 0.0
						if (rating == 0.0)
							index = 0;
						else
							while (temp < rating) {
								temp += intervals;
								index++;
							}
						changeColor(spriteObjects[spriteNames[j]], Configuration.LENSES_COLOR_BY_RESPONSE_COLORS[index], Configuration.USER_DOT_ALPHA);
					}
				}
				
				colorSlider.value = (Constants.MAX_RATING - Constants.MIN_RATING) / 2;
				colorRangeSlider.value = 0.15;
				handleColorSliderChange();
				adjustBoundsBoxes();
				// write summary
				//addToFilterSummary('Colored points given the following fields: ' + viableFields);
			}
			
			private function resetColorPoints():void{
				for (var j:int = 0; j < spriteNames.length; j++) 
				{
					// only need to check for visibility
					if (spriteObjects[spriteNames[j]].visible)
					{
							spriteObjects[spriteNames[j]].alpha = Configuration.USER_DOT_ALPHA;
					}
				}
				removeColorLens();
				colorFocusBox.visible=false;
				colorFocusBox.includeInLayout=false;
			}
			
			public function hideFlareVisSliders():void{
				vslider.visible=false;
				vsliderText.visible = false;
		//		thumbImageTop.visible = false;
	//			thumbImageBottomLeft.visible = false;
//				thumbImageBottomRight.visible = false;
				hslider.visible = false;
				hsliderText.visible = false;
				//flareVis.height = Configuration.SPACE_DIMENSIONS + Configuration.NO_SLIDER_SCALE;
				//flareVis.width = Configuration.SPACE_DIMENSIONS + Configuration.NO_SLIDER_SCALE;
			}
			
			public function showFlareVisSliders():void{
				vslider.visible=true;
				vsliderText.visible = true;
	//			thumbImageTop.visible = true;
//				thumbImageBottomLeft.visible = true;
		//		thumbImageBottomRight.visible = true;
				hslider.visible = true;
				hsliderText.visible = true;
				//flareVis.height = Configuration.SPACE_DIMENSIONS;
				//flareVis.width = Configuration.SPACE_DIMENSIONS;
			}
			
			private function handleSliderChange():void
			{
				// indicate that the seed has made it's way into the map
				placingPoint = true;
				
				// If logged in user is placing point, update their point's location
				if(loggedIn)
				{
					var tmp:Array = new Array();
					var axis:String = MathUtils.twoSliderXorY(MathUtils.compressEigenvectorsDecoded(this.parentApplication.eigenvectorsDecoded),0);
					if(axis == 'y')
					{
						tmp.push(vslider.value);
						tmp.push(hslider.value);
						this.parentApplication.ratingModule.sliders[0].value = vslider.value;
						this.parentApplication.ratingModule.sliders[1].value = hslider.value;
					}
					else
					{
						tmp.push(hslider.value);
						tmp.push(vslider.value);
						this.parentApplication.ratingModule.sliders[0].value = hslider.value;
						this.parentApplication.ratingModule.sliders[1].value = vslider.value;
					}
	
					placeUserDot(tmp,curUserDot);
					return;
				} else
				{
					updateFakePoint(hslider.value,1.0 - vslider.value);					
				}
			}
			
			public function createFakeUserPoint(x:int, y:int):void
			{
				fakeUserDot = this.parentApplication.PointDrawer.drawDisc(0x15abd7,0,0,30/7,30,true);
				fakeUserDot.x = x;
				fakeUserDot.y = y;
				fakeUserDot.name = "fakeUserDot";
				fakeUserDot.buttonMode = true;
				
				if (this.parentApplication.numStatements == 2)
					fakeUserDot.addEventListener(MouseEvent.MOUSE_DOWN, placingPointDown);
					
				fakeUserDot.visible = true; 
				
				// Create aura
				var gradientGlow:GradientGlowFilter = new GradientGlowFilter();
				gradientGlow.distance = 0;
				gradientGlow.angle = 0;
				gradientGlow.colors = [0x000000, 0xFBEC5D, 0xFBEC5D];//[0x000000, 0xeefc6b, 0xeefc6b, 0xeefc6b];
				gradientGlow.alphas = [0, 1, 1];
				gradientGlow.ratios = [0, 95, 200];
				gradientGlow.blurX = 60;
				gradientGlow.blurY = 60;
				gradientGlow.strength = 4;
				gradientGlow.quality = BitmapFilterQuality.MEDIUM;
				gradientGlow.type = BitmapFilterType.OUTER;
				
				/*
				fakeUserDot.filters = [gradientGlow];
				
				// Have bud twinkle
                var twn:Tween = new Tween(fakeUserDot, 1, {//"filters[0].alphas":[0, 1, 1],
                                   "filters[0].ratios":[0, 63, 126]
                                   //"filters[0].strength":4
                                   });
	            twn.easing = Easing.none;
	            var twn1:Tween = new Tween(fakeUserDot, 1, {//"filters[0].alphas":GRADIENT_GLOW_ALPHA,
	                                               "filters[0].ratios":[0, 95, 200]
	                                               //scaleX:1, scaleY:1
	                                               });
	            twn1.easing = Easing.none;
	            
	            var seq:Sequence = new Sequence(twn, twn1);
	            seq.addEventListener(TransitionEvent.END, function():void {seq.play();});
				
				seq.play();
				*/
				
				// drag and drop text
				if (this.parentApplication.numStatements == 2)
				{
					dragTxt = new Text();
					dragTxt.styleName = 'firstTimeIntroPromptText';
	                dragTxt.text = Configuration.DRAG_SEED_PROMPT;
	                dragTxt.width = 200;
	     			dragTxt.x = fakeUserDot.x - dragTxt.width/2;
	     			dragTxt.y = fakeUserDot.y + 30;
	     			plotCanvas.addChild(dragTxt);
    			}
				
				// Show arrow for fake point
            	//meTxt.x = fakeUserDot.x - meTxt.width - 100;
            	//meTxt.y = fakeUserDot.y - meTxt.height/2;
				//meTxt.visible = true;
				
				idToHaloRadius[fakeUserDot.name] = USER_DOT_HALO_RADIUS;
				hasHalo[fakeUserDot.name] = false;
				inContainer[fakeUserDot.name] = true;
//				isLandmark[fakeUserDot.name] = false;
				originalCoordinates[fakeUserDot.name] = new Point(hslider.value,1.0 - vslider.value);
				
				plotCanvas.rawChildren.addChild(fakeUserDot);
			}
			
			public function clearJoinObjects():void
			{
				//hideFlareVisSliders()
				done_box.visible = false;
				done_box.includeInLayout = false;
				placingPoint = false;
				removeFakePoint()
			}			
			
			public function saveRatingsAndClear():void
			{
				var axis:String = MathUtils.twoSliderXorY(MathUtils.compressEigenvectorsDecoded(this.parentApplication.eigenvectorsDecoded),0);
				if(axis == 'y')
				{
					this.parentApplication.ratingModule.sendRating(1,vslider.value);
					this.parentApplication.ratingModule.sendRating(2,hslider.value);
				}
				else
				{
					this.parentApplication.ratingModule.sendRating(2,vslider.value);
					this.parentApplication.ratingModule.sendRating(1,hslider.value);
				}
				
				hideFlareVisSliders();
				placingPoint = false;
				hasFinishedStatements = true;
				removeFakePoint();
				fakeUserDot = null;
			}
			
			private function openSignupPage():void
			{
				if(placingPoint){
					this.parentApplication.opinionMap.done_box.visible = false;
					this.parentApplication.opinionMap.done_box.includeInLayout = false;
					
					if (Configuration.NO_STATEMENTS)
						firstTimeIntroPromptText.text = Configuration.REGISTER_SEED_PROMPT_NO_STATEMENTS;
					else
						firstTimeIntroPromptText.text = Configuration.REGISTER_SEED_PROMPT;
					
					this.mapOverlay.showSignupPage();
				}
			}
			
			public function resizeFlareVis():void
			{
				if(this.parentApplication.numStatements == 2)
				{
					xLowerPadding = 15;
					xUpperPadding = 120;
					yLowerPadding = 150;
					yUpperPadding = 20;
					flareVis.height= plotCanvas.height * .825;
					flareVis.width= flareVis.height;
					flareBox.x= vsliderText.width + vslider.width;
					mouseLocalDeltaX = flareBox.x + 10;
				}
				else
				{
					xLowerPadding = 40;
					xUpperPadding = 30;
					yLowerPadding = 190;//currentTopicBox.height + 100;
					yUpperPadding = 40;
					
					if (Configuration.VERTICAL_ORIENTATION)
						flareVis.width = this.width;
					else if (Configuration.PROJECTOR_MODE)
						flareVis.width = this.width * .4;
					else
						flareVis.width = this.width * .6;
						
					flareVis.height = this.height - yUpperPadding - 50;
				}
			}
			
			public function showSuggestionPrompt():void
			{
				if(!plotCanvas.contains(leaveSuggestionPrompt) && !hasSeenSuggestionPrompt && Configuration.SUGGESTIONS_ENABLED)
				{
					if ((Configuration.SERIALIZED_OPINION_PROFILE && numFullyRatedResponses == 2) || (!Configuration.SERIALIZED_OPINION_PROFILE && numFullyRatedResponses > (Configuration.EXPLORE_THRESHOLD_RATINGS + 1)))
					{
						plotCanvas.addChild(leaveSuggestionPrompt);
						// hide the prompt until it is positioned
						leaveSuggestionPrompt.visible = false;
						setTimeout(positionSuggestionPrompt, 500);
						
						hasSeenSuggestionPrompt = true;
					}
				}
			}
			
			public function positionSuggestionPrompt():void	
			{
				leaveSuggestionPrompt.visible = true;
				var pt:Point = commentModule.iconBar.contentToGlobal(new Point(commentModule.suggestionButton.x, commentModule.suggestionButton.y));
				leaveSuggestionPrompt.x = pt.x - leaveSuggestionPrompt.width - 10;
				leaveSuggestionPrompt.y = pt.y - leaveSuggestionPrompt.height- 13;
			}
			
			public function showRatedPrompt(spr:Sprite):void
			{
				if(!plotCanvas.contains(ratedTranslucentPrompt))
				{
					if ((Configuration.SERIALIZED_OPINION_PROFILE && numFullyRatedResponses == 1) || (!Configuration.SERIALIZED_OPINION_PROFILE && numFullyRatedResponses <= (Configuration.EXPLORE_THRESHOLD_RATINGS+1)))
					{
						plotCanvas.addChild(ratedTranslucentPrompt);
						// hide the prompt until it is positioned
						ratedTranslucentPrompt.visible = false;
						setTimeout(positionRatedPrompt,500,spr);
					}
				}
			}
			
			public function positionRatedPrompt(spr:Sprite):void	
			{
				ratedTranslucentPrompt.visible = true;
				var pt:Point = container.localToGlobal(new Point(spr.x, spr.y));
				var rPt:Point = plotCanvas.globalToLocal(pt);
				ratedTranslucentPrompt.x = rPt.x - ratedTranslucentPrompt.width/2 + 3;
				ratedTranslucentPrompt.y = rPt.y - ratedTranslucentPrompt.height - 30;
			}			
			
			public function showRatingPrompt():void
			{
				if(!plotCanvas.contains(rateResponsePrompt))
				{
					plotCanvas.addChild(rateResponsePrompt);
					// hide the prompt until it is positioned
					rateResponsePrompt.visible = false;
					setTimeout(positionRatingPrompt, 500);
				}
			}
			
			public function positionRatingPrompt():void
			{
				rateResponsePrompt.visible = true;
				var pt:Point = commentModule.localToGlobal(new Point(commentModule.iconBar.x, commentModule.iconBar.y));
				var rPt:Point = plotCanvas.globalToLocal(pt);
				rateResponsePrompt.x = rPt.x - rateResponsePrompt.width - 20;
				rateResponsePrompt.y = rPt.y + 80;
			}
			
			public function showScoreExplanationBox():void
			{
				//fuck
				if(!plotCanvas.contains(scoreExplanationBox))
				{
					plotCanvas.addChild(scoreExplanationBox);
					// hide the prompt until it is positioned
					scoreExplanationBox.visible = false;
					setTimeout(positionScoreExplanationBox, 100);
					setTimeout(removeFloatingPrompt, 5000,scoreExplanationBox);
				}
			}
			
			public function positionScoreExplanationBox():void
			{
				scoreExplanationBox.visible = true;
				scoreExplanationBox.x = plotCanvas.width - scoreExplanationBox.width-200;
				scoreExplanationBox.y = 0;
			}
			
			public function removeFloatingPrompt(promptBox:Box):void
			{
				if(plotCanvas.contains(promptBox))
				{
					plotCanvas.removeChild(promptBox);
				}
			}
			
			public function createFloatingPrompt(text:String, width:int=-1):HBox
			{
				var container:HBox = new HBox();
				var promptBox:HBox = new HBox();
				var pointBox:HBox = new HBox();
				var prompt:Text = new Text();
				
				container.styleName = "instructionPrompts";
				
				if (width == -1) 				
					container.width = Configuration.FLOATING_PROMPT_WIDTH;
				else
					container.width = width;
				
				container.setStyle('verticalAlign', 'middle');
				container.setStyle("horizontalGap", 0); 
				
				var textShadow:DropShadowFilter = new DropShadowFilter();
                textShadow.color = 0x000000;
                textShadow.angle = -90;
                textShadow.distance = .5;
                textShadow.blurX = 0;
                textShadow.blurY = 0;
                textShadow.alpha = .75;
				prompt.filters = [textShadow];
				
				var buttonShadow:DropShadowFilter = new DropShadowFilter();
                buttonShadow.color = 0x000000;
                buttonShadow.angle = 135;
                buttonShadow.distance = 1.75;
                buttonShadow.blurX = 0;
                buttonShadow.blurY = 0;
                buttonShadow.alpha = .4;
                
                var innerShadow1:DropShadowFilter = createInnerShadow(0, 0xFF9900);
                var innerShadow2:DropShadowFilter = createInnerShadow(90, 0xFF9900);
                var innerShadow3:DropShadowFilter = createInnerShadow(180, 0xFF9900);
                var innerShadow4:DropShadowFilter = createInnerShadow(270, 0xFF9900);
                
				container.filters = [innerShadow1, innerShadow2, innerShadow3, innerShadow4, buttonShadow]; 				
				
				var fade:Fade = new Fade();
				fade.duration = 200;
				container.setStyle("showEffect", fade);
				
				promptBox.percentWidth = 100;
				promptBox.setStyle('textAlign', 'center');
				prompt.text = text;
				if (width = -1)
					prompt.percentWidth = 100;
				
				var point:Shape = new Shape();
				point.graphics.moveTo(0,-3);
				point.graphics.beginGradientFill("linear",[0xFF9900, 0xFF9900], [1,1], [0,255]);
				point.graphics.lineTo(7,0);
				point.graphics.lineTo(0,3);
				point.graphics.lineTo(0,0);
	
				pointBox.rawChildren.addChild(point);
				
				promptBox.addChild(prompt);
				container.addChild(promptBox);
				container.addChild(pointBox);
			
				
				return container;
			}
			
			public function createFloatingPromptTop(text:String, width:int=-1):VBox
			{
				var container:VBox = new VBox();
				var promptBox:HBox = new HBox();
				var pointBox:VBox = new VBox();
				var prompt:Text = new Text();
				
				container.styleName = "instructionPrompts";
				
				if (width == -1) 				
					container.width = Configuration.FLOATING_PROMPT_WIDTH;
				else
					container.width = width;
				
				container.setStyle('verticalAlign', 'middle');
				container.setStyle("horizontalGap", 0); 
				
				var textShadow:DropShadowFilter = new DropShadowFilter();
                textShadow.color = 0x000000;
                textShadow.angle = -90;
                textShadow.distance = .5;
                textShadow.blurX = 0;
                textShadow.blurY = 0;
                textShadow.alpha = .75;
				prompt.filters = [textShadow];
				
				var buttonShadow:DropShadowFilter = new DropShadowFilter();
                buttonShadow.color = 0x000000;
                buttonShadow.angle = 135;
                buttonShadow.distance = 1.75;
                buttonShadow.blurX = 0;
                buttonShadow.blurY = 0;
                buttonShadow.alpha = .4;
                
                var innerShadow1:DropShadowFilter = createInnerShadow(0, 0x1eb0da);
                var innerShadow2:DropShadowFilter = createInnerShadow(90, 0x1eb0da);
                var innerShadow3:DropShadowFilter = createInnerShadow(180, 0x1eb0da);
                var innerShadow4:DropShadowFilter = createInnerShadow(270, 0x1eb0da);
                
				container.filters = [innerShadow1, innerShadow2, innerShadow3, innerShadow4, buttonShadow]; 				
				
				var fade:Fade = new Fade();
				fade.duration = 200;
				container.setStyle("showEffect", fade);
				
				promptBox.percentWidth = 100;
				promptBox.setStyle('textAlign', 'center');
				prompt.text = text;
				if (width = -1)
					prompt.percentWidth = 100;
				
				var point:Shape = new Shape();
				point.graphics.moveTo(-3,0);
				point.graphics.beginGradientFill("linear",[0x36cbf6, 0x15abd7], [1,1], [0,255]);
				point.graphics.lineTo(0,7);
				point.graphics.lineTo(3,0);
				point.graphics.lineTo(0,0);
				point.x = container.width/2 - 3;
	
				pointBox.rawChildren.addChild(point);
				
				promptBox.addChild(prompt);
				container.addChild(promptBox);
				container.addChild(pointBox);
			
				
				return container;
			}
			
			private function createInnerShadow(angle:Number, color:Number):DropShadowFilter
	        {
	        	var innerShadow:DropShadowFilter = new DropShadowFilter();
	            innerShadow.inner = true;
	            innerShadow.color = color;
	            innerShadow.angle = angle;
	            innerShadow.distance = 1.25;
	            innerShadow.blurX = 0;
	            innerShadow.blurY = 0;
	            innerShadow.alpha = 1;
	                
	        	return innerShadow;
	        }
	        
	        /**
	        * Sets alpha and updates stage if appropriate
	        */ 
	        public function refreshIdea(userId:String, comment:Object=null):void
	        {
	        	var spr:Sprite;
				var numRatings:int;
	        	if (userId != "curUser")
	        	{
		        	spr = spriteObjects[userId];
					if (storedVisualVars[userId] == undefined)
					{
						return;
					}
		        	numRatings = storedVisualVars[userId][2];	
          		} else
          		{
					spr = curUserDot;
					numRatings = this.parentApplication.numUserRatedBy;          			
          		}
               /*
				// Determine what to draw
	            var ideaStages:Array = this.parentApplication.PointDrawer.ideaProgression();
	            var newSpr:Sprite;
               
                // Draw bud if # ratings < 2
                if (numRatings < Configuration.AUTHOR_RATINGS_THRESHOLDS[0])
                	newSpr = ideaStages[0];
                else if(numRatings < Configuration.AUTHOR_RATINGS_THRESHOLDS[1])
                	newSpr = ideaStages[1];
                else if(numRatings < Configuration.AUTHOR_RATINGS_THRESHOLDS[2])
                	newSpr = ideaStages[2];
                else
                	newSpr = ideaStages[3];

	        	var i:int = spr.numChildren;
	        	while(i--)
	        	{
	        		spr.removeChildAt(i);
	        	}
	        	
	        	var x:int = newSpr.numChildren;
	        	var chldrn:Array = new Array();
	        	while(x--)
	        	{
	        		var shp:Shape = Shape(newSpr.getChildAt(x));
	        		chldrn.push(shp);
	        	}
	        	
	        	var y:int=chldrn.length;
	        	while(y--)
	        		spr.addChild(chldrn[y]);
	        	*/
	        	// Set alpha
	        	if (userId != "curUser" && storedCommentRating[userId] != -1 && storedAgreementRating[userId] != -1) 
				{
                	if (Configuration.ONA_ON || (curQueryInsightRating[userId] != null && curQueryAgreeRating[userId] != null))// && !ratedIdeasQuery && !leaderboardUsersOnMap)
                	{
                		spr.removeEventListener(MouseEvent.CLICK, handleDotClick);
                		var twn:Tween = new Tween(spr, .75, {"alpha":Configuration.IDEA_RATED_ALPHA});
	            		twn.easing = Easing.none;  
                		twn.play();
                		showRatedPrompt(spr);
                		moveToBack(spr);
                	} 
                	
                	// TODO: Have smart mouse overs to avoid collisions, if you've rated the point before and it's above
                	// A point you haven't rated, don't move to top   
                }
                	
	        }
	        
	        private function drawLegend():void
	        {
	        	var arr:Array = this.parentApplication.PointDrawer.colorLegend();
				
				for (var i:int = 0; i < arr.length; i++)
				{
					var spr:Sprite = arr[i];
					spr.x = i * 15 + 20;
					legendBox.rawChildren.addChild(spr);
				}
				
				var ar:Array = this.parentApplication.PointDrawer.sizeLegend();
				for (var x:int = 0; x < ar.length; x++)
				{
					var spr:Sprite = ar[x];
					spr.x = x * 30 + 70 + arr.length*15;
					legendBox.rawChildren.addChild(spr);	
				}
	        }
	        
	        public function initLayoutBindings():void
	        {
	        	BindingUtils.bindSetter(initLayout, mapOverlayPrompt, "height");
	        	BindingUtils.bindSetter(initLayout, currentTopicContent, "height");
	        	BindingUtils.bindSetter(initLayout, scoreDisplayBox, "height");
	        	
	        }
	        
	        public function initLayout(args:Object=null):void
	        {
	        	// For Facebook, where the width is 520px
	        	if (Configuration.VERTICAL_ORIENTATION)
	        	{
	        		// Discussion question at top
		        	currentTopicContent.percentWidth = 100;
		        	currentTopicContent.x = 0;
		        	currentTopicContent.clearStyle('top');
		        	currentTopicContent.setStyle('top',0);	
		        	
		        	mapOverlayPrompt.clearStyle('top');
		        	mapOverlayPrompt.clearStyle('left');
		        	mapOverlayPrompt.setStyle('top',0);
		        	mapOverlayPrompt.setStyle('left',0);
		        	mapOverlayPrompt.percentWidth = 100;
		        	
		        	// Scores, queries, and snippet
		        	scoreDisplayBox.clearStyle('top');    
		        	scoreDisplayBox.clearStyle('right');
		        	if (!this.parentApplication.isUserAuthenticated)
						scoreDisplayBox.setStyle('top',mapOverlayPrompt.height + 5);
					else
						scoreDisplayBox.setStyle('top',currentTopicContent.height + 5);
					scoreDisplayBox.setStyle('left',10);
					scoreDisplayBox.setStyle('right',10);
					scoreDisplayBox.width = plotCanvas.width;
		        	
		        	// Container for both rating and comment module
					mapLeftPanel.percentWidth = 100;
					mapLeftPanel.clearStyle('top');
					mapLeftPanel.clearStyle('right');
					if (!this.parentApplication.isUserAuthenticated)
						mapLeftPanel.setStyle('top',mapOverlayPrompt.height + scoreDisplayBox.height + 10);
					else
						mapLeftPanel.setStyle('top',currentTopicContent.height + scoreDisplayBox.height + 10);
					mapLeftPanel.setStyle('right',0);
					mapLeftPanel.setStyle('bottom',0);	   
					
					leftPanelUserViewer.clearStyle("showEffect");
					leftPanelUserViewer.clearStyle("hideEffect");
					leftPanelUserViewer.setStyle("showEffect", statementsShow);
					leftPanelUserViewer.setStyle("hideEffect", statementsShow);
					
					leftPanelOtherUserViewer.clearStyle("showEffect");
					leftPanelOtherUserViewer.clearStyle("hideEffect");
					leftPanelOtherUserViewer.setStyle("showEffect", statementsShow);
					leftPanelOtherUserViewer.setStyle("hideEffect", statementsShow);
					
					leftPanelOtherUserViewerLoggedout.clearStyle("showEffect");
					leftPanelOtherUserViewerLoggedout.clearStyle("hideEffect");
					leftPanelOtherUserViewerLoggedout.setStyle("showEffect", statementsShow);
					leftPanelOtherUserViewerLoggedout.setStyle("hideEffect", statementsShow);
					
					legendBox.visible = Configuration.SHOW_LEGEND;
					
					// Move LOADING... text to another container 
					queryBox.addChild(loadingText);					
	        	}
	        }
			
			public function format_score(score:Number):String
			{
				var rtn:String = scoreFormatter.format(score);
				if (rtn == '0')
					return '--'
				return rtn;
			}
					
			public function removeHeaderInstructions():void
			{
				currentTopicContent.visible = false;
				currentTopicContent.includeInLayout = false;
			}
			
			public function transitionDemoText(text:String,transition:Boolean = true,timeout:Number = 0,center:Boolean = false, button:Boolean=false,buttonText:String="", fontSize:int=27):void
			{
				if(center)
				{
					currentTopicContent.percentWidth = 100;
					currentTopicBox.percentWidth = 57;
				}
				else
				{
					currentTopicContent.percentWidth = 57;
					currentTopicBox.percentWidth = 100;
				}
				
				if(text == currentTopicHeader.text)
					return;
				
				if(button)
				{
					optionalButton.visible=true;
					optionalButton.includeInLayout = true;
					optionalButton.label = buttonText;
					optionalButton.setStyle("fontSize",fontSize);
				}
				else
				{
					optionalButton.visible = false;
					optionalButton.includeInLayout = false;
				}
				
				
				currentTopicHeader.visible= false;
				currentTopicHeader.visible= true;
				currentTopicHeader.htmlText = text;	
				
				if(timeout !=0)
					setTimeout(removeHeaderInstructions,timeout);
			}
			
			public function optionalButtonCallback():void
			{
				if(optionalButton.label == "More about the Map")
					DisplayUtils.displayPopup(this.parentApplication, 'tutorial');
				else
					mapOverlay.showSignupPage();
			}
	        
        ]]>
    </mx:Script>
    
    <utils:ExtendedHTTPService id="getAllCurrentComments" method="POST" resultFormat="text" result="handleGetAllCurrentComments()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getUnratedUsers" method="POST" resultFormat="text" result="handleGetUnratedUsers()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getLeaderboardUsers" method="POST" resultFormat="text" result="handleGetLeaderboardUsers()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getRatedUsers" method="POST" resultFormat="text" result="handleGetRatedUsers()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getRatedByUsers" method="POST" resultFormat="text" result="handleGetRatedByUsers()" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="getUsersByList" method="POST" resultFormat="text" result="handleGetUsersByList()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getOtherUsers" resultFormat="text" result="handleGetOtherUsers()" fault="handleFaultOrTimeout(event)"/>
<!--    <utils:ExtendedHTTPService id="getLandmarks" resultFormat="text" result="handleGetLandmarks()" fault="handleFaultOrTimeout(event)"/>-->
    <utils:ExtendedHTTPService id="getLandmarkRatings" resultFormat="text" result="handleGetLandmarkRatings()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getComment" method="POST" url="" resultFormat="text" result="handleGetComment()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="flagComment" method="POST" url="" resultFormat="text" result="handleFlagComment()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="saveCommentRating" method="POST" url="" resultFormat="text" result="handleSaveCommentRating()" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="updateComment" url="" method="POST" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="getPreviousComment" resultFormat="text" result="handleGetPreviousComment()" fault="handleFaultOrTimeout(event)"/>
    <utils:ExtendedHTTPService id="saveCommentAgreement" method="POST" url="" resultFormat="text" result="handleSaveCommentAgreement()" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="getRatedUpdatedComments" method="POST" resultFormat="text" result="handleGetRatedUpdatedComments()" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="getNeverSeenComments" method="POST" resultFormat="text" result="handleGetNeverSeenComments()" fault="handleFaultOrTimeout(event)"/>
	<utils:ExtendedHTTPService id="addUserToMap" method="POST" resultFormat="text" result="handleAddUserToMap()" fault="handleFaultOrTimeout(event)"/>
	
    <mx:Fade id="panelFade" duration="200"/> 
	<mx:Fade id="textIn" duration="1500" alphaFrom="0.0" alphaTo="1.0"/>
    <mx:WipeDown id="wipeDown" duration="500"/>
    <mx:WipeUp id="wipeUp" duration="500"/>
	<mx:NumberFormatter id="scoreFormatter" useThousandsSeparator="true" precision="{Configuration.SCORE_PRECISION}" />  
    <mx:Zoom id="shrink" duration="100" zoomHeightTo=".9" zoomWidthTo=".9" />
    <mx:Zoom id="revert" duration="50" zoomHeightTo="1" zoomWidthTo="1" />
	
	<mx:Glow id="glowQuestion" duration="0" alphaFrom="0" alphaTo=".17" blurXFrom="0.0" blurXTo="12.0" blurYFrom="0.0" blurYTo="12.0"  strength="3" color="0x000000" target="{currentTopicBox}"/>
	<mx:Glow id="glowPanel" duration="0" alphaFrom="0" alphaTo=".17" blurXFrom="0.0" blurXTo="12.0" blurYFrom="0.0" blurYTo="12.0"  strength="3" color="0x000000" target="{mapLeftPanel}"/>
	<mx:Glow id="glowPrompt" duration="0" alphaFrom="0" alphaTo=".17" blurXFrom="0.0" blurXTo="12.0" blurYFrom="0.0" blurYTo="12.0"  strength="3" color="0x000000" target="{mapOverlayPrompt}"/>
	<mx:Glow id="glowLeaderboard" duration="0" alphaFrom="0" alphaTo=".17" blurXFrom="0.0" blurXTo="12.0" blurYFrom="0.0" blurYTo="12.0"  strength="3" color="0xffda10" target="{newCommentsButton}"/>
	<mx:Glow id="glowLeaderboardBox" duration="0" alphaFrom="0" alphaTo=".17" blurXFrom="0.0" blurXTo="12.0" blurYFrom="0.0" blurYTo="12.0"  strength="3" color="0x00000" target="{leaderboardBox}"/>
    
    <mx:Fade id="welcomeFade" duration="500"/>
    <mx:Fade id="toolBarFade" duration="1000"/>
	<mx:WipeRight id="statementsShow" duration="500"/>
	<mx:WipeLeft id="statementsHide" duration="500"/>
    <mx:Resize id="welcomeResize" duration="500"/>
    <mx:NumberFormatter id="welcomeFormatter" useThousandsSeparator="true" />
    
    <mx:VBox height="100%" width="100%" horizontalAlign="right">   
            <mx:Canvas id="plotCanvas" height="100%" width="100%" verticalScrollPolicy="off" horizontalScrollPolicy="off">				
				<mx:Image width="100%" height="100%" source="{Configuration.MAP_BACKGROUND}" scaleContent="true" maintainAspectRatio="false"/>	
				
				<!-- old mask for OS2.0 arcs -->
				<mx:VBox id="mapMask" width="100%" height="100%"/>
				
				<!-- Vertical slider -->
<!--				<mx:Image id="thumbImageTop" x="{vsliderText.width + vslider.width - 30}" y="{yLowerPadding - 45 + Configuration.SLIDER_OFFSET_DOWN}" includeInLayout="false" source="{Configuration.THUMBS_UP}"/>-->
				<mx:Text  id="vsliderText" textAlign="left" fontSize="14"  text="" width="90" x="0" y="{flareVis.height/2 - vsliderText.height/2}" includeInLayout="false" paddingLeft="10"/>
				<mx:VSlider id="vslider" enabled="false" styleName="statementsPageSlider" valueCommit="handleSliderChange()" change="handleSliderChange()" liveDragging="true" showDataTip="false" sliderThumbClass="com.opinion.components.core.StateDeptLargeThumbClass" includeInLayout="false" x="{vsliderText.width + vslider.width - Configuration.SLIDER_PADDING}" y="{yLowerPadding - 20 + Configuration.SLIDER_OFFSET_DOWN}" value=".5" height="{flareVis.height + 20 - yUpperPadding - yLowerPadding}" minimum="0" maximum="1"/>
				
				<!-- The space -->
				<mx:HBox id="flareBox" autoLayout="false" top="45">
					<flex:FlareVis id="flareVis" includeInLayout="false" clipContent="false"/>
				</mx:HBox>
				
				<!-- Horizontal slider -->
				<mx:HSlider id="hslider" enabled="false" styleName="statementsPageSlider" valueCommit="handleSliderChange()" change="handleSliderChange()" liveDragging="true" showDataTip="false" sliderThumbClass="com.opinion.components.core.StateDeptLargeThumbClass" includeInLayout="false" y="{flareVis.height - hslider.height+ Configuration.SLIDER_OFFSET_DOWN + Configuration.SLIDER_PADDING}" x="{vsliderText.width + vslider.width + xLowerPadding}" value=".5" minimum="0" maximum="1" width="{flareVis.width + 20 - xLowerPadding - xUpperPadding}"/>
<!--				<mx:Image id="thumbImageBottomLeft" x="{vsliderText.width + vslider.width - Configuration.SLIDER_PADDING}" y="{flareVis.height + hslider.height - Configuration.SLIDER_PADDING/2}" includeInLayout="false" source="{Configuration.THUMBS_DOWN}"/>
				<mx:Image id="thumbImageBottomRight" x="{hslider.width + vsliderText.width + vslider.width + Configuration.SLIDER_PADDING}" includeInLayout="false" y="{flareVis.height+ hslider.height - Configuration.SLIDER_PADDING/2}" source="{Configuration.THUMBS_UP}" />-->
				<mx:Text id="hsliderText" fontSize="14" textAlign="center"  x="{vsliderText.width + vslider.width + flareVis.width/2 - hsliderText.width/2}" includeInLayout="false" y="{flareVis.height - yUpperPadding + hslider.height + Configuration.SLIDER_PADDING}" text="" width="{flareVis.width - 150}"/>				
				
				<mx:VBox id="scoreDisplayBox" width="{plotCanvas.width * .38}" right="20" top="0" styleName="firstTimeIntroPromptText" horizontalAlign="right" verticalGap="0">
					
					<!-- First time tutorial points -->
					<mx:HBox width="100%" verticalAlign="middle" visible="{!loggedIn}" includeInLayout="{!loggedIn}">
						<mx:VBox id="firstTimeScore" width="100%" horizontalAlign="right" visible="false" showEffect="{welcomeFade}">
							<mx:Text id="firstTimeExploreCounter" text="{String(Configuration.YOUR_SCORE_LANGUAGE + format_score(firstTimeUserScore)).toUpperCase() }" buttonMode="true" useHandCursor="true" mouseChildren="false" toolTip="{Configuration.YOUR_SCORE_TOOLTIP}" fontWeight="bold" fontSize="{Configuration.SCORE_SIZE}" visible="{Configuration.SHOW_SCORE}" includeInLayout="{Configuration.SHOW_SCORE}"/>
							<!-- In a box to have two effects play -->
							<mx:VBox id="claimYourSeedButton" visible="false" includeInLayout="false" showEffect="{welcomeFade}">
								<utils:LoggedButton name="claim_seed_button" label="Seed Your Idea" styleName="blueButtonLarge" click="claimYourScore()"/> <!--creationCompleteEffect="{glowButton}"/>-->	
							</mx:VBox>
							
						</mx:VBox>
					</mx:HBox>
					
					<!-- Steady state points display -->
					<mx:HBox width="100%" visible="{loggedIn}" includeInLayout="{loggedIn}">
						<mx:VBox visible="{Configuration.SHOW_SCORE}" includeInLayout="{Configuration.SHOW_SCORE}" width="100%" horizontalAlign="right">
							<mx:Text text="{String(Configuration.YOUR_SCORE_LANGUAGE +  scoreFormatter.format(oldClientScore)).toUpperCase()}" buttonMode="true" useHandCursor="true" mouseChildren="false" toolTip="{Configuration.YOUR_SCORE_TOOLTIP}" fontWeight="bold" fontSize="{Configuration.SCORE_SIZE}"/>
							<mx:Text visible="false" includeInLayout="false" text="{Configuration.YOUR_SCORE_LANGUAGE +  scoreFormatter.format(calculateClientSideScoreDifference(authorScore, reviewerScore, hasFinishedStatements, hasFinishedComment, numFullyRatedResponses))}" buttonMode="true" useHandCursor="true" mouseChildren="false" toolTip="{Configuration.YOUR_SCORE_TOOLTIP}" fontWeight="bold" fontSize="{Configuration.SCORE_SIZE}"/>
						</mx:VBox>
						<!-- Scores displayed with two text fields to enable the delayed update of the score (after animation) -->					    
						<!-- Move the new ideas + rated query here -->
					</mx:HBox>
					
					<mx:LinkButton label="What's this?" styleName="explink" visible="{!(!firstTimeScore.visible || loggedIn)}" includeInLayout="{!(!firstTimeScore.visible || loggedIn)}" click="{showScoreExplanationBox()}"/>
					<!-- snippet for vertical layouts -->
					<mx:HBox id="bloomSnippet" width="100%" verticalAlign="middle" includeInLayout="false" visible="false" styleName="snippetBox">
						<mx:Text id="snippetUsername" text="" fontWeight="bold" fontSize="16"/>
						<mx:Label id="snippetText" fontSize="14" fontWeight="normal" maxWidth="{bloomSnippet.width - snippetUsername.textWidth - snippetExpand.width - 40}" truncateToFit="true"/>
						<utils:LoggedButton id="snippetExpand" styleName="blueButton" label="Expand" click="bloomSnippet.visible = false; bloomSnippet.includeInLayout = false; if(curSelectedSprite != curUserDot) refreshCommentPanel(); else showRatingModule();"/>
					</mx:HBox> 
				</mx:VBox>
				
				<mx:VBox id="mapLeftPanel" top="{30 + 45}" width="33%" minWidth="350" height="{plotCanvas.height  - 30- Configuration.MAP_LEFT_PANEL_PADDING_BOTTOM}" styleName="mapLeftPanel" horizontalScrollPolicy="off" creationCompleteEffect="{glowPanel}">
					
					<!-- Global view, both logged in, logged out, and plot click or dot click -->
					<!--<mx:VBox width="100%" styleName="mapLeftPanelSubBox" includeInLayout="false" visible="false">
						
					</mx:VBox>-->
					
					<!-- logged in view -->
					<mx:VBox width="100%" height="100%" visible="{loggedIn}" includeInLayout="{loggedIn}">
						
						<!-- top box of mapLeftPanel -->
						<mx:VBox id="mapLeftPanelDefault" visible="{ !(!Configuration.LENSES_ENBALED || !approvedForLenses)}" includeInLayout="{ !(!Configuration.LENSES_ENBALED || !approvedForLenses)}" styleName="mapLeftPanelSubBox" width="100%">
							
							<!-- Lenses -->
							<mx:VBox width="100%" visible="{!(!Configuration.LENSES_ENBALED || !approvedForLenses)}" includeInLayout="{!(!Configuration.LENSES_ENBALED || !approvedForLenses)}">
								<mx:Text fontWeight="bold" text="{Configuration.LENSES_DISPLAY_NAME}" />
								<mx:VBox width="100%">
									<mx:HBox>
										<mx:ComboBox id="filterableKeysDropDown" dropdownStyleName="comboBoxDropDown" maxWidth="{Configuration.FILTER_FIELD_MAX_WIDTH}" itemRenderer="mx.controls.Label" textAlign="left" change="filterableKeysDropDownChange()" enabled="{!DEMO_PLAYING}" />
										<utils:LoggedButton name="lenses_color_segment" label="Separate by color" click="lensesSegmentByColor()"/>
										<utils:LoggedButton name="lenses_color_clear" label="Clear color" click="removeColorLens()"/>
									</mx:HBox>
									<mx:HBox width="100%">
										<mx:List id="possibleFilterValues" resizeEffect="{welcomeResize}" allowMultipleSelection="true" styleName="comboBoxDropDown" width="100%" itemRenderer="mx.controls.Label" textAlign="left" enabled="false"/>
										<mx:VBox>
											<utils:LoggedButton name="lenses_show_only" label="Show Only" click="filterPoints(false)"/>
											<utils:LoggedButton name="lenses_filter_out" label="Filter Out" click="filterPoints(true)"/>
											<mx:HBox>
												<utils:LoggedButton name="lenses_undo" label="Undo" click="lensesUndo()"/>
												<utils:LoggedButton name="lenses_redo" label="Redo" click="lensesRedo()"/>
											</mx:HBox>	
										</mx:VBox>
										<mx:HBox width="100%" height="100%" horizontalAlign="right" verticalAlign="middle">
											<utils:LoggedButton name="lenses_restore" label="Reset All" click="restorePoints()"/>
										</mx:HBox>
									</mx:HBox>
									<mx:VBox width="100%">
										<mx:Text text="Color Points by Response Values" />
										<mx:HBox width="100%">
											<mx:ComboBox id="stmdIdDropDown" dropdownStyleName="comboBoxDropDown" width="100%" itemRenderer="mx.controls.Label" textAlign="left" change="filterableKeysDropDownChange()" enabled="{!DEMO_PLAYING}" />
											<utils:LoggedButton name="lenses_color_points" label="Color" click="colorPointsByResponse()"/>
											<utils:LoggedButton name="lenses_color_reset" label="Reset" click="resetColorPoints()"/>
										</mx:HBox>
										<mx:VBox id="colorFocusBox" width="100%" visible="false" includeInLayout="false">
											<mx:Text text="Focus:"/>
											<mx:Canvas id="colorSliderBox" width="100%">
												<mx:HBox id="colorBar" horizontalGap="0" left="11" right ="9" bottom="8" width="100%">
												</mx:HBox>
												<core:OpinionSlider id="colorSlider" width="100%"
																	change="handleColorSliderChange()"
																	maximum="{Constants.MAX_RATING}" minimum="{Constants.MIN_RATING}" 
																	showDataTip="false" liveDragging="true" value="{(Constants.MAX_RATING - Constants.MIN_RATING) / 2}" />
												<mx:Canvas id="boundaryBarsBox" left="11" right="9" bottom="6" width="100%">
												</mx:Canvas>
											</mx:Canvas>
											<mx:Text text="Focus Range:"/>
											<core:OpinionSlider id="colorRangeSlider" width="100%"
																change="handleColorSliderChange()"
																maximum="{Constants.MAX_RATING/2}" minimum="{Constants.MIN_RATING}" 
																showDataTip="false" liveDragging="true" value="0.15" />
										</mx:VBox>
									</mx:VBox>
									<mx:VBox id="filterSummaryBox" width="100%" visible="false" includeInLayout="false" horizontalAlign="left">
										<mx:Text fontWeight="bold" text="Summary:"/>
										<mx:VBox id="summaryNotesBox" width="100%"/>
									</mx:VBox>
									<mx:HBox id="lensesColorLegend" width="100%" visible="false" includeInLayout="false">
										<mx:VBox id="legendLeft" width="50%"/>
										<mx:VBox id="legendRight" width="50%"/>
									</mx:HBox>
									
								</mx:VBox>
							</mx:VBox>
							
						</mx:VBox>
						
						<!-- rating module -->
						<mx:VBox id="leftPanelUserViewer" height="100%" width="100%" horizontalAlign="left" showEffect="{panelFade}" hideEffect="{panelFade}" styleName="mapLeftPanelSubBox">
							<mx:HBox verticalAlign="middle" width="100%">
								<mx:Image id="profile_pic" visible="{Configuration.USE_PROFILE_PIC}" includeInLayout="{Configuration.USE_PROFILE_PIC}" width="{Configuration.PROFILE_PIC_WIDTH}" height="{Configuration.PROFILE_PIC_HEIGHT}" click="{if (Configuration.PICTURE_UPLOAD_ON) {mapOverlay.showUpload();}}" toolTip="{Configuration.PROFILE_PIC_TOOLTIP}"/>
								
								<!-- Removing user name and location -->
								<mx:VBox verticalGap="0" styleName="leftPanelUserViewerText" visible="false" includeInLayout="false">
									<mx:Text id="userRegisteredUsernameText" fontWeight="bold" fontSize="20"/>
									<mx:Text id="userLocationText" visible="{Configuration.SHOW_LOCATION}" includeInLayout="{Configuration.SHOW_LOCATION}" fontWeight="bold" fontSize="20" />
									
									<!-- Scores displayed with two text fields to enable the delayed update of the score (after animation) -->
									<!--<mx:Text fontSize="15" text="{Configuration.YOUR_SCORE_LANGUAGE +  scoreFormatter.format(oldClientScore)}" buttonMode="true" useHandCursor="true" mouseChildren="false" toolTip="{Configuration.YOUR_SCORE_TOOLTIP}"/>
									<mx:Text visible="false" includeInLayout="false" text="{Configuration.YOUR_SCORE_LANGUAGE +  scoreFormatter.format(calculateClientSideScoreDifference(authorScore, reviewerScore, hasFinishedStatements, hasFinishedComment, numFullyRatedResponses))}"/>-->
								</mx:VBox>								
							</mx:HBox>
							
							<mx:VBox width="100%" visible="{Configuration.EDIT_PROFILE_ENABLED}" includeInLayout="{Configuration.EDIT_PROFILE_ENABLED}">
								<mx:VBox visible="{!hasFinishedDemographics}" includeInLayout="{!hasFinishedDemographics}" width="100%">
									<mx:Text text="{Configuration.DEMOGRAPHICS_NOT_FINISHED_TEXT}" width="100%" styleName="incompleteSignup"/>
									<utils:LoggedButton name="edit-profile" label="Edit profile" fontSize="10" enabled="true" click="{mapOverlay.showDemographicsPage(event)}" />
								</mx:VBox>
							</mx:VBox>														
						</mx:VBox> 
						
						<!-- comment module -->
						<mx:VBox id="leftPanelOtherUserViewer" width="100%" height="100%" horizontalAlign="left" verticalGap="0" includeInLayout="false" visible="false" showEffect="{panelFade}" hideEffect="{panelFade}">
							<!--<mx:Text text="VIEW OPINIONS" styleName="spacedFont"/>-->
							<mx:Box id="commentModuleWrapper" height="100%" width="100%"/>
						</mx:VBox>
						
						<mx:Box width="100%" visible="{Configuration.SHOW_DEMO}" includeInLayout="{Configuration.SHOW_DEMO}">
							<mx:HBox width="100%" visible="{displayFirstTimeInstructions}" includeInLayout="{displayFirstTimeInstructions}">
								<mx:VBox width="100%" textAlign="center" horizontalAlign="center">
									<mx:Text width="100%" styleName="demoText" text="{Configuration.FIRST_TIME_INSTRUCTION_TEXT}"/>
									<!--<mx:Image id="playButton" buttonMode="true" useHandCursor="true" source="{PLAY_BUTTON}" click="opinionSpaceDemo1()"/>-->								
								</mx:VBox>
							</mx:HBox>							
						</mx:Box>
					</mx:VBox>
					
					<!-- logged out view. 2010.09.29 this is now the first time tutorial view -->
					<mx:VBox id="mapLeftPanelLoggedOut" width="100%" height="100%" horizontalAlign="center" visible="{!loggedIn}" includeInLayout="{!loggedIn}">
						
						<!-- Removing the intro text and total number of opinions for first time intro -->						
						<mx:HBox id="numOpinionsCollected" horizontalGap="0" paddingTop="40" visible="false" includeInLayout="false">
							<mx:Text fontSize="16" text="{numberOpinionsCollected}"/>
							<mx:Text fontSize="16" text="opinions expressed."/>
						</mx:HBox>
						<mx:HBox width="100%" horizontalAlign="center" paddingTop="30" includeInLayout="false" visible="false">
							<utils:LoggedButton name="get-started" styleName="yellowButton" fontSize="15" label="Get Started!" click="{this.parentApplication.currentState = 'signup'}" textAlign="center"/>
							<utils:LoggedButton name="sign-in" styleName="bigButton" fontSize="15" label="Sign In" click="{DisplayUtils.displayPopup(this.parentApplication, 'loginForm')}" textAlign="center"/>
						</mx:HBox> 
						<!--<mx:Button styleName="yellowButton" fontSize="15" label="Login with Facebook" click="{DisplayUtils.displayPopup(this.parentApplication, 'externalLogin')}" textAlign="center" visible="{Configuration.ALLOW_EXTERNAL_LOGIN}" includeInLayout="{Configuration.ALLOW_EXTERNAL_LOGIN}"/>-->
						<mx:VBox id="introTextBox" width="100%" includeInLayout="false" visible="false">
							<mx:Text id="introText" text="{Configuration.WELCOME_TEXT_BODY}" fontSize="14" width="100%" fontWeight="normal"/>	
						</mx:VBox>
						
						<mx:VBox id="leftPanelOtherUserViewerLoggedout" width="100%" height="100%" verticalGap="0" horizontalAlign="left" includeInLayout="false" visible="false" showEffect="{panelFade}" hideEffect="{panelFade}" />
					</mx:VBox>
				</mx:VBox>
				
				<!-- Upper tool bar: visible only if statements and comments finished -->
				<mx:VBox id="upperToolBar" left="20" top="{20 + currentTopicBox.height}" visible="{!(!loggedIn || (!hasFinishedStatements || !hasFinishedComment))}" includeInLayout="{!(!loggedIn || (!hasFinishedStatements || !hasFinishedComment))}" showEffect="{toolBarFade}">
					
					<!-- To avoid having weird UI issues, we have a second container, whose visiblity can be turned off and on (the upperToolBar box is bound to several boolean fields)  -->
					<mx:VBox id="upperToolBarContent">
						<!-- Allow queries if queries enabled and lenses not enabled -->
						<mx:HBox visible="{!(!Configuration.QUERIES_ENABLED || !(!Configuration.LENSES_ENBALED || !approvedForLenses))}" includeInLayout="{!(!Configuration.QUERIES_ENABLED || !(!Configuration.LENSES_ENBALED || !approvedForLenses))}">
							<mx:Text fontWeight="bold" color="0xffffff" text="{Configuration.QUERIES_DISPLAY_NAME}" includeInLayout="{Configuration.QUERIES_DISPLAY_NAME != ''}" />
							<utils:LoggedButton name="query_all_comments" styleName="splashButtonAqua" label="{Configuration.ALL_COMMENTS_LABEL}" visible="{Configuration.ALL_COMMENTS_ENABLED}" includeInLayout="{Configuration.ALL_COMMENTS_ENABLED}" click="this.sendGetAllCurrentComments()" toolTip="{Configuration.ALL_COMMENTS_TOOLTIP}"/>
							<!--<utils:LoggedButton name="query_shuffle" styleName="splashButtonAqua" label="{Configuration.SHUFFLE_LABEL}" visible="{Configuration.SHUFFLE_ENABLED}" includeInLayout="{Configuration.SHUFFLE_ENABLED}" click="this.sendShuffle()" toolTip="{Configuration.SHUFFLE_TOOLTIP}"/>-->
							
							<!-- discussion statement drop down -->
							<mx:VBox visible="false" includeInLayout="false">
								<mx:ComboBox id="discussionQuestionsDropDown" styleName="splashButtonAqua" dropdownStyleName="comboBoxDropDown" itemRenderer="mx.controls.Label" width="{flareVis.width * .325}" textAlign="left" change="discussionStatementDropDownChange()" enabled="{!(DEMO_PLAYING || queryInProcess)}" visible="{discussionStatementDropDownActive}" includeInLayout="{discussionStatementDropDownActive}"/>								
							</mx:VBox>
						</mx:HBox>
						<!-- not needed due to query, keep code in case
						<mx:VBox paddingBottom="10" verticalGap="0">
							<mx:Text text="Options" fontWeight="bold"/>
							<mx:Button id="linesButton" label="{Configuration.SHOW_RATERS_BUTTON}" fontSize="10" click="linkResponseRaters()" enabled="{curUserRatedByUids.length!=0}" disabledColor="#555555"/>
						</mx:VBox>
						-->						
					</mx:VBox>

				</mx:VBox>

				<!-- plus one for reviewer score -->
				<mx:VBox id="plusOneBox" alpha="0" visible="false" includeInLayout="false" >
					<mx:Text id="plusText" fontSize="75" fontWeight="bold" text=""/>
				</mx:VBox>

				<!-- Demo text box -->
				<mx:VBox id="centerInstructions" visible="false" includeInLayout="false" verticalGap="0" styleName="centerBox" width="500" height="115" verticalAlign="top" hideEffect="{panelFade}" showEffect="{panelFade}">
					<mx:VBox width="100%" height="100%" verticalAlign="middle">
						<mx:Text id="demoText" styleName="centerText" width="100%" showEffect="{panelFade}"/>
					</mx:VBox>
					<mx:HBox width="100%" height="100%" verticalAlign="bottom" horizontalAlign="right">
						<mx:Button styleName="nextButton" label="Next" enabled="{!ANIMATION_PLAYING}" click="opinionSpaceDemoNext()"/>
					</mx:HBox>
				</mx:VBox>
				
				<!-- Demo white arrow -->
				<!--<mx:VBox id="demoArrowBox" visible="{demoState == 2 || demoState == 4}" includeInLayout="{demoState == 2 || demoState == 4}" showEffect="{panelFade}" hideEffect="{panelFade}">
					<mx:Image source="{WHITE_ARROW}"/>
				</mx:VBox>-->
				
				<!-- Score display box -->
				<mx:VBox id="scoreDisplayBox1" width="{plotCanvas.width * .38}" right="20" top="10" styleName="firstTimeIntroPromptText" horizontalAlign="left" visible="{loggedIn}" includeInLayout="{loggedIn}">
				<mx:HBox id="queryBox" paddingLeft="60">
					<!--<utils:LoggedButton id="leaderboardButton" creationCompleteEffect="{glowLeaderboard}" name="query_leaderboard" styleName="blueButton" buttonMode="true" label="{Configuration.LEADERBOARD_LABEL}" visible="{Configuration.LEADERBOARD_ENABLED}" includeInLayout="{Configuration.LEADERBOARD_ENABLED}" click="this.sendGetLeaderboardUsers()" toolTip="{Configuration.LEADERBOARD_TOOLTIP}" />-->					
					<utils:LoggedButton id="ratedButton" buttonMode="true" label="{Configuration.RATED_LABEL}" name="rated-comments-query" toolTip="{Configuration.RATED_TOOLTIP}" click="sendGetRatedUsers()" visible="{Configuration.RATED_ENABLED}" includeInLayout="{Configuration.RATED_ENABLED}"/>
				</mx:HBox>	
					</mx:VBox>
				
				<!-- First time intro initial prompt -->
				<mx:HBox id="firstTimeIntroPrompt" width="60%" verticalAlign="middle" x="15" top="{20 + currentTopicBox.height}" showEffect="{welcomeFade}" visible="false" includeInLayout="false" paddingRight="20" horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<mx:HBox styleName="firstTimeIntroPrompt" width="100%">
						<mx:Text id="firstTimeIntroPromptText" styleName="firstTimeIntroPromptText" width="100%" />
					</mx:HBox>
				</mx:HBox>
				
				<!-- done box for 2 statements placing point -->
				<mx:VBox id="done_box" visible="false" includeInLayout="false" right="0" top="0" verticalAlign="middle" horizontalAlign="center" height="50%" width="30%" showEffect="{welcomeFade}">
					<utils:LoggedButton styleName="splashButton" label="Next!" click="{openSignupPage()}" textAlign="center"/>
				</mx:VBox>
				
				<!-- General notification text -->
				<mx:HBox id="mapNotificationPrompt" verticalAlign="middle" width="100%" left="15" y="{20 + currentTopicBox.height}" showEffect="{welcomeFade}" hideEffect="{welcomeFade}" visible="false" includeInLayout="false" paddingRight="60" horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<mx:Text id="mapNotificationPromptText" width="100%" fontWeight="normal" styleName="firstTimeIntroPromptText" />	
				</mx:HBox>
				
				<mx:HBox id="meTxtBox" visible="{Configuration.RATING_MODULE_VISIBLE}" />
				
				<mx:HBox id="legendBox" bottom="10" left="10" visible="{Configuration.SHOW_LEGEND}">
					<mx:HBox width="135">
						<mx:HBox width="50%" horizontalAlign="left" paddingTop="10">
							<mx:Text fontSize="10" width="55" textAlign="center" text="Less Agreeable" fontWeight="bold" fontFamily="Arial" />	
						</mx:HBox>
						<mx:HBox width="50%" horizontalAlign="right" paddingTop="10">
							<mx:Text fontSize="10" width="55" textAlign="center" text="More Agreeable" fontWeight="bold" fontFamily="Arial" />	
						</mx:HBox>	
					</mx:HBox>
					<mx:HBox width="130">
						<mx:HBox width="50%" horizontalAlign="left" paddingTop="10">
							<mx:Text fontSize="10" width="55" textAlign="center" text="Less Insightful" fontWeight="bold" fontFamily="Arial" />	
						</mx:HBox>
						<mx:HBox width="50%" horizontalAlign="right" paddingTop="10">
							<mx:Text fontSize="10" width="55" textAlign="center" text="More Insightful" fontWeight="bold" fontFamily="Arial" />	
						</mx:HBox>	
					</mx:HBox>
				</mx:HBox>
				
				<mx:HBox id="leaderBox" top="15" left="20" visible="{hasFinishedComment}" includeInLayout="{hasFinishedComment}">
					<utils:LoggedButton id="newCommentsButton" creationCompleteEffect="{glowLeaderboard}" styleName="blueButton" label="{Configuration.SHUFFLE_LABEL}" name="new-comments-query" buttonMode="true" fontSize="18" toolTip="{Configuration.SHUFFLE_TOOLTIP}" click="sendGetNeverSeenComments()" visible="false" includeInLayout="false"/>
					
					<!--<utils:LoggedButton id="leaderboardButton" creationCompleteEffect="{glowLeaderboard}" name="query_leaderboard" styleName="blueButton" buttonMode="true" fontSize="18" label="Top Rated" click="this.sendGetLeaderboardUsers()" toolTip="{Configuration.LEADERBOARD_TOOLTIP}" />-->
				</mx:HBox>
				
				<!-- Discussion Question -->
				<mx:HBox id="currentTopicContent" width="57%" x="15" top="10" visible="false" includeInLayout="false">
					<mx:VBox horizontalAlign="center" id="currentTopicBox" width="100%" styleName="discussionQuestionBox" verticalGap="0" creationCompleteEffect="{glowQuestion}" visible="{!mapOverlayPrompt.visible}">
						<mx:Text id="currentTopicHeader" paddingTop="5" visible="false" includeInLayout="false" showEffect="{textIn}"/>	
						<mx:LinkButton id="optionalButton" label="" styleName="signin" visible="false" includeInLayout="false" click="optionalButtonCallback()"/>
						<mx:Text id="currentTopicText" paddingTop="5" visible="false" includeInLayout="false"/>
					</mx:VBox>
					
					<!-- Leaderboard -->				
					
				</mx:HBox> 	
				
				<mx:VBox id="leaderboardBox" width="400" left="50" top="20" visible="{!(!hasFinishedComment || currentTopicContent.visible || !Configuration.LEADERBOARD_ENABLED)}" includeInLayout="{!(!hasFinishedComment || currentTopicContent.visible || !Configuration.LEADERBOARD_ENABLED)}" styleName="leaderboardBox" showEffect="{panelFade}" hideEffect="{panelFade}" verticalGap="0" creationCompleteEffect="{glowLeaderboardBox}">	
					<!-- controls -->
					<mx:HBox fontSize="10" letterSpacing="0.5" paddingTop="3" horizontalGap="0">
						<mx:VBox verticalGap="0" visible="{Configuration.LIST_1_ENABLED}" includeInLayout="{Configuration.LIST_1_ENABLED}">
							<mx:HBox id="topAuthorHeaderBox" verticalAlign="middle" styleName="leaderBoardHeaderBox" horizontalGap="0">
								<mx:Text id="topAuthorControlText" fontWeight="bold" fontSize="12" text="{Configuration.LIST_1}" mouseChildren="false" buttonMode="true" useHandCursor="true" click="toggleAuthorControl()" mouseOver="listControlOver(topAuthorControl, topAuthorControlText);" mouseOut="listControlOut(topAuthorControl, topAuthorControlText);"/>
								<mx:Image id="topAuthorControl" buttonMode="true" useHandCursor="true" source="{CLOSED_LIST_IMAGE}" click="toggleAuthorControl()" mouseOver="listControlOver(topAuthorControl, topAuthorControlText);" mouseOut="listControlOut(topAuthorControl, topAuthorControlText);"/>
							</mx:HBox>
						</mx:VBox>
						<mx:VBox verticalGap="0" visible="{Configuration.LIST_2_ENABLED}" includeInLayout="{Configuration.LIST_2_ENABLED}">
							<mx:HBox id="topReviewerHeaderBox" fontWeight="bold" fontSize="12" verticalAlign="middle" styleName="leaderBoardHeaderBox" horizontalGap="0">
								<mx:Text id="topReviewerControlText" text="{Configuration.LIST_2}" mouseChildren="false" buttonMode="true" useHandCursor="true" click="toggleReviewerControl()" mouseOver="listControlOver(topReviewerControl, topReviewerControlText);" mouseOut="listControlOut(topReviewerControl, topReviewerControlText);"/>
								<mx:Image id="topReviewerControl" buttonMode="true" useHandCursor="true" source="{CLOSED_LIST_IMAGE}" click="toggleReviewerControl()" mouseOver="listControlOver(topReviewerControl, topReviewerControlText);" mouseOut="listControlOut(topReviewerControl, topReviewerControlText);"/>
							</mx:HBox>
						</mx:VBox>
						<mx:VBox verticalGap="0" visible="{Configuration.LIST_3_ENABLED}" includeInLayout="{Configuration.LIST_3_ENABLED}">
							<mx:HBox id="risingAuthorHeaderBox" verticalAlign="middle" styleName="leaderBoardHeaderBox" horizontalGap="0">
								<mx:Text id="risingAuthorControlText" text="{Configuration.LIST_3}" mouseChildren="false" buttonMode="true" useHandCursor="true" click="toggleRisingAuthorControl()" mouseOver="listControlOver(risingAuthorControl, risingAuthorControlText);" mouseOut="listControlOut(risingAuthorControl, risingAuthorControlText);"/>
								<mx:Image id="risingAuthorControl" buttonMode="true" useHandCursor="true" source="{CLOSED_LIST_IMAGE}" click="toggleRisingAuthorControl()" mouseOver="listControlOver(risingAuthorControl, risingAuthorControlText);" mouseOut="listControlOut(risingAuthorControl, risingAuthorControlText);"/>
							</mx:HBox>
						</mx:VBox>								
					</mx:HBox>
					
					<!-- actual lists -->
					<mx:HBox horizontalAlign="left" horizontalGap="0" width="100%">
						<mx:List id="leftList" textAlign="left" itemClick="leaderBoardClick(event)" styleName="leaderBoardList" rowCount="5" width="50%" visible="false" includeInLayout="false"/>								
						<mx:List id="rightList" textAlign="left" itemClick="leaderBoardClick(event)" styleName="leaderBoardList" rowCount="5" width="50%" visible="false" includeInLayout="false"/>								
					</mx:HBox>	
				</mx:VBox>
				
				<mx:Text id="loadingText" left="500" top="20" text="LOADING..." fontSize="25" color="0x646462" fontWeight="bold" visible="{queryInProcess}" includeInLayout="{queryInProcess}"/>
				<spinner:Spinner visible="false" includeInLayout="false"/>
					
				
				
				<!-- Map cover mask for mapOverlay components -->
				<mx:Canvas id="mapOverlayMask" width="100%" height="100%" visible="false" includeInLayout="false" backgroundColor="0xffffff" backgroundAlpha=".5"/>

				<!-- Map overlay - dual text -->
				<mx:VBox id="mapOverlayPrompt" styleName="discussionQuestionBox" width="57%" left="15" top="10" verticalGap="0" showEffect="{welcomeFade}" visible="false" includeInLayout="false" horizontalScrollPolicy="off" verticalScrollPolicy="off" creationCompleteEffect="{glowPrompt}">
					<mx:HBox width="100%" verticalAlign="middle" >
						<mx:Text id="mapOverlayPromptText" color="#b9b7b3" fontWeight="bold" fontSize="40"/>
						<mx:Text id="mapOverlayPromptSubText" width="100%" leading="0" />	
					</mx:HBox>
					
					<!-- error text if needed -->
					<mx:HBox width="100%">
						<mx:Text id="mapOverlayPromptSubErrorText" fontSize="14" fontFamily="Arial" width="100%" color="0xff0000" fontWeight="bold" visible="false" includeInLayout="false" paddingTop="10"/>	
					</mx:HBox>
					
				</mx:VBox>
				
				<!-- Area on the right of mapLeftPanel -->
				<mx:VBox id="mapRightArea" width="100%" height="100%">
					<!-- overlay of states on top of map -->
					<local:MapOverlay id="mapOverlay" currentState="empty" width="100%" height="100%" verticalAlign="top"/>	
				</mx:VBox>
				
				<!-- Note: Everything below is currently unusued. Please only remove if necessary as there are sections of code that may be used again -->

				<!-- The map top bar is unused, and thus hidden. There are some button definitions that may be used in the future, i.e. refresh, fullscreen, and help -->
			<!--	<mx:HBox id="mapTopBar" width="100%" left="0" top="0" horizontalGap="0" visible="false" includeInLayout="false">
					<mx:VBox id="topAuthorBox" width="130" verticalGap="0" visible="{loggedIn}">
						<mx:HBox id="topAuthorText" styleName="leaderBoardText" width="100%" height="28">
							<mx:HBox paddingTop="8">
								<mx:Text text=" Top authors"/>
						<mx:Image id="topAuthorControl" buttonMode="true" useHandCursor="true" source="{CLOSED_LIST_IMAGE}" click="toggleAuthorControl()"/>	
							</mx:HBox>
						</mx:HBox>
						<mx:HBox paddingLeft="5" width="100%">
							<mx:List id="topAuthorList" textAlign="right" itemClick="leaderBoardClick(event);" styleName="leaderBoardList" width="95%" verticalScrollPolicy="off" rowCount="10" visible="false" showEffect="{wipeDown}" hideEffect="{wipeUp}"/>
						</mx:HBox>
					</mx:VBox>
					<mx:VBox id="topReviewerBox" width="130" verticalGap="0" paddingLeft="1" visible="{loggedIn}">
						<mx:HBox id="topReviewerText" styleName="leaderBoardText" width="100%" height="28" verticalAlign="bottom" paddingBottom="2">
							<mx:HBox paddingTop="8">
								<mx:Text text=" Top reviewers"/>
									<mx:Image id="topReviewerControl" buttonMode="true" useHandCursor="true" source="{CLOSED_LIST_IMAGE}" click="toggleReviewerControl()"/>
							</mx:HBox>
						</mx:HBox>
						<mx:HBox paddingLeft="5" width="100%">
							<mx:List id="topReviewerList" textAlign="right" itemClick="leaderBoardClick(event);" styleName="leaderBoardList" width="95%" verticalScrollPolicy="off" rowCount="10" visible="false" showEffect="{wipeDown}" hideEffect="{wipeUp}"/>
						</mx:HBox>
					</mx:VBox>
					<mx:VBox width="100%" paddingLeft="10" verticalGap="0">
						<mx:HBox styleName="myScoresBox" visible="{loggedIn}" height="28">
							<mx:HBox horizontalAlign="center" height="100%">
								<mx:Text id="authorScoreText" text="Your author score" paddingTop="8" buttonMode="true" useHandCursor="true" mouseChildren="false" click="toggleResponseStats()" mouseOver="highlightAuthorText()" mouseOut="restoreAuthorText()"/>
								<mx:Text id="authorScoreNumber" styleName="myScoresText" text="{scoreFormatter.format(authorScore)}" paddingTop="2" buttonMode="true" useHandCursor="true" mouseChildren="false" click="toggleResponseStats()" mouseOver="highlightAuthorText()" mouseOut="restoreAuthorText()"/>
					 	   		<mx:Text text="Your reviewer score" paddingTop="8"/>
					 	   		<mx:Text styleName="myScoresText" text="{scoreFormatter.format(reviewerScore)}" paddingTop="2"/> 
							</mx:HBox>
							<mx:VBox height="85%" backgroundColor="#001f37" width="1"/>
				 	   		<mx:HBox autoLayout="false" paddingTop="1">
				 	   			<mx:Image id="showMyOpinionsButton" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{SHOW_MY_OPINIONS_ICON}" click="showHideRatingModule()" toolTip="Your opinion dashboard"/>
				 	   			<mx:Image id="showMeButton" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{SHOW_ME_ICON}" click="findUser()" toolTip="Your location"/>	
				 	   		</mx:HBox>
						</mx:HBox>
						<mx:VBox id="responseStats" styleName="myScoresSubBox" visible="false" horizontalAlign="left" verticalGap="2">
							<mx:HBox verticalAlign="middle" horizontalGap="0" paddingTop="4" paddingRight="8" paddingBottom="4">
								<mx:Text text="{curUserRatedByUids.length} users that have rated your response" paddingLeft="8" paddingRight="8"/>
								<mx:Button id="linesButton" label="Show" click="linkResponseRaters()" enabled="{curUserRatedByUids.length!=0}" disabledColor="#555555"/>								
							</mx:HBox>
						</mx:VBox>
					</mx:VBox>
					<mx:HBox width="100%" horizontalAlign="right">
						<mx:Text id="refreshingLabel" text="Refreshing..." paddingRight="20" paddingTop="10" styleName="refreshLabel" visible="false"/>
						<mx:HBox id="toolBarBox" styleName="toolBarBox" autoLayout="false" height="28">
							<mx:Image id="refreshIconButton" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{REFRESH_ICON}" click="{this.parentApplication.sendRefreshOS()}" toolTip="Refresh"/>
			 	   			<mx:Image id="fullscreenButton" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{FULLSCREEN_ICON}" click="{this.parentApplication.toggleFullScreen()}" toolTip="Fullscreen"/>
							<mx:Image id="helpIconButton" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{HELP_ICON}" click="showHideHelp()" toolTip="Help"/>
						</mx:HBox>
					</mx:HBox>
				</mx:HBox> -->
				
				<!-- Original help text that would lie above the space, now unused -->
              <!--  <mx:VBox width="100%" height="100%" verticalAlign="bottom" paddingBottom="5" verticalGap="0" visible="false" includeInLayout="false">   
                	<mx:HBox width="100%" horizontalAlign="right" paddingRight="15" paddingBottom="15"> 
                        <mx:VBox id="helpBox" styleName="helpBox" width="240" visible="false"> 
                            <mx:Text styleName="helpText" width="100%">
								<mx:htmlText>
                                <![CDATA[Click on any point to read and rate a specific user's response to the discussion question. Each point's size reflects how other users have rated the comment.

Blue points in the Opinion Space are "landmarks" (public figures). Their locations in the space correspond to research-based "educated extrapolations" to determine where they would likely stand on a given issue.

Once you sign up, click on your point or the "Show My Opinions" button to change your ratings. <b>Tip</b>: we suggest using the Opinion Dashboard to see how changes of your ratings affect your standing relative to the landmarks!

<a href='http://www.youtube.com/watch?v=c4sHYzh7qHU' target='_blank'><b>Click here</b></a> to view a video walkthrough of Opinion Space!]]>
                                </mx:htmlText>
                            </mx:Text>
                 		</mx:VBox>
                 	</mx:HBox> -->
                 	
                 	<!-- zoom controls, now usued -->
			<!--		<mx:HBox width="100%" autoLayout="false" paddingLeft="20" paddingBottom="10">
						<mx:Image id="zoomInIcon" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{ZOOM_IN_ICON}" click="doZoomIncrement()" toolTip="Zoom In"/>	
                        <ns1:ZoomSlider   
                                 id="zoomSlider" 
                                 width="100%"
                                 minimum="{ZOOM_SLIDER_MIN}"
                                 maximum="{ZOOM_SLIDER_MAX}"  
                                 change="doZoom()"
                                 liveDragging="true"
                                 tickInterval="0.25"
                                 snapInterval="0.25" visible="false" includeInLayout="false"/> 
 						<mx:Image id="zoomOutIcon" mouseDownEffect="{shrink}" mouseUpEffect="{revert}" buttonMode="true" useHandCursor="true" source="{ZOOM_OUT_ICON}" click="doZoomDecrement()" toolTip="Zoom Out"/>	
                 	</mx:HBox>       
                </mx:VBox> -->

             <!--   <mx:VBox width="100%" height="100%" horizontalAlign="center" verticalAlign="top" paddingTop="200"> 
                     <mx:HBox id="fullscreenWarningBox" width="600" horizontalAlign="center" styleName="fullscreenWarningBox" hideEffect="{panelFade}" showEffect="{panelFade}" visible="false"> 
                             <mx:Text styleName="fullScreenWarningText" text="Warning: keyboard disabled in fullscreen mode!"/> 
                     </mx:HBox> 
                </mx:VBox> -->
				
				<!-- Old intro box for OS 2.0 - now unused and hidden 
                <mx:VBox width="100%" height="100%" horizontalAlign="left" verticalAlign="top">
                    <mx:VBox styleName="opinionMapWelcome" visible="false" includeInLayout="false" resizeEffect="welcomeResize">
	                    <mx:VBox id="mainWelcomeBox" horizontalAlign="left" verticalGap="0" >
	                    	<mx:Text fontSize="25" text="Welcome to Opinion Space!"/>
	                    	<mx:HBox horizontalGap="0">
	                    		<mx:Text fontSize="20" text="{numberOpinionsCollected}"/>
	                    		<mx:Text fontSize="20" text="opinions collected."/>
	                    	</mx:HBox>
	                    	<mx:HBox>
	                    		<mx:Button id="welcomeInfoButton" fontSize="15" styleName="bigButton" label="Tell me more" click="displayWelcomeInfo()"/>
	                    		<mx:Button styleName="yellowButton" fontSize="15" label="Get Started!" click="{this.parentApplication.currentState = 'signup'}" textAlign="center"/>
	                    		<mx:Button styleName="bigButton" fontSize="15" label="Sign In" click="{DisplayUtils.displayPopup(this.parentApplication, 'loginForm')}" textAlign="center"/>
	                    	</mx:HBox>                    	
	                    </mx:VBox>
						<mx:VBox id="secondaryWelcomeBox" height="150" width="840" horizontalScrollPolicy="off" verticalGap="0" includeInLayout="false" visible="false">
							<mx:Text fontSize="20" width="825">
								<mx:htmlText>
									<![CDATA[The U.S. Department of State wants to hear your perspectives and ideas about pressing foreign policy questions. Designed to engage a broad community of citizens, Opinion Space is unlike conventional maps.  Every participant is represented by a reference point.  The map is not based on geography or predetermined categories.  Instead, the layout is based on similarity of opinion: those who agree on basic issues are neighbors, those who are far apart have agreed to disagree.  Insightful comments can emerge from anywhere on the map.
									
Click the highlighted points to read the comments rated most insightful. (Click the "About" tab for more details, or click "Get started" to try it!)]]>
								</mx:htmlText>
							</mx:Text>
							<mx:Button styleName="bigButton" fontSize="15" label="Hide" click="displayWelcomeInfo()" textAlign="center"/>	
						</mx:VBox>
                    </mx:VBox>
                </mx:VBox>-->
            </mx:Canvas>
    </mx:VBox>
</mx:Module>